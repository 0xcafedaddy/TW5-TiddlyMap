{"version":3,"sources":["felixhayashi/tiddlymap/js/lib.EdgeTypeSubscriberRegistry.js"],"names":["EdgeTypeSubscriberRegistry","subscribers","allEdgeTypes","_classCallCheck","this","subscriberClasses","updateIndex","allSubscribers","subscribersForType","i","l","length","canHandle","edgeType","push","skipOthers","subscriberClass","moduleName","subscriber","ignore","sort","s1","s2","priority"],"mappings":";;;;;;;;;;;GAiBMA,uCAMJ,QAAAA,GAAYC,EAAaC,GAAcC,gBAAAC,KAAAJ,EAErCI,MAAKC,kBAAoBJ,CACzBG,MAAKE,YAAYJ,yDADZG,GAGN,GAAAE,GAAAH,KAAAG,cAWC,IAAMC,KAEN,KAAK,GAAIC,GAAI,EAAGC,EAAIH,EAAeI,OAAQF,EAAIC,EAAGD,IAAK,CAErD,GAAIF,EAAeE,GAAGG,UAAUC,GAAW,CAEzCL,EAAmBM,KAAKP,EAAeE,GAEvC,IAAIF,EAAeE,GAAGM,WAAY,CAChC,QATN,MAAMP,sCAWH,MAAAJ,MAAAG,qDA2BOL,GAEV,GAAMK,KAGN,IAAMS,GAAkBZ,KAAKC,iBAd/B,KAAA,GAAAY,KAAAD,GAAA,CAiBI,GAAME,GAAa,GAAKF,GAAgBC,GAAaf,EAGrD,IAAIgB,EAAWC,SAAW,KAAM,CAC9B,SAGFZ,EAAeO,KAAKI,GAItBX,EAAea,KAAK,SAACC,EAAIC,GAAL,MAAYA,GAAGC,SAAWF,EAAGE,UAEjDnB,MAAKG,eAAiBA,kCAXpBP","file":"../../../../felixhayashi/tiddlymap/js/lib.EdgeTypeSubscriberRegistry.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeTypeSubscriberRegistry\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**\n * Registry to store and retrieve EdgeTypeSubcriber modules that are responsible\n * for handling the retrieval, insertion and deletion of EdgeType objects.\n *\n\n */\nclass EdgeTypeSubscriberRegistry {\n\n  /**\n   * @param {AbstractEdgeTypeSubscriber[]} subscribers\n   * @param {EdgeType[]} allEdgeTypes\n   */\n  constructor(subscribers, allEdgeTypes) {\n\n    this.subscriberClasses = subscribers;\n    this.updateIndex(allEdgeTypes);\n\n  }\n\n  /**\n   * Gets all matching subscribers for a type.\n   *\n   * @param {EdgeType} edgeType\n   * @returns AbstractEdgeTypeSubscriber[]\n   */\n  getAllForType(edgeType) {\n\n    const allSubscribers = this.allSubscribers;\n    const subscribersForType = [];\n\n    for (let i = 0, l = allSubscribers.length; i < l; i++) {\n\n      if (allSubscribers[i].canHandle(edgeType)) {\n\n        subscribersForType.push(allSubscribers[i]);\n\n        if (allSubscribers[i].skipOthers) {\n          break;\n        }\n      }\n    }\n\n    return subscribersForType;\n\n  }\n\n  /**\n   * Gets all subscribers.\n   *\n   * @returns AbstractEdgeTypeSubscriber[]\n   */\n  getAll() {\n\n    return this.allSubscribers;\n\n  }\n\n  /**\n   * Indexes all subscribers. Moreover, subscribers get linked to the edge\n   * types that currently exist in the wiki.\n   *\n   * This method should be called everytime after an edge type is added or\n   * removed in the system.\n   *\n   * @param {EdgeType[]} allEdgeTypes\n   */\n  updateIndex(allEdgeTypes) {\n\n    const allSubscribers = [];\n\n    // instantiate and register all active subscriber modules\n    const subscriberClass = this.subscriberClasses;\n    for (let moduleName in subscriberClass) {\n\n      const subscriber = new (subscriberClass[moduleName])(allEdgeTypes);\n\n      // ignore all subscribers that have their ignore flag set to false\n      if (subscriber.ignore === true) {\n        continue;\n      }\n\n      allSubscribers.push(subscriber);\n    }\n\n    // sort subscribers by priority\n    allSubscribers.sort((s1, s2) => s2.priority - s1.priority);\n\n    this.allSubscribers = allSubscribers;\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport default EdgeTypeSubscriberRegistry;\n"],"sourceRoot":"../../../../../src/plugins"}