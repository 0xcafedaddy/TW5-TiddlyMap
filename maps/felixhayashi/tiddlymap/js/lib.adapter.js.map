{"version":3,"sources":["felixhayashi/tiddlymap/js/lib.adapter.js"],"names":["_ViewAbstraction","require","_EdgeType","_NodeType","_utils","_Edge","_vis","_contrastcolour","Adapter","_classCallCheck","this","indeces","$tm","services","wiki","$tw","visShapesWithTextInside","_utils2","default","getLookupTable","edge","_processEdge","edges","convert","i","length","deleteEdge","action","logger","fromTRef","from","tObj","getTiddler","type","allETy","_EdgeType2","handlers","edgeTypeSubscriberRegistry","getAllForType","fn","exists","save","groupBy","opts","arguments","undefined","start","getMatches","selector","allPotentialNodes","getEdgesForSet","tRefs","toWL","typeWL","adjList","groupByProperty","stop","matches","_this","addProperties","steps","_indeces","tById","idByT","visited","getArrayValuesAsHashmapKeys","view","_ViewAbstraction2","allEdgesLeadingToNeighbours","makeHashMap","allNeighbours","maxSteps","parseInt","direction","getConfig","isWalkBoth","isWalkIn","isWalkOut","getAdjacencyList","addAsNeighbour","role","neighboursOfThisStep","id","tRef","node","makeNode","push","step","isSystemOrDraft","outgoing","t","toArrow","invertedArrow","j","incoming","nodes","neighbourhood","_ref","getNodeFilter","neighScope","graph","selectNodesByReferences","outputType","getNeighbours","group","Object","assign","ndoes","neighbours","isEnabled","nodeTRefs","getTiddlersById","removeObsoleteViewData","attachStylesToNodes","tiddler","getAll","eTySubscribers","l","tiddlers","getEdges","getAllPotentialNodes","newName","selectEdgesByType","newType","load","deleteTiddler","fullPath","_ref3","result","keys","nodeIds","options","selectNodesByIds","protoNode","merge","label","fields","field","nodeLabel","renderText","title","src","protoByTRef","glNTy","inheritors","getInheritors","proto","style","inheritedStyles","getInheritedNodeStyles","viewNodeData","getNodeData","isStaticMode","faIcon","twIcon","color","x","y","isColorObject","_typeof","background","border","addNodeIcon","shape","font","run","icon","glNTyById","fixed","allViews","viewRefs","removeNode","saveNodeData","deleteEdges","ids","deleteNode","positions","isForce","protoTiddler","generateNewTitle","getRandomLabel","Tiddler","text","tmap.id","getCreationFields","addTiddler","addNode","Array","isArray","_vis2","DataSet","getTiddlerRef","getFAdigits","str","substr","face","code","String","fromCharCode","imgTObj","getModificationFields","getDataUri","data","obsoleteDataItems","getLabel","addStyleToEdge","isTrue"],"mappings":"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","file":"../../../../felixhayashi/tiddlymap/js/lib.adapter.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Adapter\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport ViewAbstraction              from '$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction';\nimport EdgeType                     from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport NodeType                     from '$:/plugins/felixhayashi/tiddlymap/js/NodeType';\nimport utils                        from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport Edge                         from '$:/plugins/felixhayashi/tiddlymap/js/Edge';\nimport vis                          from '$:/plugins/felixhayashi/vis/vis.js';\nimport { run as getContrastColour } from '$:/core/modules/macros/contrastcolour.js';\n\n/***************************** CODE ********************************/\n\n/**\n * This library acts as an abstraction layer above the tiddlywiki\n * system. All the provided methods give the api-user the chance\n * to interact with tiddlywiki as if it was a simple graph database.\n *\n * Everything that is related to retrieving or inserting nodes and\n * edges is handled by the adapter class.\n *\n * You don't need to create your own instance of this class.\n * The adapter service may be accessed from anywhere using\n * `$tm.apapter`.\n *\n * @constructor\n */\nclass Adapter {\n\n  constructor() {\n\n    this.indeces = $tm.indeces;\n    this.services = $tm.services;\n    this.wiki = $tw.wiki;\n\n    this.visShapesWithTextInside = utils.getLookupTable([\n      'ellipse', 'circle', 'database', 'box', 'text'\n    ]);\n\n  }\n\n  /**\n   * This function will delete the specified edge object from the system.\n   *\n   * @param {Edge} edge - The edge to be deleted. The edge necessarily\n   *     needs to possess an `id` and a `from` property.\n   * @return {Edge} The deleted edge is returned.\n   */\n  deleteEdge(edge) {\n\n    return this._processEdge(edge, 'delete');\n\n  }\n\n  /**\n   * Persists an edge by storing the vector (from, to, type).\n   *\n   * @param {Edge} edge - The edge to be saved. The edge necessarily\n   *     needs to possess a `to` and a `from` property.\n   * @return {Edge} The newly inserted edge.\n   */\n  insertEdge(edge) {\n\n    return this._processEdge(edge, 'insert');\n\n  }\n\n  /**\n   * Removes multiple edges from several stores.\n   *\n   * @param {EdgeCollection} edges - The edges to be deleted.\n   */\n  deleteEdges(edges) {\n\n    edges = utils.convert(edges, 'array');\n    for (let i = edges.length; i--;) {\n      this.deleteEdge(edges[i]);\n    }\n\n  }\n\n  /**\n   * Private function to handle the insertion or deletion of an edge.\n   * It prepares the process according to the action type and delegates\n   * the task to more specific functions.\n   *\n   * @private\n   * @return {Edge} The processed edge.\n   */\n  _processEdge(edge, action) {\n\n    $tm.logger('debug', 'Edge', action, edge);\n\n    // get from-node and corresponding tiddler\n    const fromTRef = this.indeces.tById[edge.from];\n\n    if (!fromTRef || !utils.tiddlerExists(fromTRef)) {\n      return;\n    }\n\n    const tObj = utils.getTiddler(fromTRef);\n    const type = this.indeces.allETy[edge.type] || new EdgeType(edge.type);\n    const handlers = this.services.edgeTypeSubscriberRegistry.getAllForType(type);\n    const fn = `${action}Edge`;\n\n    for (let i = handlers.length; i--;) {\n      (handlers[i][fn])(tObj, edge, type);\n    }\n\n    // if type didn't exist yet, create it\n    if (action === 'insert' && !type.exists()) {\n      type.save();\n    }\n\n    return edge;\n\n  }\n\n  /**\n   * This function will return an adjacency list for the nodes\n   * present in the current system. The list may be restricted by\n   * optional filters.\n   *\n   * @param {string} [groupBy='to'] - Specifies by which property the\n   *     adjacency list is indexed. May be either 'from' or 'to'.\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edge-types are included.\n   * @param {Hashmap} [opts.edges] - A set of edges on which basis\n   *     the adjacency list is build. If not provided,\n   *     all edges in the system are considered.\n   * @return {Object<Id, Array<Edge>>} For each key (a node id) an\n   *     array of edges pointing 'from' (or 'to'; depends on `groupBy`)\n   *     is supplied as value.\n   */\n  getAdjacencyList(groupBy, opts = {}) {\n\n    $tm.start('Creating adjacency list');\n\n    if (!opts.edges) {\n      const tRefs = utils.getMatches($tm.selector.allPotentialNodes);\n      opts.edges = this.getEdgesForSet(tRefs, opts.toWL, opts.typeWL);\n    }\n\n    const adjList = utils.groupByProperty(opts.edges, groupBy || 'to');\n\n    $tm.stop('Creating adjacency list');\n\n    return adjList;\n\n  }\n\n  /**\n   * This function will return all neighbours of a graph denoted by\n   * a set of tiddlers.\n   *\n   * @todo parts of this code may be outsourced into a function to\n   * prevent repeating code.\n   *\n   * @param {Array<TiddlerReference>} matches - The original set that\n   *     defines the starting point for the neighbourhood discovery\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edges are travelled to reach a neighbour.\n   * @param {Hashmap} [opts.edges] - An initial set of edges that is\n   *    used in the first step to reach immediate neighbours, if no\n   *    set of edges is specified, all exsisting edges will be considered.\n   * @param {number} [opts.steps] - An integer value that specifies\n   *    the scope of the neighbourhood. A node is considered a neighbour\n   *    if it can be reached within the given number of steps starting\n   *    from original set of tiddlers returned by the node filter.\n   * @param {Hashmap} [opts.addProperties] - a hashmap\n   *     containing properties to be added to each node.\n   *     For example:\n   *     {\n   *       group: 'g1',\n   *       color: 'red'\n   *     }\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all neighbouring nodes* },\n   *       edges: { *all edges connected to neighbours* },\n   *     }\n   */\n  getNeighbours(matches, opts = {}) {\n\n    $tm.start('Get neighbours');\n\n    const { addProperties, toWL, typeWL, steps } = opts;\n    const { allETy, tById, idByT } = this.indeces;\n\n    // index of all tiddlers have already are been visited, either by\n    // having been included in the original set, or by having been\n    // recorded as neighbour during the discovery.\n    const visited = utils.getArrayValuesAsHashmapKeys(matches);\n    const view = new ViewAbstraction(opts.view);\n    const allEdgesLeadingToNeighbours = utils.makeHashMap();\n    const allNeighbours = utils.makeHashMap();\n    const maxSteps = (parseInt(steps) > 0 ? steps : 1);\n    const direction = (opts.direction || (view.exists() && view.getConfig('neighbourhood_directions')));\n    const isWalkBoth = (!direction || direction === 'both');\n    const isWalkIn = (isWalkBoth || direction === 'in');\n    const isWalkOut = (isWalkBoth || direction === 'out');\n\n    // adjacency receives whitelists through opts\n    const adjList = this.getAdjacencyList('to', opts);\n\n    const addAsNeighbour = (edge, role, neighboursOfThisStep) => {\n      allEdgesLeadingToNeighbours[edge.id] = edge;\n      const tRef = tById[edge[role]];\n      if (!visited[tRef]) {\n        visited[tRef] = true;\n        const node = this.makeNode(tRef, addProperties);\n        if (node) { // saveguard against obsolete edges or other problems\n          // record node\n          allNeighbours[node.id] = node;\n          neighboursOfThisStep.push(tRef);\n        }\n      }\n    };\n\n    // loop if still steps to be taken and we have a non-empty starting set\n    for (let step = 0; step < maxSteps && matches.length; step++) {\n\n      // neighbours that are discovered in the current step;\n      // starting off from the current set of matches;\n      const neighboursOfThisStep = [];\n\n      // loop over all nodes in the original set\n      for (let i = matches.length; i--;) {\n\n        if (utils.isSystemOrDraft(matches[i])) {\n          // = this might happen if the user manually created edges\n          // that link to a system/draft tiddler or if the original\n          // set contained system/draft tiddlers.\n          continue;\n        }\n\n        // get all outgoing edges\n        // = edges originating from the starting set and point outwards\n        const outgoing = this.getEdges(matches[i], toWL, typeWL);\n        for (let id in outgoing) {\n\n          const t = allETy[outgoing[id].type];\n          if (isWalkBoth || isWalkOut && t.toArrow || isWalkIn && t.invertedArrow) {\n\n            addAsNeighbour(outgoing[id], 'to', neighboursOfThisStep);\n          }\n        }\n\n        // get all incoming edges\n        // = edges originating from outside pointing to the starting set\n        const incoming = adjList[idByT[matches[i]]];\n        if (!incoming) {\n          continue;\n        }\n\n        for (let j = incoming.length; j--;) {\n          const t = allETy[incoming[j].type];\n          if (isWalkBoth || isWalkIn && t.toArrow || isWalkOut && t.invertedArrow) {\n            addAsNeighbour(incoming[j], 'from', neighboursOfThisStep);\n          }\n        }\n      }\n\n      // the current set of newly discovered neighbours forms the\n      // starting point for the next discovery\n      matches = neighboursOfThisStep;\n\n    }\n\n    const neighbourhood = {\n      nodes: allNeighbours,\n      edges: allEdgesLeadingToNeighbours\n    };\n\n    $tm.logger('debug', 'Retrieved neighbourhood', neighbourhood, 'steps', step);\n\n    $tm.stop('Get neighbours');\n\n    return neighbourhood;\n\n  }\n\n  /**\n   * This function will assemble a graph object based on the supplied\n   * node and edge filters. Optionally, a neighbourhood may be\n   * merged into the graph neighbourhood.\n   *\n   * @param {string|ViewAbstraction} [view] - The view in which\n   *     the graph will be displayed.\n   * @param {string|ViewAbstraction} [filter] - If supplied,\n   *     this will act as node filter that defines which nodes\n   *     are to be displayed in the graph; a possible view node filter\n   *     would be ignored.\n   * @param {Hashmap} [edgeTypeWL] - A whitelist lookup-table\n   *     that restricts which edges are travelled to reach a neighbour.\n   * @param {number} [neighbourhoodScope] - An integer value that\n   *     specifies the scope of the neighbourhood in steps.\n   *     See {@link Adapter#getNeighbours}\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all nodes in the graph* },\n   *       edges: { *all edges in the graph* },\n   *     }\n   *     Neighbours will be receive the 'tmap:neighbour' type.\n   */\n  getGraph({ view, filter, edgeTypeWL, neighbourhoodScope } = {}) {\n\n    $tm.start('Assembling Graph');\n\n    view = new ViewAbstraction(view);\n    const matches = utils.getMatches(filter || (view.exists() && view.getNodeFilter('compiled')));\n    const neighScope = parseInt(neighbourhoodScope || (view.exists() && view.getConfig('neighbourhood_scope')));\n    const typeWL = (edgeTypeWL || (view.exists() && view.getEdgeTypeFilter('whitelist')));\n    const toWL = utils.getArrayValuesAsHashmapKeys(matches);\n\n    const graph = {\n      edges: this.getEdgesForSet(matches, toWL, typeWL),\n      nodes: this.selectNodesByReferences(matches, {\n        view: view,\n        outputType: 'hashmap'\n      })\n    };\n\n    if (neighScope) {\n      const neighbours = this.getNeighbours(matches, {\n        steps: neighScope,\n        view: view,\n        typeWL: typeWL,\n        addProperties: {\n          group: 'tmap:neighbour'\n        }\n      });\n\n      // add neighbours (nodes and edges) to graph\n      Object.assign(graph.ndoes, neighbours.nodes);\n      Object.assign(graph.edges, neighbours.edges);\n\n      if (view.exists() && view.isEnabled('show_inter_neighbour_edges')) {\n        const nodeTRefs = this.getTiddlersById(neighbours.nodes);\n        // this time we need a whitelist based on the nodeTRefs\n        const toWL = utils.getArrayValuesAsHashmapKeys(nodeTRefs);\n        Object.assign(graph.edges, this.getEdgesForSet(nodeTRefs, toWL));\n      }\n    }\n\n    // this is pure maintainance!\n    removeObsoleteViewData(graph.nodes, view);\n\n    // add styles to nodes\n    this.attachStylesToNodes(graph.nodes, view);\n\n    $tm.stop('Assembling Graph');\n\n    $tm.logger('debug', 'Assembled graph:', graph);\n\n    return graph;\n\n  }\n\n  /**\n   * Returns all edges stored in a given tiddler. Any edge stored in a\n   * tiddler is orginally an outgoing edge. Depending on how the user\n   * changes the arrow head (by manipulating the Visjs edge-type style),\n   * the edge may change its orientation and become an incoming edge or\n   * bi-directional. Therefore, the edges retrieved may be incoming,\n   * outgoing or both!\n   *\n   * Returned edges may be of the following type:\n   *\n   * - Edges stored in the tiddler text (=links).\n   * - Edges stored in fields denoted by magic edge-types.\n   * - TiddlyMap edges stored in a json format\n   *\n   * @param {Tiddler} tiddler - A tiddler reference or object from\n   *     which to retrieve the edges.\n   * @param {Hashmap<TiddlerReference, boolean>} [toWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge that leads to a certain tiddler in the result or not.\n   *     In this case, all edges stored in the tiddler are treated as\n   *     outgoing and the arrow head is ignored. If not specified,\n   *     all edges are included.\n   * @param {Hashmap<string, boolean>} [typeWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge of a given type in the result or not. If not\n   *     specified, all edges are included.\n   */\n  getEdges(tiddler, toWL, typeWL) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) {\n      return;\n    }\n\n    const { allETy } = this.indeces;\n    const edges = utils.makeHashMap();\n    const eTySubscribers = this.services.edgeTypeSubscriberRegistry.getAll();\n\n    for (let i = 0, l = eTySubscribers.length; i < l; i++) {\n      Object.assign(edges, (eTySubscribers[i]).loadEdges(tObj, toWL, typeWL));\n    }\n\n    for (let id in edges) {\n\n      const edge = edges[id];\n\n      // check exists for historical reasons...\n      if (!edge.from || !edge.to) {\n        continue;\n      }\n\n      const type = allETy[edge.type] || new EdgeType(edge.type);\n      addStyleToEdge(edges[id], type);\n\n      edges[id] = edge;\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * The method will return all outgoing edges for a subset of tiddlers.\n   *\n   * @param {Array<Tiddler>} tiddlers - The set of tiddlers to consider.\n   * @param toWL\n   * @param typeWL\n   * @return {Hashmap<Id, Edge>} An edge collection.\n   */\n  getEdgesForSet(tiddlers, toWL, typeWL) {\n\n    const edges = utils.makeHashMap();\n    for (let i = tiddlers.length; i--;) {\n      Object.assign(edges, this.getEdges(tiddlers[i], toWL, typeWL));\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * Select all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   */\n  selectEdgesByType(type) {\n\n    const typeWL = utils.makeHashMap();\n    typeWL[new EdgeType(type).id] = true;\n    return this.getEdgesForSet(this.getAllPotentialNodes(), null, typeWL);\n\n  }\n\n  /**\n   * Deletes or renames all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   * @param {('rename'|'delete')} [action='delete']\n   * @param {string} [newName]\n   */\n  _processEdgesWithType(type, { action, newName }) {\n\n    type = new EdgeType(type);\n\n    $tm.logger('debug', 'Processing edges', type, action);\n\n    // get edges\n    const edges = this.selectEdgesByType(type);\n\n    if (action === 'rename') {\n\n      // clone type first to prevent auto-creation\n      const newType = new EdgeType(newName);\n      newType.load(type);\n      newType.save();\n\n    }\n\n    for (let id in edges) {\n\n      this._processEdge(edges[id], 'delete');\n\n      if (action === 'rename') {\n        edges[id].type = newName;\n        this._processEdge(edges[id], 'insert');\n      }\n    }\n\n    // finally remove the old type\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Returns a set of nodes that corresponds to a set of tiddlers.\n   *\n   * @param {TiddlerCollection} tiddlers - A collection of tiddlers.\n   * @param {Hashmap} [addProperties] - a hashmap\n   * @param {CollectionTypeString} [outputType='dataset'] - The result type.\n   *\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByReferences(tiddlers, { addProperties, outputType } = {}) {\n\n    const result = utils.makeHashMap();\n    const keys = Object.keys(tiddlers);\n\n    for (let i = keys.length; i--;) {\n\n      const node = this.makeNode(tiddlers[keys[i]], addProperties);\n      if (node) {\n        result[node.id] = node;\n      }\n\n    }\n\n    return utils.convert(result, outputType);\n\n  }\n\n  /**\n   * Retrieve nodes based on the a list of ids that corrspond to tiddlers\n   * id fields.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids of the tiddlers\n   *     that represent the nodes.\n   * @param {Hashmap} [options] - See {@link Adapter#selectNodesByReferences}.\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByIds(nodeIds, options) {\n\n    const tRefs = this.getTiddlersById(nodeIds);\n\n    return this.selectNodesByReferences(tRefs, options);\n\n  }\n\n  /**\n   * Select a single node by id.\n   *\n   * @param {Id} id - A node's id\n   * @param {Hashmap} [options]\n   *     Except from the outputType option, all options\n   *     are inherited from {@link Adapter#selectNodesByIds}.\n   * @return {Node|undefined} A node or nothing.\n   */\n  selectNodeById(id, options) {\n\n    options = Object.assign({}, options, { outputType: 'hashmap' });\n    const result = this.selectNodesByIds([ id ], options);\n\n    return result[id];\n\n  }\n\n  /**\n   * Deletes a node type from the system.\n   * @param {NodeType|string} type - the node type id or the actual NodeType\n   */\n  removeNodeType(type) {\n\n    type = new NodeType(type);\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Gets a Node representation for a tiddler.\n   *\n   * @param {Tiddler} tiddler - the tiddler to represent as node\n   * @param {Object} protoNode - default node properties\n   *\n   * @return {Node|void}\n   */\n  makeNode(tiddler, protoNode) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) return;\n\n    // merge(!) so later node manipulations do not affect other nodes\n    const node = utils.merge({}, protoNode);\n\n    // assignId() will not assign an id if the tiddler already has one\n    node.id = this.assignId(tObj);\n\n    // add label\n    const label = tObj.fields[$tm.field.nodeLabel];\n    node.label = (label && $tm.field.nodeLabel !== 'title'\n      ? this.wiki.renderText('text/plain', 'text/vnd-tiddlywiki', label)\n      : tObj.fields.title);\n\n    return node;\n\n  }\n\n  /**\n   * Return node styles that are inherited from system styles or node types.\n   *\n   * @param nodes\n   * @return {Object<TiddlerReference, Object>}\n   */\n  getInheritedNodeStyles(nodes) {\n\n    const src = this.getTiddlersById(nodes);\n    const protoByTRef = {};\n    const glNTy = this.indeces.glNTy;\n\n    for (let i = glNTy.length; i--;) {\n      const type = glNTy[i];\n\n      let inheritors = [];\n      if (type.id === 'tmap:neighbour') { // special case\n        const tById = this.indeces.tById;\n        for (let id in nodes) {\n\n          if (nodes[id].group === 'tmap:neighbour') {\n\n            inheritors.push(tById[id]);\n          }\n        }\n      } else {\n        inheritors = type.getInheritors(src);\n      }\n\n      for (let j = inheritors.length; j--;) {\n        const tRef = inheritors[j];\n        const proto = protoByTRef[tRef] = (protoByTRef[tRef] || {});\n        proto.style = utils.merge(\n          proto.style || {},\n          type.style\n        );\n\n        // ATTENTION: only override proto icons when the type provides\n        // an icon since otherwise we might erase previously\n        // inherited icons.\n        if (type['fa-icon']) {\n          proto['fa-icon'] = type['fa-icon'];\n        } else if (type['tw-icon']) {\n          proto['tw-icon'] = type['tw-icon'];\n        }\n\n      }\n    }\n\n    return protoByTRef;\n\n  }\n\n  /**\n   * Adds styles to nodes.\n   *\n   * @param {Object<string, Node>} nodes\n   * @param {ViewAbstraction|string} view\n   */\n  attachStylesToNodes(nodes, view) {\n\n    view = new ViewAbstraction(view);\n\n    const inheritedStyles = this.getInheritedNodeStyles(nodes);\n\n    const viewNodeData = view.exists() ? view.getNodeData() : utils.makeHashMap();\n    const isStaticMode = view.exists() && !view.isEnabled('physics_mode');\n\n    // shortcuts (for performance and readability)\n    const tById = this.indeces.tById;\n\n    for (let id in nodes) {\n\n      const tRef = tById[id];\n      const tObj = this.wiki.getTiddler(tRef);\n      const fields = tObj.fields;\n\n      const node = nodes[id];\n      let faIcon = null;\n      let twIcon = null;\n\n      // == group styles ==\n\n      // will add local and global group styles\n      if (inheritedStyles[tRef]) {\n\n        if (inheritedStyles[tRef].style) {\n          utils.merge(node, inheritedStyles[tRef].style);\n        }\n        faIcon = inheritedStyles[tRef]['fa-icon'];\n        twIcon = inheritedStyles[tRef]['tw-icon'];\n      }\n\n      // == global node styles ==\n\n      // background color\n      if (fields.color) {\n        node.color = fields.color;\n      }\n\n      // global node style from vis editor\n      if (fields['tmap.style']) {\n        utils.merge(node, utils.parseJSON(fields['tmap.style']));\n      }\n\n      faIcon = fields['tmap.fa-icon'] || faIcon;\n      twIcon = fields['icon'] || twIcon;\n\n      // == local node styles ==\n\n      // local node style and positions\n\n      if (viewNodeData[id]) {\n\n        utils.merge(node, viewNodeData[id]);\n        if (isStaticMode) {\n          // fix x if x-position is set; same for y\n          node.fixed = {\n            x: (node.x != null),\n            y: (node.y != null)\n          };\n        }\n\n        faIcon = viewNodeData[id]['fa-icon'] || faIcon;\n\n        twIcon = viewNodeData[id]['tw-icon'] || twIcon;\n      }\n\n      // == tweaks ==\n\n      const isColorObject = (node.color !== null\n      && typeof node.color === 'object');\n      // color/border-color may be undefined\n      const color = (isColorObject ? node.color.background : node.color);\n\n      node.color = {\n        background: color,\n        border: (isColorObject ? node.color.border : undefined)\n      };\n\n      // ATTENTION: this function needs to be called after color is assigned\n      addNodeIcon(node, faIcon, twIcon);\n\n      // determine font color if not defined via a group- or node-style;\n      // in case of global and local default styles, the user is responsible\n      // him- or herself to adjust the font\n      node.font = node.font || {};\n\n      if (node.shape && !this.visShapesWithTextInside[node.shape]) {\n        node.font.color = 'black'; // force a black color\n      } else if (!node.font.color && color) {\n        node.font.color = getContrastColour(color, color, 'black', 'white');\n      }\n\n      if (node.shape === 'icon' && typeof node.icon === 'object') {\n        node.icon.color = color;\n      }\n\n    }\n\n    if (view.exists()) {\n      const node = nodes[view.getConfig('central-topic')];\n      if (node) {\n        utils.merge(node, this.indeces.glNTyById['tmap:central-topic'].style);\n      }\n    }\n\n  }\n\n  /**\n   * This function will remove all tiddlers from the wiki that correspond\n   * to a node in the collection. Drafts are also removed. The default\n   * storylist is updated eventually.\n   * call deleteNode which does the following\n   * 1. get id using IdByT\n   * 2. remove id using adapter.deleteEdgesByTo(idByT[tRef])\n   * 3. remove from all indeces\n   *\n   * @see: https://github.com/Jermolene/TiddlyWiki5/issues/1550\n   *\n   * @param {Node|string} node.\n   */\n  deleteNode(node) {\n\n    if (!node) return;\n\n    const id = (typeof node === 'object' ? node.id : node);\n    const tRef = this.indeces.tById[id];\n\n    // delete tiddler and remove it from the river; this will\n    // automatically remove the global node style and the outgoing edges\n\n    if (tRef) {\n      // checking for tRef is needed;\n      // see: https://github.com/Jermolene/TiddlyWiki5/issues/1919\n      utils.deleteTiddlers([ tRef ]);\n    }\n\n    // delete local node-data in views containing the node\n\n    const viewRefs = utils.getMatches($tm.selector.allViews);\n    for (let i = viewRefs.length; i--;) {\n      const view = new ViewAbstraction(viewRefs[i]);\n      view.removeNode(id);\n      if (view.getNodeData(id)) {\n        view.saveNodeData(id, null);\n      }\n    }\n\n    // remove obsolete connected edges\n\n    const neighbours = this.getNeighbours([ tRef ]);\n    this.deleteEdges(neighbours.edges);\n\n    // -------------------------------------------\n    // NEVER DELETE AN INDEX THAT ALREADY EXISTED!\n    // -------------------------------------------\n    // Some instances may have cached the index and get confused!\n    // It does not do harm to leave indeces as is since we do not\n    // iterate over them(!) and when a tiddler has the same title or\n    // id as a deleted tiddler, which is highly unlikely, then it will\n    // simply override the index, which is totally fine. The indeces\n    // are refreshed on every boot anyway so it is not a big deal.\n    //\n    // THEREFORE:\n    //\n    // DO NOT DO delete this.indeces.tById[id];\n    // DO NOT DO delete this.indeces.idByT[tRef];\n\n  }\n\n  /**\n   * Delete all nodes from the system.\n   *\n   * @param {string[]} ids ids\n   */\n  deleteNodes(ids) {\n\n    for (let i = ids.length; i--;) {\n      this.deleteNode(ids[i]);\n    }\n\n  }\n\n  /**\n   * Public API function; will store the positions into the sprecified view.\n   *\n   * @param {object} positions A hashmap ids as keys and x, y properties as values\n   * @param {ViewAbstraction|Tiddler|string} view\n   */\n  storePositions(positions, view) {\n\n    view = new ViewAbstraction(view);\n    if (!view.exists()) return;\n\n    view.saveNodeData(positions);\n\n  }\n\n  /**\n   * This method will assign an id to an *existing* tiddler that does\n   * not already possess and id. Any assigned id will be registered\n   * at the id->tiddler index.\n   *\n   * @todo It is a bottleneck that the tiddler is always reloaded from the db.\n   *\n   * @param {Tiddler} tiddler - The tiddler to assign the id to.\n   * @param {boolean} isForce - True if the id should be overridden,\n   *     false otherwise. Only works if the id field is not set to title.\n   *\n   * @return {Id} The assigned or retrieved id.\n   */\n  assignId(tiddler, isForce) {\n\n    // ALWAYS reload from store to avoid setting wrong ids on tiddler\n    // being in the role of from and to at the same time.\n    // Therefore, do not use utils.getTiddler(tiddler)!\n    const tObj = utils.getTiddler(tiddler, true);\n\n    if (!tObj) return;\n\n    let id = tObj.fields['tmap.id'];\n\n    if (!id || isForce) {\n      id = utils.genUUID();\n      utils.setField(tObj, 'tmap.id', id);\n      $tm.logger('info', 'Assigning new id to', tObj.fields.title);\n    }\n\n    // blindly update the index IN ANY CASE because tiddler may have\n    // an id but it is not indexed yet (e.g. because of renaming operation)\n    this.indeces.tById[id] = tObj.fields.title;\n    this.indeces.idByT[tObj.fields.title] = id;\n\n    return id;\n\n  }\n\n  /**\n   * Create a new tiddler that gets a non-existant title and is opened\n   * for edit. If a view is registered, the fields of the tiddler match\n   * the current view. If arguments network and position are specified,\n   * the node is also inserted directly into the graph at the given\n   * position.\n   *\n   * @TODO: Description is obsolete!\n   *\n   * @param {object} node A node object to be inserted\n   * @param {ViewAbstraction|string} view - used to set positions and register the node to\n   * @param {Tiddler} protoTiddler\n   */\n  insertNode(node = {}, view, protoTiddler) {\n\n    // title might has changed after generateNewTitle()\n    node.label = this.wiki.generateNewTitle(node.label || utils.getRandomLabel());\n\n    // add to tiddler store\n    const tObj = new $tw.Tiddler(\n      { text: '' }, // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n      protoTiddler,\n      {\n        title: node.label, // force title\n        'tmap.id': null // force empty id (generated later)\n      },\n      this.wiki.getModificationFields(),\n      this.wiki.getCreationFields()\n    );\n\n    this.wiki.addTiddler(tObj);\n\n    node = this.makeNode(tObj, node);\n\n    view = new ViewAbstraction(view);\n    if (view.exists()) {\n      view.addNode(node);\n    }\n\n    return node;\n\n  }\n\n  /**\n   * Retrieve tiddlers based on the a list of corresponding ids.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids.\n   * @return {Array<TiddlerReference>} The resulting tiddlers.\n   */\n  getTiddlersById(nodeIds) {\n\n    // transform into a hashmap with all values being true\n    if (Array.isArray(nodeIds)) {\n      nodeIds = utils.getArrayValuesAsHashmapKeys(nodeIds);\n    } else if (nodeIds instanceof vis.DataSet) {\n      nodeIds = utils.getLookupTable(nodeIds, 'id'); // use id field as key\n    }\n\n    const result = [];\n    const tById = this.indeces.tById;\n    for (let id in nodeIds) {\n\n      if (tById[id]) {\n        result.push(tById[id]);\n      }\n    }\n\n    return result;\n\n  }\n\n  getId(tiddler) {\n\n    return this.indeces.idByT[utils.getTiddlerRef(tiddler)];\n    // works too: return utils.getField(tiddler, 'tmap.id');\n\n  }\n}\n\n/**** Helper *******************************************************/\n\n/**\n * Returns the short symbol identifier (`&#xf2bc;` → `f206`).\n *\n * @param str FontAwesome id\n * @return {string}\n * @private\n */\nconst getFAdigits = (str) => (str.length === 4 ? str : str.substr(3, 4));\n\n/**\n * Adds an icon to the specified node.\n *\n * @param {Node} node\n * @param {string} faIcon\n * @param {string} twIcon\n * @private\n */\nconst addNodeIcon = (node, faIcon, twIcon) => {\n\n  // Font Awesome style\n\n  if (faIcon) {\n    node.shape = 'icon';\n    node.icon = {\n      shape: 'icon',\n      face: 'FontAwesome',\n      color: node.color,\n      code: String.fromCharCode('0x' + getFAdigits(faIcon))\n    };\n\n    return;\n  }\n\n  // TiddlyWiki stored icons\n\n  if (twIcon) {\n\n    const imgTObj = utils.getTiddler(twIcon);\n    if (!imgTObj) return;\n\n    if (imgTObj.fields['_canonical_uri']) { // image is a url address\n      node.image = imgTObj.fields['_canonical_uri'];\n      node.shape = 'image';\n\n    } else if (imgTObj.fields.text) {\n      node.image = utils.getDataUri(imgTObj);\n      node.shape = 'image';\n    }\n\n  }\n\n};\n\n/**\n * Garbage collector for obsolete node data.\n *\n * @param {Object<string, Node>} nodes\n * @param {ViewAbstraction|string} view\n * @private\n */\nconst removeObsoleteViewData = (nodes, view) => {\n\n  view = new ViewAbstraction(view);\n  if (!view.exists() || !nodes) return;\n\n  const data = view.getNodeData();\n\n  let obsoleteDataItems = 0;\n  for (let id in data) {\n    if (nodes[id] === undefined && data[id] != null) {\n      // we only set this to undefined as deletion would\n      // slow down V8, however, this necessarily requires\n      // a safeguard agains recursion: data[id] != null\n\n      data[id] = undefined;\n      obsoleteDataItems++;\n    }\n  }\n\n  if (obsoleteDataItems) {\n    $tm.logger('debug', '[Cleanup]',\n      'Removed obsolete node data:',\n      view.getLabel(), obsoleteDataItems);\n    view.saveNodeData(data);\n  }\n\n};\n\n/**\n * Sets up an edge object that is ready to be consumed by vis.\n *\n * @param {Edge} edge\n * @param {EdgeType} type\n */\nconst addStyleToEdge = (edge, type) => {\n\n  edge = Object.assign(edge, type.style);\n\n  if (utils.isTrue(type['show-label'], true)) {\n    edge.label = type.getLabel();\n  }\n};\n\n/*** Exports *******************************************************/\n\nexport default Adapter;\n"],"sourceRoot":"../../../../../src/plugins"}