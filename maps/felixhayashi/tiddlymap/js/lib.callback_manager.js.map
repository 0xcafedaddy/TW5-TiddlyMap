{"version":3,"sources":["felixhayashi/tiddlymap/js/lib.callback_manager.js"],"names":["_utils","require","CallbackManager","_classCallCheck","this","callbacks","_utils2","default","makeHashMap","logger","$tm","wiki","$tw","tRef","callback","isDeleteOnCall","execute","refOrRefList","i","length","changedTiddlers","getTiddler","remove"],"mappings":";;;;;;;;;;AAWA,GAAAA,QAAAC,QAAA,kRAKMC,4BAEJ,QAAAA,KAAcC,gBAAAC,KAAAF,EACZE,MAAKC,UAAYC,QAAAC,QAAMC,aACvBJ,MAAKK,OAASC,IAAID,MAClBL,MAAKO,KAAOC,IAAID,iDAedE,EAAMC,EAAUC,GAElBX,KAAKK,OAAO,QAAZ,6CAAkEI,EAAlE,IACAT,MAAKC,UAAUQ,IACbG,QAASF,EACTC,qBAAwBA,KAAmB,UAAYA,EAAiB,uCAQrEE,GAEL,IAAKA,EAAc,CACjB,OAdF,SAAKR,KAAL,SAAA,CACAQ,GAAeJ,GAAQ,IAAvB,GAAAK,GAAAD,EAAAE,OAAAD,KAAA,CAKD,GAAAL,GAAAI,EAAAC,EAiBG,IAAId,KAAKC,UAAUQ,GAAO,CACxBT,KAAKK,OAAO,QAAZ,mBAAwCI,EAAxC,2BACOT,MAAKC,UAAUQ,6CANzBO,GAED,GAAAhB,KAAKC,UAAQY,QAAaE,EAAAA,MAExB,KAAA,GAAIN,KAAKR,GAAiB,CAExB,IAAAD,KAAAC,UAAYA,GAAUQ,CACvB,SAsBD,GAAIT,KAAKO,KAAKU,WAAWR,GAAO,CAE9BT,KAAKK,OAAO,QAAZ,6BAAkDI,EAClDT,MAAKC,UAAUQ,GAAMG,QAAQH,EAG7B,KAAKT,KAAKC,UAAUU,eAAgB,CAClC,UAIJX,KAAKkB,OAAOT,oCAbXX","file":"../../../../felixhayashi/tiddlymap/js/lib.callback_manager.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/CallbackManager\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/**\n * @constructor\n */\nclass CallbackManager {\n\n  constructor() {\n    this.callbacks = utils.makeHashMap();\n    this.logger = $tm.logger;\n    this.wiki = $tw.wiki;\n  }\n\n  /**\n   * The callback mechanism allows to dynamically listen to tiddler\n   * changes without hardcoding a change-check for a tiddler name\n   * in the refresh function.\n   *\n   * @param {TiddlerReference} tRef - A tiddler whose change triggers\n   *     the callback.\n   * @param {function} callback - A function that is called when the\n   *     tiddler has changed.\n   * @param {boolean} [isDeleteOnCall=true] - True if to delete the\n   *     callback once it has been called, false otherwise.\n   */\n  add(tRef, callback, isDeleteOnCall) {\n\n    this.logger('debug', `A callback was registered for changes of \"${tRef}\"`);\n    this.callbacks[tRef] = {\n      execute: callback,\n      isDeleteOnCall: (typeof isDeleteOnCall === 'boolean' ? isDeleteOnCall : true)\n    };\n\n  };\n\n  /**\n   * Removes the callback from the list of tiddler callbacks.\n   */\n  remove(refOrRefList) {\n\n    if (!refOrRefList) {\n      return;\n    }\n\n    if (typeof refOrRefList === 'string') {\n      refOrRefList = [ refOrRefList ];\n    }\n\n    for (let i = refOrRefList.length; i--;) {\n      const tRef = refOrRefList[i];\n      if (this.callbacks[tRef]) {\n        this.logger('debug', `A callback for \"${tRef}\" will be deleted`);\n        delete this.callbacks[tRef];\n      }\n    }\n\n  };\n\n  /**\n   * this method has to be implemented at the top of the refresh method.\n   * It checks for changed tiddlers that have\n   * registered callbacks. If `deleteOnCall` was specified during\n   * registration of the callback, the callback will be deleted\n   * automatically.\n   */\n  handleChanges(changedTiddlers) {\n\n    if (this.callbacks.length == 0) return;\n\n    for (let tRef in changedTiddlers) {\n\n      if (!this.callbacks[tRef]) {\n        continue;\n      }\n\n      if (this.wiki.getTiddler(tRef)) {\n\n        this.logger('debug', `Executing a callback for: ${tRef}`);\n        this.callbacks[tRef].execute(tRef);\n\n        // a continue prevents deleting the callback\n        if (!this.callbacks.isDeleteOnCall) {\n          continue;\n        }\n      }\n\n      this.remove(tRef);\n    }\n\n  };\n}\n\n/*** Exports *******************************************************/\n\nexport default CallbackManager;\n"],"sourceRoot":"../../../../../src/plugins"}