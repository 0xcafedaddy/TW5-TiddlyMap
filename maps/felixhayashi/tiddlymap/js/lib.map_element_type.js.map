{"version":3,"sources":["felixhayashi/tiddlymap/js/lib.map_element_type.js"],"names":["_utils","require","MapElementType","id","root","fieldMeta","data","this","_fieldMeta","fullPath","isShipped","$tw","wiki","getSubTiddler","$tm","path","pluginRoot","load","description","style","parse","_utils2","default","parseJSON","stringify","JSON","modified","created","prototype","isFullPath","startsWith","tRef","loadFromTiddler","Tiddler","field","tiddler","tObj","getTiddler","shadowTObj","utils","extend","fields","parser","rawData","call","rawVal","exists","tiddlerExists","setStyle","isMerge","merge","save","silently","title","text","Date","addTiddler"],"mappings":";;;;;;;;;;AAaA,GAAAA,QAAAC,QAAA,iKAQA,QAASC,gBAAeC,EAAIC,EAAMC,EAAWC,GAE3CC,KAAKJ,GAAKA,CACVI,MAAKH,KAAOA,CATdG,MAAAC,WAAAH,CAWEE,MAAKE,SAAWF,KAAKH,KAAO,IAAMG,KAAKJ,EATzCI,MAAAG,UAAAC,IAAAC,KAAAC,cAAAC,IAAAC,KAAAC,WAAAT,KAAAE,SAYEF,MAAKU,KAAKX,GAAQC,KAAKE,UAYzBP,eAAeM,YARfU,eAUEC,OACEC,MAAOC,QAAAC,QAAMC,UACbC,UAAWC,KAAKD,WAElBE,YACAC,WALSzB,gBAFiB0B,UAAAX,KAAA,SAAAX,GAO1B,IAAAA,EAAW,MAWX,UAAWA,KAAS,SAAU,CAE5B,GAAIuB,GAAaR,QAAAC,QAAMQ,WAAWxB,EAAMC,KAAKH,KAC7C,IAAI2B,GAAQF,EAAavB,EAAOC,KAAKH,KAAO,IAAME,CAClDC,MAAKyB,gBAAgBD,OAEhB,IAAIzB,YAAgBK,KAAIsB,QAAS,CARxC1B,KAAKD,gBAAMA,OAEP,WAAAA,KAAOA,YAAAA,YAAAA,QAAPA,MAAgB,SAAU,CAAE,IAAA,GAAA4B,KAAA3B,MAAAC,WAAA,CAE9BD,KAAIsB,GAAAA,EAAaK,KAcpBhC,gBApBD0B,UAAAI,gBAAA,SAAAG,GAuBA,GAAAC,GAAAf,QAAAC,QAAAe,WAAAF,EAQE,KAAKC,EAAM,MAEX,IAAIE,GAAa3B,IAAIC,KAAKC,cAAcC,IAAIC,KAAKC,WACTT,KAAKE,aAJ7C,IAAI2B,GAAOzB,IAAA4B,MAAAC,UAAMH,EAAjBI,OAAAL,EAAAK,OASA,KAAK,GAAIP,KAAS3B,MAAKC,WAAY,CAEjC,GAAIkC,GAASnC,KAAKC,WAAW0B,GAAOd,KAJtC,IAAIuB,GAAUhC,EAAAuB,EAEd3B,MAAK2B,GAALQ,EAAuBlC,EAAvBoC,KAAmCrC,KAAAsC,GAAAA,GAkBrC3C,gBAAe0B,UAAUkB,OAAS,WAEhC,MAAOzB,SAAAC,QAAMyB,cAAcxC,KAAKE,UAIlCP,gBAAe0B,UAAUoB,SAAW,SAAS7B,EAAO8B,GAGlD,SAAW9B,KAAU,SAAU,CAHjCjB,EAAAA,QAAAA,QAAe0B,UAAUoB,GAIrB7B,UAAQA,KAARA,YAAAA,YAAAA,QAAQA,MAAA,SAAMI,CACf,GAAA0B,EAAA,CAKG5B,QAAAC,QAAM4B,MAAM3C,KAAKY,MAAOA,OAH5B,CACIZ,KAAAY,MAAAA,IAsBNjB,gBAAe0B,UAAUuB,KAAO,SAASpB,EAAMqB,GAE7C,IAAKrB,EAAM,CAFb7B,EAAAA,KAAe0B,aAIN,UAAWG,KAAS,SAAU,CAFrC,OAQA,GAAIU,IAFJY,MAAAtB,EACAuB,KAAA,GAGEA,KAAAA,QAAAA,QAAMxB,WAAAC,EAAAxB,KAAAH,MAAA,CAONqC,EAAOtC,GAAKI,KAAKJ,GAElB,GAAAiD,IAAA,KAAA,CAED7C,KAAI6C,SAAa,GAAjBG,MAGC,IAAAhD,KAAAuC,SAAA,CAEDvC,KAAKoB,QAAApB,KAAemB,SAGnB,IAAA,GAAAQ,KAAA3B,MAAAC,WAAA,CAED,GAAAgB,GAAAjB,KAAAC,WAAA0B,GAAAV,SAKEiB,GAAOP,GAAUV,EAFDA,EAAKhB,KAAW0B,KAAOV,KAAAA,IAIpBjB,KAAK2B,GAG1BvB,IAAIC,KAAK4C,WAAW,GAAI7C,KAAIsB,QAAQQ,qBAQvBvC","file":"../../../../felixhayashi/tiddlymap/js/lib.map_element_type.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/MapElementType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/*** Code **********************************************************/\n\n/**\n * @constructor\n * @abstract\n */\nfunction MapElementType(id, root, fieldMeta, data) {\n\n  this.id = id;\n  this.root = root;\n  this._fieldMeta = fieldMeta;\n  this.fullPath = this.root + '/' + this.id;\n  this.isShipped = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath);\n  // finally get the data\n  this.load(data || this.fullPath);\n\n}\n\n/**\n * A list of fields that are used as data identifiers. Only these\n * listed keys are acknowledged by the load and save functions in\n * this class.\n *\n * This object resembles tw's field modules that are used by\n * `boot.js` to decide how fields are parsed and stringified again.\n */\nMapElementType._fieldMeta = {\n  'description': {},\n  'style': {\n    parse: utils.parseJSON,\n    stringify: JSON.stringify\n  },\n  'modified': {}, // translation handled by TW's core\n  'created': {} // translation handled by TW's core\n};\n\n/**\n * Load the type's data. Depending on the constructor arguments,\n * the data source can be a tiddler, a type store\n */\nMapElementType.prototype.load = function(data) {\n\n  if (!data) return;\n\n  if (typeof data === 'string') { // assume id or full path\n\n    var isFullPath = utils.startsWith(data, this.root);\n    var tRef = (isFullPath ? data : this.root + '/' + data);\n    this.loadFromTiddler(tRef);\n\n  } else if (data instanceof $tw.Tiddler) {\n    this.loadFromTiddler(data);\n\n  } else if (typeof data === 'object') { // = type or a data object\n    for (var field in this._fieldMeta) {\n\n      this[field] = data[field];\n    }\n  }\n\n};\n\n\n/**\n * Retrieve all data from the tiddler provided. If a shadow tiddler\n * with the same id exists, its data is merged during the load\n * process.\n */\nMapElementType.prototype.loadFromTiddler = function(tiddler) {\n\n  var tObj = utils.getTiddler(tiddler);\n  if (!tObj) return;\n\n  var shadowTObj = $tw.wiki.getSubTiddler($tm.path.pluginRoot,\n                                          this.fullPath) || {};\n\n  // copy object to allow manipulation of the data\n  var rawData = $tw.utils.extend({}, shadowTObj.fields, tObj.fields);\n  // allow parsers to transform the raw field data\n  for (var field in this._fieldMeta) {\n\n    var parser = this._fieldMeta[field].parse;\n\n    var rawVal = rawData[field];\n\n    this[field] = (parser ? parser.call(this, rawVal) : rawVal);\n  }\n\n};\n\n/**\n * Method to determine whether or not this type exists. A type\n * exists if a tiddler with the type's id can be found below\n * the type's root path.\n *\n * @return {boolean} True if the type exists, false otherwise.\n */\nMapElementType.prototype.exists = function() {\n\n  return utils.tiddlerExists(this.fullPath);\n\n};\n\nMapElementType.prototype.setStyle = function(style, isMerge) {\n\n  // preprocessing: try to turn string into json\n  if (typeof style === 'string') {\n    style = utils.parseJSON(style);\n  }\n\n  // merge or override\n  if (typeof style === 'object') {\n    if (isMerge) {\n      utils.merge(this.style, style);\n    } else {\n      this.style = style;\n    }\n  }\n\n};\n\n/**\n * Store the type object as tiddler in the wiki. If the `tRef`\n * property is not provided, the default type path prefix\n * will be used with the type id appended. Stringifiers provided in\n * the field meta object (that was passed to the constructor) are\n * called.\n *\n * @param {string} [tRef] - If `tRef` is provided, the type\n *     data will be written into this tiddler and the id property\n *     is added as extra field value. Only do this is only for\n *     dumping purposes!\n */\nMapElementType.prototype.save = function(tRef, silently) {\n\n  if (!tRef) {\n    tRef = this.fullPath;\n  } else if (typeof tRef !== 'string') {\n    return;\n  }\n\n  // also add an empty text field to guard against\n  // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n  var fields = {\n    title: tRef,\n    text: ''\n  };\n\n  if (!utils.startsWith(tRef, this.root)) {\n\n    // = not the standard path for storing this type!\n    // in this case we add the id to the output.\n    fields.id = this.id;\n\n  }\n\n  if (silently !== true) {\n    // add modification date to the output;\n    this.modified = new Date();\n  }\n\n  if (!this.exists()) { // newly created\n    // add a creation field as well\n    this.created = this.modified;\n  }\n\n  // allow parsers to transform the raw field data\n  for (var field in this._fieldMeta) {\n\n    var stringify = this._fieldMeta[field].stringify;\n\n    fields[field] = (stringify\n                     ? stringify.call(this, this[field])\n                     : this[field]);\n  }\n\n  $tw.wiki.addTiddler(new $tw.Tiddler(fields));\n\n\n};\n\n\n/*** Exports *******************************************************/\n\nexport default MapElementType;\n"],"sourceRoot":"../../../../../src/plugins"}