{"version":3,"sources":["felixhayashi/tiddlymap/js/widget/MapWidget.js"],"names":["_DialogManager","require","_CallbackManager","_ViewAbstraction","_EdgeType","_Popup","_vis","_widget","_utils","_SelectionRectangle","MapWidget","parseTreeNode","options","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","getAttr","getAttribute","isDebug","_utils2","default","isTrue","$tm","config","sys","debug","bindTo","callbackManager","_CallbackManager2","dialogManager","_DialogManager2","computeAttributes","editorMode","clickToUse","id","getStateQualifier","widgetPopupsPath","path","tempPopups","addTWlisteners","tmap:tm-create-view","handleCreateView","tmap:tm-rename-view","handleRenameView","handleDeleteView","tmap:tm-delete-element","handleDeleteElement","tmap:tm-edit-view","handleEditView","tmap:tm-store-position","tmap:tm-generate-widget","handleGenerateWidget","tmap:tm-toggle-central-topic","handleSetCentralTopic","tmap:tm-save-canvas","handleSaveCanvas","tmap:tm-focus-node","handleFocusNode","tmap:tm-reset-focus","repaintGraph","visListeners","click","handleVisSingleClickEvent","doubleClick","handleVisDoubleClickEvent","stabilized","selectNode","handleVisSelectNode","deselectNode","handleVisDeselectNode","dragStart","handleVisDragStart","dragEnd","handleVisDragEnd","hoverNode","hoverEdge","handleVisHoverElement","blurNode","blurEdge","handleVisBlurElement","beforeDrawing","handleVisBeforeDrawing","afterDrawing","handleVisAfterDrawing","stabilizationProgress","handleVisLoading","stabilizationIterationsDone","windowDomListeners","resize","handleResizeEvent","handleClickEvent","handleStorePositions","mousemove","handleCanvasMouseMove","canvasDomListeners","keyup","handleCanvasKeyup","keydown","handleCanvasKeydown","mousewheel","handleCanvasScroll","contextmenu","widgetDomListeners","handleWidgetKeyup","handleWidgetKeydown","conVector","from","edge","callback","_this2","eTyFilter","param","fromLabel","adapter","handleContextMenu","label","toLabel","selectNodeById","to","viewNS","view","getConfig","open","isConfirmed","outTObj","namespace","type","_EdgeType2","getText","exists","save","insertEdge","isEdgeTypeVisible","getLabel","pretty","ref","sysMeta","setEntry","setText","touch","n1","insertNode","x","y","n2","message","args","Array","prototype","slice","arguments","unshift","logger","apply","parent","nextSibling","parentDomNode","domNode","registerClassNames","viewHolderRef","getViewHolderRef","getView","graphBarDomNode","document","createElement","$tw","utils","addClass","appendChild","graphDomNode","renderFullWidget","header","body","snapshotTRef","getRoot","snapshotTObj","insertBefore","className","makeChildWidget","getTranscludeNode","placeholder","renderChildren","setDomListeners","window","widget","addLoadingBar","tooltip","_Popup2","showDelay","popups","delay","contextMenu","hideOnClick","leavingDelay","sidebar","getFirstElementByClassName","isInSidebar","isTiddlyWikiFakeDom","contains","rebuildEditorBar","initAndRenderGraph","registry","push","reloadRefreshTriggers","checkForFreshInstall","misc","mainEditorId","url","query","toggleEnlargedMode","graphLoadingBarDomNode","unicodeBtnClass","variables","widgetQualifier","widgetTempPath","isViewBound","String","viewRoot","viewLabel","edgeTypeFilter","getPaths","allEdgesFilter","selector","allEdgeTypes","neighScopeBtnClass","isEnabled","activeUnicodeBtnClass","rasterMenuBtnClass","name","setVariable","children","graphBar","el","getElementNode","focusButton","makeChildWidgets","firstChild","viewHolder","updates","isZombieWidget","changedTiddlers","rebuildGraph","reinitNetwork","rebuildGraphOptions","refresh","isViewSwitched","hasChangedAttributes","nodeTypes","isViewUpdated","update","ignoreNextViewModification","reloadBackgroundImage","resetEdgeTypeWL","hasChangedElements","removeChildDomNodes","refreshChildren","isForce","remove","refreshTriggers","str","parseStringArray","length","i","add","handleTriggeredRefresh","_ref","undefined","resetFocus","isPreviewed","hasNetworkStabilized","changes","rebuildGraphData","duration","physics","solver","centralGravity","network","setOptions","visOptions","hasElements","graphData","nodesById","stabilize","start","graph","getGraph","changedNodes","refreshDataSet","nodes","changedEdges","edges","edgesById","setField","getTiddlersByIds","stop","startsWith","localHolders","keys","maybeMatches","inGraph","isShowNeighbourhood","tRef","isSystemOrDraft","getId","modified","nodeFilter","matches","getMatches","_this3","_destructVis","getVisOptions","_vis2","DataSet","makeHashMap","setEnabled","enabled","Network","canvas","event","on","bind","addGraphButtons","fullscreen-button","fullscreenButton","halfscreen-button","focus","ev","_this4","nodeIds","getSelectedNodes","ctrlKey","preventDefault","keyCode","handleAddNodesToClipboard","handlePasteNodesFromClipboard","allNodes","selectNodes","getElementsByTagName","tabIndex","notify","ucFirst","role","openTiddlerWithId","handleRemoveElements","getSelection","elements","selectRect","selectedNodes","stopPropagation","target","mouse","DOMtoCanvas","offsetX","offsetY","span","nodePositions","getPositions","isPointWithin","inArray","assignActiveStyle","paramObject","redraw","zoomView","enlargedMode","interaction","_this5","hide","nodeId","getNodeAt","div","mode","registerTransclude","contextMenuWidget","focusButtonStateTRef","deleteByPrefix","clipBoard","ids","addNode","get","returnType","removeNode","_this6","vis","localOptions","parseJSON","merge","globalOptions","manipulation","deleteNode","data","resetVisManipulationBar","deleteEdge","addEdge","handleConnectionEvent","editNode","handleEditNode","editEdge","stabilization","iterations","visCallback","disableEditMode","enableEditMode","getElementsByClassName","isClone","getField","_ViewAbstraction2","handleInsertNode","isLiveView","newView","isCreate","protoView","_this7","setView","references","getOccurrences","count","toString","joinAndWrap","_this8","rename","_this9","visInherited","JSON","stringify","viewConfig","preselects","filter.prettyNodeFltr","filter.prettyEdgeFltr","vis-inherited","createdOn","getCreationDate","numberOfNodes","numberOfEdges","extend","fields","prvBg","setConfig","curBg","filter","setNodeFilter","nf","eTf","tempImagePath","createAndSaveSnapshot","defaultName","getSnapshotTitle","dialog","snapshot","width","height","action","cp","_this10","dispatchEvent","navigateTo","addPlaceholder","wiki","deleteTiddler","title","a","href","getSnapshot","MouseEvent","addTiddler","Tiddler","text","Date","stripPreamble","toDataURL","getWithoutPrefix","_this11","viewname","openStandardConfirmDialog","download","destroy","defaultViewLabel","msg","trigger","curTiddler","getTiddler","liveTab","fallbackView","_ref2","handleRemoveEdges","deleteEdges","edgeIds","tiddlers","params","stringifyList","delete-from","deleteNodes","deletionCount","success","_this12","handleRemoveNodes","findAndRemoveClassNames","scrollTop","pContainer","rootWidget","_ref3","setCentralTopic","withNotify","getNodeData","positions","saveNodeData","properties","idsOfNodesWithoutPosition","setNodesMoveable","_ref4","scale","animation","getContainer","_this13","clearTimeout","fit","easingFunction","activeFitTimeout","setTimeout","node","_this14","tiddlerExists","isMatch","getNodeFilter","makeNode","tObj","draft.title","_this15","tracker","getTiddlerById","globalDefaults","localDefaults","nodeStylesByTRef","getInheritedNodeStyles","color","nodeData","tiddler","tidColor","tidIcon","field","nodeIcon","tidLabelField","nodeLabel","tidIconField","inherited-global-default-style","inherited-local-default-style","inherited-group-styles","groupStyles","global.tmap.style","globalNodeStyle","local-node-style","addToPreselects","scope","store","getPropertiesByPrefix","p","global","local","saveNodeStyle","isActivated","singleClickMode","handleOpenMapElementEvent","pointer","typeId","handleEditEdgeType","hidePopups","behaviour","edgeClickBehaviour","getBoundingClientRect","clientWidth","rect","left","distRight","parseInt","calculatedHeight","innerHeight","top","distBottom","style","evt","selected","_ref6","isArray","defaultColor","highlight","hover","pos","_extends","getNearestRasterPosition","draggedNode","context2d","backgroundImage","drawImage","drawRaster","colorObj","getRect","beginPath","globalAlpha","fillStyle","fillRect","_toConsumableArray","strokeStyle","strokeRect","rPos","stroke","arc","Math","PI","fill","signature","outType","descr","nodeInfo","innerHTML","renderText","inType","tooltipWidget","render","allETy","description","moveTo","isVisInEditMode","isShown","populator","constructTooltip","show","total","display","_ref9","draftTRef","findDraft","wasInDraftAlready","_this16","tiddlerTitle","originalTRef","bounds","navigateFromTitle","navigateFromNode","navigateFromClientRect","right","bottom","viewName","holderRef","viewRef","views","genUUID","defaultViewHolder","noCache","_this17","bgFieldValue","imgTObj","img","Image","ajaxCallback","b64","src","onload","urlField","getImgFromWeb","isInFS","hasClass","fitGraph","enable","b","toggleClass","isMoveable","isFixed","fixed","buttonEvents","addEventListener","setGraphButtonEnabled","tmap","tiddlymap"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/widget/MapWidget.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget\ntype: application/javascript\nmodule-type: widget\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport DialogManager        from '$:/plugins/felixhayashi/tiddlymap/js/DialogManager';\nimport CallbackManager      from '$:/plugins/felixhayashi/tiddlymap/js/CallbackManager';\nimport ViewAbstraction      from '$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction';\nimport EdgeType             from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport Popup                from '$:/plugins/felixhayashi/tiddlymap/js/Popup';\nimport vis                  from '$:/plugins/felixhayashi/vis/vis.js';\nimport { widget as Widget } from '$:/core/modules/widgets/widget.js';\nimport utils                from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport SelectionRectangle   from '$:/plugins/felixhayashi/tiddlymap/js/lib/SelectionRectangle';\n\n/*** Code **********************************************************/\n\n/**\n * The map widget is responsible for drawing the actual network\n * diagrams.\n *\n * @constructor\n */\nclass MapWidget extends Widget {\n\n  constructor(parseTreeNode, options) {\n    super(parseTreeNode, options);\n\n    // create shortcuts for services and frequently used vars\n    this.getAttr = this.getAttribute;\n    this.isDebug = utils.isTrue($tm.config.sys.debug, false);\n\n    // force early binding of functions to this context\n    utils.bindTo(this, [\n      'constructTooltip',\n      'handleResizeEvent',\n      'handleClickEvent',\n      'handleCanvasKeyup',\n      'handleCanvasKeydown',\n      'handleCanvasScroll',\n      'handleCanvasMouseMove',\n      'handleWidgetKeyup',\n      'handleWidgetKeydown',\n      'handleTriggeredRefresh',\n      'handleContextMenu'\n    ]);\n\n    // instanciate managers\n    this.callbackManager = new CallbackManager();\n    this.dialogManager = new DialogManager(this.callbackManager, this);\n\n    // make the html attributes available to this widget\n    this.computeAttributes();\n    this.editorMode = this.getAttr('editor');\n    this.clickToUse = utils.isTrue(this.getAttr('click-to-use'), false);\n\n    // who am I? the id is used for debugging and special cases\n    this.id = this.getAttr('object-id') || this.getStateQualifier();\n\n    this.widgetPopupsPath = $tm.path.tempPopups + '/' + this.id;\n\n    // register listeners that are available in editor mode\n    if (this.editorMode) {\n      utils.addTWlisteners({\n        'tmap:tm-create-view': this.handleCreateView,\n        'tmap:tm-rename-view': this.handleRenameView,\n        'tmap:tm-delete-view': this.handleDeleteView,\n        'tmap:tm-delete-element': this.handleDeleteElement,\n        'tmap:tm-edit-view': this.handleEditView,\n        'tmap:tm-store-position': this.handleStorePositions,\n        'tmap:tm-generate-widget': this.handleGenerateWidget,\n        'tmap:tm-toggle-central-topic': this.handleSetCentralTopic,\n        'tmap:tm-save-canvas': this.handleSaveCanvas\n      }, this, this);\n    }\n\n    // register listeners that are available in any case\n    utils.addTWlisteners({\n      'tmap:tm-focus-node': this.handleFocusNode,\n      'tmap:tm-reset-focus': this.repaintGraph\n    }, this, this);\n\n    // Visjs handlers\n    this.visListeners = {\n      'click': this.handleVisSingleClickEvent,\n      'doubleClick': this.handleVisDoubleClickEvent,\n      'stabilized': this.handleVisStabilizedEvent,\n      'selectNode': this.handleVisSelectNode,\n      'deselectNode': this.handleVisDeselectNode,\n      'dragStart': this.handleVisDragStart,\n      'dragEnd': this.handleVisDragEnd,\n      'hoverNode': this.handleVisHoverElement,\n      'hoverEdge': this.handleVisHoverElement,\n      'blurNode': this.handleVisBlurElement,\n      'blurEdge': this.handleVisBlurElement,\n      'beforeDrawing': this.handleVisBeforeDrawing,\n      'afterDrawing': this.handleVisAfterDrawing,\n      'stabilizationProgress': this.handleVisLoading,\n      'stabilizationIterationsDone': this.handleVisLoadingDone\n    };\n\n    this.windowDomListeners = {\n      'resize': [ this.handleResizeEvent, false ],\n      'click': [ this.handleClickEvent, false ],\n      'mousemove': [ this.handleCanvasMouseMove, true ],\n    };\n\n    this.canvasDomListeners = {\n      'keyup': [ this.handleCanvasKeyup, true ],\n      'keydown': [ this.handleCanvasKeydown, true ],\n      'mousewheel': [ this.handleCanvasScroll, true ],\n      'contextmenu': [ this.handleContextMenu, true ],\n    };\n\n    this.widgetDomListeners = {\n      'keyup': [ this.handleWidgetKeyup, true ],\n      'keydown': [ this.handleWidgetKeydown, true ],\n    };\n\n    this.conVector = { from: null, to: null };\n  }\n\n  /**\n   * This handler will open a dialog that allows the user to create a\n   * new relation between two edges. This includes, that the user\n   * gets a chance to specify the edgetype of the connection.\n   *\n   * If an edge-type namespace has been declared for the entire view,\n   * then add it to the `id` of the specified type…\n   *   - …if the type doesn't exist yet.\n   *   - …if the type doesn't contain a namespace already, regardless\n   *     whether it exists or not.\n   *\n   * Once the user confirmed the dialog, the edge is persisted.\n   *\n   * @param {Edge} edge - A javascript object that contains at least\n   *    the properties 'from' and 'to'\n   * @param {function} [callback] - A function with the signature\n   *    function(isConfirmed);\n   */\n  handleConnectionEvent(edge, callback) {\n\n    const eTyFilter = this.view.getEdgeTypeFilter();\n\n    const param = {\n      fromLabel: $tm.adapter.selectNodeById(edge.from).label,\n      toLabel: $tm.adapter.selectNodeById(edge.to).label,\n      viewNS: this.view.getConfig('edge_type_namespace'),\n      eTyFilter: eTyFilter.raw\n    };\n\n    this.dialogManager.open('getEdgeType', param, (isConfirmed, outTObj) => {\n\n      if (isConfirmed) {\n\n        const options = {\n          namespace: this.view.getConfig('edge_type_namespace')\n        };\n        const type = new EdgeType(utils.getText(outTObj), null, options);\n\n        // persist the type if it doesn't exist\n        if (!type.exists()) type.save();\n\n        // add type to edge\n        edge.type = type.id;\n        $tm.adapter.insertEdge(edge);\n\n        if (!this.view.isEdgeTypeVisible(type.id)) {\n\n          this.dialogManager.open('edgeNotVisible', {\n            type: type.id,\n            view: this.view.getLabel(),\n            eTyFilter: eTyFilter.pretty\n          });\n\n        }\n\n      }\n\n      if (typeof callback === 'function') {\n        callback(isConfirmed);\n      }\n\n    });\n\n  }\n\n  /**\n   * The first time a map is opened, we want to display a welcome message.\n   * Once shown, a flag is set and the message is not displayed again.\n   */\n  checkForFreshInstall() {\n\n    if (!utils.getEntry($tm.ref.sysMeta, 'showWelcomeMessage', true)) {\n      return;\n    }\n\n    utils.setEntry($tm.ref.sysMeta, 'showWelcomeMessage', false);\n\n    this.dialogManager.open('welcome', {}, (isConfirmed, outTObj) => {\n\n      if (utils.tiddlerExists('$:/plugins/felixhayashi/topstoryview')) {\n\n        utils.setText('$:/view', 'top');\n        utils.setText('$:/config/Navigation/openLinkFromInsideRiver', 'above');\n        utils.setText('$:/config/Navigation/openLinkFromOutsideRiver', 'top');\n        utils.setText('$:/themes/tiddlywiki/vanilla/options/sidebarlayout', 'fixed-fluid');\n\n        // trigger a save and reload message\n        utils.touch('$:/plugins/felixhayashi/topstoryview');\n      }\n\n      const view = $tm.misc.defaultViewLabel;\n\n      const n1 = $tm.adapter.insertNode({ label: 'Have fun with', x: 0, y: 0 }, view);\n      const n2 = $tm.adapter.insertNode({ label: 'TiddlyMap!!', x: 100, y: 100 }, view);\n\n      $tm.adapter.insertEdge({ from: n1.id, to: n2.id });\n\n    });\n\n  }\n\n  /**\n   * A very basic dialog that will tell the user he/she has to make\n   * a choice.\n   *\n   * @param {function} [callback] - A function with the signature\n   *     function(isConfirmed).\n   * @param {string} [message] - An small optional message to display.\n   */\n  openStandardConfirmDialog(callback, message) {\n\n    const param = { message : message };\n    this.dialogManager.open('getConfirmation', param, callback);\n\n  }\n\n  /**\n   * An extention of the default logger mechanism. It works like\n   * `this.logger` but will include the object id of the widget\n   * instance.\n   *\n   * @param {string} type - The type of the message (debug, info, warning…)\n   *     which is exactly the same as in `console[type]`.\n   * @param {...*} message - An infinite number of arguments to be printed\n   *     (just like console).\n   */\n  logger(type, message /*, more stuff*/) {\n\n    if (this.isDebug) {\n\n      const args = Array.prototype.slice.call(arguments, 1);\n      args.unshift('@' + this.id);\n      args.unshift(type);\n      $tm.logger.apply(this, args);\n\n    }\n\n  }\n\n  /**\n   * Method to render this widget into the DOM.\n   *\n   * Note that we do not add this.domNode to the list of domNodes\n   * since this widget does never remove itself during a refresh.\n   *\n   * @override\n   */\n  render(parent, nextSibling) {\n\n    this.parentDomNode = parent;\n\n    this.domNode = this.document.createElement('div');\n    parent.insertBefore(this.domNode, nextSibling);\n\n    // add widget classes\n    this.registerClassNames(this.domNode);\n\n    // get view and view holder\n    this.viewHolderRef = this.getViewHolderRef();\n    this.view = this.getView();\n\n    // create the header div\n    this.graphBarDomNode = this.document.createElement('div');\n    $tw.utils.addClass(this.graphBarDomNode, 'tmap-topbar');\n    this.domNode.appendChild(this.graphBarDomNode);\n\n    // create body div\n    this.graphDomNode = this.document.createElement('div');\n    this.domNode.appendChild(this.graphDomNode);\n\n    $tw.utils.addClass(this.graphDomNode, 'tmap-vis-graph');\n\n    if (utils.isPreviewed(this) || this.domNode.isTiddlyWikiFakeDom) {\n\n      $tw.utils.addClass(this.domNode, 'tmap-static-mode');\n      this.renderPreview(this.graphBarDomNode, this.graphDomNode);\n\n    } else {\n\n      // render the full widget\n      this.renderFullWidget(this.domNode, this.graphBarDomNode, this.graphDomNode);\n\n    }\n\n  }\n\n  /**\n   * When the widget is only previewed we do some alternative rendering.\n   */\n  renderPreview(header, body) {\n\n    const snapshotTRef = this.view.getRoot() + '/snapshot';\n    const snapshotTObj = utils.getTiddler(snapshotTRef);\n\n    const label = this.document.createElement('span');\n    label.innerHTML = this.view.getLabel();\n    label.className = 'tmap-view-label';\n    header.appendChild(label);\n\n    if (snapshotTObj) {\n\n      // Construct child widget tree\n      const placeholder = this.makeChildWidget(utils.getTranscludeNode(snapshotTRef), true);\n      placeholder.renderChildren(body, null);\n\n    } else {\n\n      $tw.utils.addClass(body, 'tmap-graph-placeholder');\n\n    }\n\n  }\n\n  /**\n   * The standard way of rendering.\n   * Attention: BE CAREFUL WITH THE ORDER OF FUNCTION CALLS IN THIS FUNCTION.\n   */\n  renderFullWidget(widget, header, body) {\n\n    // add window and widget dom node listeners\n    utils.setDomListeners('add', window, this.windowDomListeners);\n    utils.setDomListeners('add', widget, this.widgetDomListeners);\n\n    // add a loading bar\n    this.addLoadingBar(this.domNode);\n\n    // prepare the tooltip for graph elements\n    this.tooltip = new Popup(this.domNode, {\n      className: 'tmap-tooltip',\n      showDelay: $tm.config.sys.popups.delay\n    });\n\n    // prepare the context menu\n    this.contextMenu = new Popup(this.domNode, {\n      className: 'tmap-context-menu',\n      showDelay: 0,\n      hideOnClick: true,\n      leavingDelay: 999999\n    });\n\n    // register\n    this.sidebar = utils.getFirstElementByClassName('tc-sidebar-scrollable');\n    this.isInSidebar = (this.sidebar\n                                 && !this.domNode.isTiddlyWikiFakeDom\n                                 && this.sidebar.contains(this.domNode));\n\n    // *first* inject the bar\n    this.rebuildEditorBar(header);\n\n    // *second* initialise graph variables and render the graph\n    this.initAndRenderGraph(body);\n\n    // register this graph at the caretaker's graph registry\n    $tm.registry.push(this);\n\n    // if any refresh-triggers exist, register them\n    this.reloadRefreshTriggers();\n\n    // maybe display a welcome message\n    this.checkForFreshInstall();\n\n    if (this.id === $tm.misc.mainEditorId) {\n\n      const url = $tm.url;\n      if (url && url.query['tmap-enlarged']) {\n\n        this.toggleEnlargedMode(url.query['tmap-enlarged']);\n        //~ this.setView(url.query['tmap-view']);\n\n      }\n\n    }\n\n  }\n\n  /**\n   * Add some classes to give the user a chance to apply some css\n   * to different graph modes.\n   */\n  registerClassNames(parent) {\n\n    const addClass = $tw.utils.addClass;\n\n    // add main class\n    addClass(parent, 'tmap-widget');\n\n    if (this.clickToUse) {\n      addClass(parent, 'tmap-click-to-use');\n    }\n\n    if (this.getAttr('editor') === 'advanced') {\n      addClass(parent, 'tmap-advanced-editor');\n    }\n\n    if (this.getAttr('design') === 'plain') {\n      addClass(parent, 'tmap-plain-design');\n    }\n\n    if (!utils.isTrue(this.getAttr('show-buttons'), true)) {\n      addClass(parent, 'tmap-no-buttons');\n    }\n\n    if (this.getAttr('class')) {\n      addClass(parent, this.getAttr('class'));\n    }\n\n  }\n\n  /**\n   * Adds a loading bar div below the parent.\n   */\n  addLoadingBar(parent) {\n\n    this.graphLoadingBarDomNode = this.document.createElement('progress');\n    $tw.utils.addClass(this.graphLoadingBarDomNode, 'tmap-loading-bar');\n    parent.appendChild(this.graphLoadingBarDomNode);\n\n  }\n\n  /**\n   * The editor bar contains a bunch of widgets that allow the user\n   * to manipulate the current view.\n   *\n   * Attention: The Editor bar needs to render *after* the graph\n   * because some elements depend on the graph's nodes which are\n   * calculated when the network is created.\n   *\n   * @see https://groups.google.com/forum/#!topic/tiddlywikidev/sJrblP4A0o4\n   * @see blob/master/editions/test/tiddlers/tests/test-wikitext-parser.js\n   */\n  rebuildEditorBar() {\n\n    // register dialog variables\n\n    const { view } = this;\n    const unicodeBtnClass = 'tmap-unicode-button';\n    const activeUnicodeBtnClass = `${unicodeBtnClass} tmap-active-button`;\n    const variables = {\n      widgetQualifier: this.getStateQualifier(),\n      widgetTempPath: this.widgetTempPath,\n      widgetPopupsPath: this.widgetPopupsPath,\n      isViewBound: String(this.isViewBound()),\n      viewRoot: view.getRoot(),\n      viewLabel: view.getLabel(),\n      viewHolder: this.getViewHolderRef(),\n      edgeTypeFilter: view.getPaths().edgeTypeFilter,\n      allEdgesFilter: $tm.selector.allEdgeTypes,\n      neighScopeBtnClass: view.isEnabled('neighbourhood_scope') ? activeUnicodeBtnClass : unicodeBtnClass,\n      rasterMenuBtnClass: view.isEnabled('raster') ? activeUnicodeBtnClass : unicodeBtnClass,\n    };\n\n    for (let name in variables) {\n      this.setVariable(name, variables[name]);\n    }\n\n    // Construct the child widget tree\n    const body = utils.getTiddlerNode(view.getRoot());\n\n    if (this.editorMode === 'advanced') {\n\n      body.children.push(utils.getTranscludeNode($tm.ref.graphBar));\n\n    } else {\n\n      const el = utils.getElementNode('span', 'tmap-view-label', view.getLabel());\n      body.children.push(el);\n\n    }\n\n    body.children.push(utils.getTranscludeNode($tm.ref.focusButton));\n\n    this.makeChildWidgets([ body ]);\n    this.renderChildren(this.graphBarDomNode, this.graphBarDomNode.firstChild);\n\n  }\n\n  /**\n   * This function is called by the system to notify the widget about\n   * tiddler changes. It is ignored by TiddlyMap.\n   *\n   * ATTENTION: TiddlyMap doesn't use the refresh mechanism here.\n   * The caretaker module dispatches an `updates` object that provides\n   * more advanced information, tailored to the needs of TiddlyMap.\n   * These updates are picked up by {@link MapWidget#update}.\n   *\n   * @override\n   */\n  refresh(changedTiddlers) {\n\n    // TiddlyMap never needs a full refresh so we return false\n    return false;\n\n  }\n\n  /**\n   * This function is called by the caretaker module to notify the\n   * widget about tiddler changes.\n   *\n   * TiddlyMap is interested in the following changes:\n   *\n   * - Callbacks have been triggered (e.g. dialog results)\n   * - A view has been switched\n   * - A view has been modified (= configured)\n   * - Global options have changed\n   * - Node- or edge-types have changed\n   * - Graph elements have changed\n   * - Changes to the graph's topbar\n   *\n   * @override\n   * @see https://groups.google.com/d/msg/tiddlywikidev/hwtX59tKsIk/EWSG9glqCnsJ\n   */\n  update(updates) {\n\n    if (!this.network || this.isZombieWidget() || utils.isPreviewed(this)) {\n      return;\n    }\n\n    const changedTiddlers = updates.changedTiddlers;\n\n    let rebuildEditorBar = false;\n    let rebuildGraph = false;\n    let reinitNetwork = false;\n    let rebuildGraphOptions = {};\n\n    // check for callback changes\n    this.callbackManager.refresh(changedTiddlers);\n\n    if (this.isViewSwitched(changedTiddlers)\n       || this.hasChangedAttributes()\n       || updates[$tm.path.options]\n       || updates[$tm.path.nodeTypes]\n       || changedTiddlers[this.view.getRoot()]) {\n\n      this.logger('warn', 'View switched (or main config change)');\n\n      this.view = this.getView(true);\n      this.reloadRefreshTriggers();\n\n      rebuildEditorBar = true;\n      reinitNetwork = true;\n\n    } else { // view has not been switched\n\n      // give the view a chance to refresh its components\n      const isViewUpdated = this.view.update(updates);\n\n      if (isViewUpdated && !this.ignoreNextViewModification) {\n\n        this.logger('warn', 'View components modified');\n\n        this.reloadBackgroundImage();\n        rebuildEditorBar = true;\n        rebuildGraph = true;\n        rebuildGraphOptions.resetEdgeTypeWL = true;\n\n      } else { // neither view switch or view modification\n\n        if (updates[$tm.path.nodeTypes]) {\n          rebuildGraph = true;\n\n        } else if (this.hasChangedElements(changedTiddlers)) {\n          rebuildGraph = true;\n        }\n\n      }\n    }\n\n    if (reinitNetwork) {\n      this.initAndRenderGraph(this.graphDomNode);\n      this.hidePopups(0, true);\n\n    } else if (rebuildGraph) {\n      this.rebuildGraph(rebuildGraphOptions);\n      this.hidePopups(0, true);\n    }\n\n    if (rebuildEditorBar) {\n\n      this.removeChildDomNodes();\n      this.rebuildEditorBar();\n\n    } else {\n\n      // give children a chance to update themselves\n      this.refreshChildren(changedTiddlers);\n\n    }\n\n    // reset this again\n    this.ignoreNextViewModification = false;\n\n  }\n\n  hidePopups(delay, isForce) {\n\n    this.tooltip.hide(delay, isForce);\n    this.contextMenu.hide(0, true);\n\n  }\n\n  /**\n   * Refresh-triggers are tiddlers whose mere occurrence in the\n   * changedTiddlers list forces tiddlymap to reassert\n   * whether a filter expression returns the same set of matches as it\n   * is currently displayed in the graph.\n   *\n   * The raison d'etre for refresh-triggers is that a filter may contain\n   * implicit text-references or variables that may require a filter to be\n   * reasserted even though, the filter expression itself did not change.\n   *\n   * For example a filter `[field:title{$:/HistoryList!!current-tiddler}]`\n   * requires a `$:/HistoryList` refresh trigger to be added to the view so\n   * everytime the `$:/HistoryList` tiddler changes, the filter gets\n   * reasserted.\n   */\n  reloadRefreshTriggers() {\n\n    // remove old triggers (if there are any)\n    this.callbackManager.remove(this.refreshTriggers);\n\n    // load new trigger list either from attribute or view config\n    const str = this.getAttr('refresh-triggers') || this.view.getConfig('refresh-triggers');\n    this.refreshTriggers = $tw.utils.parseStringArray(str) || [];\n\n    this.logger('debug', 'Registering refresh trigger', this.refreshTriggers);\n\n    // TODO: not nice, if more than one trigger changed it\n    // will cause multiple reassertments\n    for (let i = this.refreshTriggers.length; i--;) {\n      this.callbackManager.add(this.refreshTriggers[i],\n                               this.handleTriggeredRefresh,\n                               false);\n    }\n\n  }\n\n  /**\n   * Calling this method will cause the graph to be rebuild, which means\n   * the graph data is refreshed. A rebuild of the graph will always\n   * cause the network to stabilize again.\n   *\n   * @param {Hashmap} [resetFocus=null] - If not false or null,\n   *     this object requires two properties to be set: `delay` (the\n   *     time to wait before starting the fit), `duration` (the length\n   *     of the fit animation).\n   */\n  rebuildGraph({ resetFocus } = {}) {\n\n    if (utils.isPreviewed(this)) {\n      return;\n    }\n\n    this.logger('debug', 'Rebuilding graph');\n\n    // always reset to allow handling of stabilized-event!\n    this.hasNetworkStabilized = false;\n\n    const changes = this.rebuildGraphData();\n\n    if (changes.changedNodes.withoutPosition.length) {\n\n      resetFocus = resetFocus || { delay: 1000, duration: 1000 };\n\n      if (!this.view.isEnabled('physics_mode')) {\n\n        // in static mode we need to ensure that objects spawn\n        // near center so we need to set physics from\n        // zero to something. Yes, we override the users\n        // central gravity value… who cares about central\n        // gravity in static mode anyways.\n        const physics = this.visOptions.physics;\n        physics[physics.solver].centralGravity = 0.25;\n        this.network.setOptions(this.visOptions);\n\n      }\n    }\n\n    if (!utils.hasElements(this.graphData.nodesById)) {\n      return;\n    }\n\n    if (resetFocus) {\n      // see https://github.com/almende/vis/issues/987#issuecomment-113226216\n      // see https://github.com/almende/vis/issues/939\n      this.network.stabilize();\n\n      this.resetFocus = resetFocus;\n\n    }\n\n  }\n\n  /**\n   * WARNING: Do not change this functionname as it is used by the\n   * caretaker's routinely checkups.\n   */\n  getContainer() {\n\n    return this.domNode;\n\n  }\n\n  /**\n   *\n   */\n  rebuildGraphData() {\n\n    $tm.start('Reloading Network');\n\n    const graph = $tm.adapter.getGraph({ view: this.view });\n\n    const changedNodes = utils.refreshDataSet(\n      this.graphData.nodes, // dataset\n      graph.nodes // new nodes\n    );\n\n    const changedEdges = utils.refreshDataSet(\n      this.graphData.edges, // dataset\n      graph.edges // new edges\n    );\n\n    // create lookup tables\n\n    this.graphData.nodesById = graph.nodes;\n    this.graphData.edgesById = graph.edges;\n\n    // TODO: that's a performance killer. this should be loaded when\n    // the search is actually used!\n    // update: Careful when refactoring, some modules are using this…\n    utils.setField(`$:/temp/tmap/nodes/${this.view.getLabel()}`, 'list', $tm.adapter.getTiddlersByIds(graph.nodes));\n\n    $tm.stop('Reloading Network');\n\n    return { changedEdges, changedNodes };\n\n  }\n\n  isViewBound() {\n\n    return utils.startsWith(this.getViewHolderRef(), $tm.path.localHolders);\n\n  }\n\n  /**\n   * A view is switched, if the holder was changed.\n   */\n  isViewSwitched(changedTiddlers) {\n\n    return changedTiddlers[this.getViewHolderRef()];\n\n  }\n\n  /**\n   * A view is switched, if the holder was changed.\n   */\n  hasChangedAttributes() {\n\n    return Object.keys(this.computeAttributes()).length;\n\n  }\n\n  /**\n   * Rebuild or update the graph if one of the following is true:\n   *\n   * 1. A tiddler currently contained as node in the graph has been\n   *    deleted or modified. This also includes tiddlers that are\n   *    represented as neighbours in the graph.\n   * 2. The neighbourhood is shown and a non-system tiddler has changed.\n   * 3. A tiddler that matches the node filter has been modified\n   *    (not deleted).\n   *\n   * Since edges are stored in tiddlers themselves, any edge modification\n   * is always accounted for as in this case the tiddler holding the\n   * edge would be included as changed tiddler.\n   *\n   * @param {Hashmap<TiddlerReference, *>} changedTiddlers - A list of\n   *     tiddler changes.\n   *\n   * @return {boolean} true if the graph needs a refresh.\n   */\n  hasChangedElements(changedTiddlers) {\n\n    const maybeMatches = [];\n    const inGraph = this.graphData.nodesById;\n    const isShowNeighbourhood = this.view.isEnabled('neighbourhood_scope');\n\n    for (let tRef in changedTiddlers) {\n\n      if (utils.isSystemOrDraft(tRef)) {\n        continue;\n      }\n\n      if (inGraph[$tm.adapter.getId(tRef)] || isShowNeighbourhood) {\n        return true;\n      }\n\n      if (changedTiddlers[tRef].modified) {\n        // may be a match so we store this and process it later\n        maybeMatches.push(tRef);\n      }\n    }\n\n    if (maybeMatches.length) {\n\n      const nodeFilter = this.view.getNodeFilter('compiled');\n      const matches = utils.getMatches(nodeFilter, maybeMatches);\n      return !!matches.length;\n\n    }\n\n  }\n\n  /**\n   * Rebuild the graph\n   *\n   * @see http://visjs.org/docs/network.html\n   * @see http://visjs.org/docs/dataset.html\n   */\n  initAndRenderGraph(parent) {\n\n    // make sure to destroy any previous instance\n    if (this.network) {\n      this._destructVis();\n    }\n\n    this.logger('info', 'Initializing and rendering the graph');\n\n    if (!this.isInSidebar) {\n      this.callbackManager.add('$:/state/sidebar', this.handleResizeEvent);\n    }\n\n    this.visOptions = this.getVisOptions();\n\n    this.graphData = {\n      nodes: new vis.DataSet(),\n      edges: new vis.DataSet(),\n      nodesById: utils.makeHashMap(),\n      edgesById: utils.makeHashMap()\n    };\n\n    this.tooltip.setEnabled(utils.isTrue($tm.config.sys.popups.enabled, true));\n\n    this.network = new vis.Network(parent, this.graphData, this.visOptions);\n    // after vis.Network has been instantiated, we fetch a reference to\n    // the canvas element\n    this.canvas = parent.getElementsByTagName('canvas')[0];\n    // just to be sure\n    this.canvas.tabIndex = 0;\n\n    for (let event in this.visListeners) {\n      this.network.on(event, this.visListeners[event].bind(this));\n    }\n\n    this.addGraphButtons({\n      'fullscreen-button': () => { this.toggleEnlargedMode('fullscreen'); },\n      'halfscreen-button': () => { this.toggleEnlargedMode('halfscreen'); }\n    });\n\n    utils.setDomListeners('add', this.canvas, this.canvasDomListeners);\n\n    this.reloadBackgroundImage();\n    this.rebuildGraph({\n      resetFocus: { delay: 0, duration: 0 },\n    });\n    this.handleResizeEvent();\n    this.canvas.focus();\n\n  }\n\n  handleCanvasKeyup(ev) {\n\n    const nodeIds = this.network.getSelectedNodes();\n\n    // this.isCtrlKeyDown = ev.ctrlKey;\n\n    if (ev.ctrlKey) { // ctrl key is hold down\n      ev.preventDefault();\n\n      if (ev.keyCode === 88) { // x\n        if (this.editorMode) {\n          this.handleAddNodesToClipboard('move');\n        } else {\n          $tm.notify('Map is read only!');\n        }\n\n      } else if (ev.keyCode === 67) { // c\n        this.handleAddNodesToClipboard('copy');\n\n      } else if (ev.keyCode === 86) { // v\n        this.handlePasteNodesFromClipboard();\n\n      } else if (ev.keyCode === 65) { // a\n        const allNodes = Object.keys(this.graphData.nodesById);\n        this.network.selectNodes(allNodes);\n\n      } else if (ev.keyCode === 49 || ev.keyCode === 50) { // 1 || 2\n        if (nodeIds.length !== 1) return;\n\n        const role = ev.keyCode === 49 ? 'from' : 'to';\n        $tm.notify(utils.ucFirst(role) + '-part selected');\n\n        this.conVector[role] = nodeIds[0];\n        if (this.conVector.from && this.conVector.to) {\n          // create the edge\n          this.handleConnectionEvent(this.conVector, () => {\n            // reset both properties, regardless whether confirmed\n            this.conVector = { from: null, to: null };\n          });\n        }\n\n      }\n\n    } else { // ctrl is not pressed\n\n      if (ev.keyCode === 13) { // ENTER\n\n        if (nodeIds.length !== 1) return;\n\n        this.openTiddlerWithId(nodeIds[0]);\n\n      }\n    }\n  }\n\n  handleCanvasKeydown(ev) {\n\n    if (ev.keyCode === 46) { // delete\n      ev.preventDefault();\n      this.handleRemoveElements(this.network.getSelection());\n    }\n\n  }\n\n  handleDeleteElement(ev) {\n\n    const id = ev.paramObject.id;\n    const elements = (id ? [ id ] : this.network.getSelectedNodes());\n\n    this.handleRemoveElements({ nodes: elements });\n\n  }\n\n  /**\n   *\n   * @param ev\n   */\n  handleCanvasMouseMove(ev) {\n\n    const { network } = this;\n\n    if (!(ev.ctrlKey && ev.buttons)) {\n\n      if (this.selectRect) {\n        this.selectRect = null;\n        const selectedNodes = network.getSelectedNodes();\n        $tm.notify(`${selectedNodes.length} nodes selected`);\n        network.redraw();\n      }\n\n      return;\n\n    }\n\n    // prevent vis' network drag if ctrl key and mouse button is pressed\n    ev.preventDefault();\n    ev.stopPropagation();\n\n    if (!this.domNode.contains(ev.target)) {\n      // since we are using a global mouse listener, we need to check whether\n      // we are actually inside our widget, so we stop updating the selectRect\n      return;\n    }\n\n    const mouse = network.DOMtoCanvas({ x: ev.offsetX, y: ev.offsetY });\n\n    if (!this.selectRect) {\n      this.selectRect = new SelectionRectangle(mouse.x, mouse.y);\n    }\n\n    // register new coordinates\n    this.selectRect.span(mouse.x, mouse.y);\n    // retrieve current mouse positions\n    const nodePositions = network.getPositions();\n    // we include previously selected nodes in the new set\n    const selectedNodes = network.getSelectedNodes();\n\n    for (let id in nodePositions) {\n\n      if (this.selectRect.isPointWithin(nodePositions[id]) && !utils.inArray(id, selectedNodes)) {\n        selectedNodes.push(id);\n      }\n    }\n\n    network.selectNodes(selectedNodes);\n    this.assignActiveStyle(selectedNodes);\n\n    network.redraw();\n\n  }\n\n  //https://github.com/almende/vis/blob/111c9984bc4c1870d42ca96b45d90c13cb92fe0a/lib/network/modules/InteractionHandler.js\n  handleCanvasScroll(ev) {\n\n    const zoomView = !!(ev.ctrlKey || this.isInSidebar || this.enlargedMode);\n\n    if (zoomView) {\n      ev.preventDefault();\n    }\n\n    if (zoomView !== this.visOptions.interaction.zoomView) {\n\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      this.visOptions.interaction.zoomView = zoomView;\n      this.network.setOptions({ interaction: { zoomView }});\n\n      return false;\n    }\n\n  }\n\n  /**\n   * Called when the user click on the canvas with the right\n   * mouse button. A context menu is opened.\n   */\n  handleContextMenu(ev) {\n\n    ev.preventDefault();\n\n    const { network } = this;\n\n    this.tooltip.hide(0, true);\n\n    const nodeId = network.getNodeAt({ x: ev.offsetX, y: ev.offsetY });\n    if (!nodeId) return;\n\n    // ids of selected nodes\n    let selectedNodes = network.getSelectedNodes();\n\n    if (!utils.inArray(nodeId, selectedNodes)) {\n      // unselect other nodes and select this one instead…\n      selectedNodes = [ nodeId ];\n      network.selectNodes(selectedNodes);\n    }\n\n    this.contextMenu.show(selectedNodes, (selectedNodes, div) => {\n\n      const mode = (selectedNodes.length > 1 ? 'multi' : 'single');\n      const tRef = '$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node';\n\n      utils.registerTransclude(this, 'contextMenuWidget', tRef);\n      this.contextMenuWidget.setVariable('mode', mode);\n      this.contextMenuWidget.render(div);\n\n    });\n\n  }\n\n  handleWidgetKeyup(ev) {\n\n  }\n\n  handleWidgetKeydown(ev) {\n\n    if (ev.ctrlKey) { // ctrl key is hold down\n      ev.preventDefault();\n\n      if (ev.keyCode === 70) { // f\n        ev.preventDefault();\n\n        const focusButtonStateTRef = `${this.widgetPopupsPath}/focus`;\n        utils.setText(focusButtonStateTRef, utils.getText(focusButtonStateTRef) ? '' : '1');\n\n        // note: it is ok to focus the graph right after this,\n        // if the focus button is activated it will steal the focus anyway\n\n      } else {\n\n        return;\n\n      }\n\n    } else if (ev.keyCode === 120) { // F9\n      ev.preventDefault();\n      this.toggleEnlargedMode('halfscreen');\n\n    } else if (ev.keyCode === 121) { // F10\n      ev.preventDefault();\n      this.toggleEnlargedMode('fullscreen');\n\n    } else if (ev.keyCode === 27) { // ESC\n      ev.preventDefault();\n\n      utils.deleteByPrefix(this.widgetPopupsPath);\n\n    } else {\n      return;\n    }\n\n    this.canvas.focus();\n\n  }\n\n  handlePasteNodesFromClipboard() {\n\n    if (!this.editorMode || this.view.isLiveView()) {\n      $tm.notify('Map is read only!');\n      return;\n    }\n\n    if (!$tm.clipBoard || $tm.clipBoard.type !== 'nodes') {\n      $tm.notify('TiddlyMap clipboad is empty!');\n    }\n\n    const nodes = $tm.clipBoard.nodes;\n    const ids = Object.keys(nodes);\n\n    for (let i = ids.length; i--;) {\n\n      const id = ids[i];\n\n      if (this.graphData.nodesById[id]) {\n        // node already present in this view\n        continue;\n      }\n\n      this.view.addNode(nodes[id]);\n\n      // paste nodes so we can select them!\n      this.graphData.nodes.update({ id });\n    }\n\n    this.network.selectNodes(ids);\n\n    this.rebuildGraph({ resetFocus: { delay: 0, duration: 0 }});\n\n    $tm.notify(`pasted ${ids.length} nodes into map.`);\n\n  }\n\n  handleAddNodesToClipboard(mode) {\n\n    const nodeIds = this.network.getSelectedNodes();\n\n    if (!nodeIds.length) {\n      return;\n    }\n\n    $tm.clipBoard = {\n      type: 'nodes',\n      nodes: this.graphData.nodes.get(nodeIds, { returnType: 'Object' })\n    };\n\n    $tm.notify(`Copied ${nodeIds.length} nodes to clipboard`);\n\n    if (mode === 'move') {\n      for (let i = nodeIds.length; i--;) {\n        this.view.removeNode(nodeIds[i]);\n      }\n    }\n\n  }\n\n  /**\n   * @todo Instead of redrawing the whole graph when an edge or node is\n   * added it may be worth considering only getting the element from the\n   * adapter and directly inserting it into the graph and *avoid* a\n   * reload of the graph via `rebuildGraph`!\n   *\n   * @todo: too much recomputation -> outsource\n   */\n  getVisOptions() {\n\n    // merge options\n    const globalOptions = $tm.config.vis;\n    const localOptions = utils.parseJSON(this.view.getConfig('vis'));\n    const options = utils.merge({}, globalOptions, localOptions);\n\n    options.clickToUse = this.clickToUse;\n    options.manipulation.enabled = !!this.editorMode;\n\n    options.manipulation.deleteNode = (data, callback) => {\n      this.handleRemoveElements(data);\n      this.resetVisManipulationBar(callback);\n    };\n\n    options.manipulation.deleteEdge = (data, callback) => {\n      this.handleRemoveElements(data);\n      this.resetVisManipulationBar(callback);\n    };\n\n    options.manipulation.addEdge = (data, callback) => {\n      this.handleConnectionEvent(data);\n      this.resetVisManipulationBar(callback);\n    };\n\n    options.manipulation.addNode = (data, callback) => {\n      this.handleInsertNode(data);\n      this.resetVisManipulationBar(callback);\n    };\n\n    options.manipulation.editNode = (data, callback) => {\n      this.handleEditNode(data);\n      this.resetVisManipulationBar(callback);\n    };\n\n    options.interaction.zoomView = !!(this.isInSidebar || this.enlargedMode);\n\n    // not allowed\n    options.manipulation.editEdge = false;\n\n    // make sure the actual solver is an object\n    const physics = options.physics;\n    physics[physics.solver] = physics[physics.solver] || {};\n\n    physics.stabilization.iterations = 1000;\n\n    this.logger('debug', 'Loaded graph options', options);\n\n    return options;\n\n  }\n\n  resetVisManipulationBar(visCallback) {\n\n    if (visCallback) {\n      visCallback(null);\n    }\n\n    this.network.disableEditMode();\n    this.network.enableEditMode();\n\n  }\n\n  isVisInEditMode() {\n\n    return this.graphDomNode.getElementsByClassName('vis-button vis-back').length > 0;\n\n  }\n\n  /**\n   * Create an empty view. A dialog is opened that asks the user how to\n   * name the view. The view is then registered as current view.\n   */\n  handleCreateView() {\n\n    const args = {\n      view: this.view.getLabel()\n    };\n\n    this.dialogManager.open('createView', args, (isConfirmed, outTObj) => {\n\n      if (!isConfirmed) return;\n\n      const label = utils.getField(outTObj, 'name');\n      const isClone = utils.getField(outTObj, 'clone', false);\n      const view = new ViewAbstraction(label);\n\n      if (view.exists()) {\n        $tm.notify('Forbidden! View already exists!');\n        return;\n      }\n\n      if (isClone && this.view.isLiveView()) {\n        $tm.notify('Forbidden to clone the live view!');\n        return;\n      }\n\n      const newView = new ViewAbstraction(label, {\n        isCreate: true,\n        protoView: (isClone ? this.view : null)\n      });\n\n      this.setView(newView);\n\n    });\n\n  }\n\n  handleRenameView() {\n\n    if (this.view.isLocked()) {\n\n      $tm.notify('Forbidden!');\n      return;\n\n    }\n\n    const references = this.view.getOccurrences();\n\n    const args = {\n      count : references.length.toString(),\n      filter : utils.joinAndWrap(references, '[[', ']]')\n    };\n\n    this.dialogManager.open('renameView', args, (isConfirmed, outTObj) => {\n\n      if (!isConfirmed) return;\n\n      const label = utils.getText(outTObj);\n      const view = new ViewAbstraction(label);\n\n      if (!label) {\n        $tm.notify('Invalid name!');\n\n      } else if (view.exists()) {\n        $tm.notify('Forbidden! View already exists!');\n\n      } else {\n        this.view.rename(label);\n        this.setView(this.view);\n      }\n    });\n  }\n\n  handleEditView() {\n\n    const visInherited = JSON.stringify($tm.config.vis);\n    const data = this.graphData;\n\n    const viewConfig = this.view.getConfig();\n\n    const preselects = {\n      'filter.prettyNodeFltr': this.view.getNodeFilter('pretty'),\n      'filter.prettyEdgeFltr': this.view.getEdgeTypeFilter('pretty'),\n      'vis-inherited': visInherited\n    };\n\n    const args = {\n      view: this.view.getLabel(),\n      createdOn: this.view.getCreationDate(true),\n      numberOfNodes: Object.keys(data.nodesById).length.toString(),\n      numberOfEdges: Object.keys(data.edgesById).length.toString(),\n      dialog: {\n        preselects: $tw.utils.extend({}, viewConfig, preselects)\n      }\n    };\n\n    this.dialogManager.open('configureView', args, (isConfirmed, outTObj) => {\n\n      if (!isConfirmed) return;\n\n      const config = utils.getPropertiesByPrefix(outTObj.fields, 'config.', true);\n\n      // ATTENTION: needs to be tested before applying new config!\n      const prvBg = this.view.getConfig('background_image');\n\n      this.view.setConfig(config);\n      if (config['physics_mode'] && !this.view.isEnabled('physics_mode')) {\n        // when not in physics mode, store positions\n        // to prevent floating afterwards\n        this.handleStorePositions();\n      }\n\n      const curBg = this.view.getConfig('background_image');\n      if (curBg && curBg !== prvBg) {\n        $tm.notify('Background changed! You may need to zoom out a bit.');\n      }\n\n      const nf = utils.getField(outTObj, 'filter.prettyNodeFltr', '');\n      const eTf = utils.getField(outTObj, 'filter.prettyEdgeFltr', '');\n\n      this.view.setNodeFilter(nf);\n      this.view.setEdgeTypeFilter(eTf);\n\n    });\n  }\n\n  /**\n   * Triggers a download dialog where the user can store the canvas\n   * as png on his/her harddrive.\n   */\n  handleSaveCanvas() {\n\n    const tempImagePath = '$:/temp/tmap/snapshot';\n    this.createAndSaveSnapshot(tempImagePath);\n    let defaultName = utils.getSnapshotTitle(this.view.getLabel(), 'png');\n\n    const args = {\n      dialog: {\n        snapshot: tempImagePath,\n        width: this.canvas.width.toString(),\n        height: this.canvas.height.toString(),\n        preselects: {\n          name: defaultName,\n          action: 'download'\n        }\n      }\n    };\n\n    this.dialogManager.open('saveCanvas', args, (isConfirmed, outTObj) => {\n      if (!isConfirmed) return;\n\n      // allow the user to override the default name or if name is\n      // empty use the original default name\n      defaultName = outTObj.fields.name || defaultName;\n\n      const action = outTObj.fields.action;\n\n      if (action === 'download') {\n        this.handleDownloadSnapshot(defaultName);\n\n      } else if (action === 'wiki') {\n        utils.cp(tempImagePath, defaultName, true);\n        this.dispatchEvent({\n          type: 'tm-navigate', navigateTo: defaultName\n        });\n\n      } else if (action === 'placeholder') {\n        this.view.addPlaceholder(tempImagePath);\n\n      }\n\n      // in any case\n      $tw.wiki.deleteTiddler('$:/temp/tmap/snapshot');\n\n    });\n\n  }\n\n  handleDownloadSnapshot(title) {\n\n    const a = this.document.createElement('a');\n    const label = this.view.getLabel();\n    a.download = title || utils.getSnapshotTitle(label, 'png');\n    a.href = this.getSnapshot();\n\n    // we cannot simply call click() on <a>; chrome is cool with it but\n    // firefox requires us to create a mouse event…\n    const event = new MouseEvent('click');\n    a.dispatchEvent(event);\n\n  }\n\n  createAndSaveSnapshot(title) {\n\n    const tRef = title || this.view.getRoot() + '/snapshot';\n    $tw.wiki.addTiddler(new $tw.Tiddler({\n      title: tRef,\n      type: 'image/png',\n      text: this.getSnapshot(true),\n      modified: new Date()\n    }));\n\n    return tRef;\n\n  }\n\n  getSnapshot(stripPreamble) {\n\n    const data = this.canvas.toDataURL('image/png');\n\n    return (stripPreamble\n            ? utils.getWithoutPrefix(data, 'data:image/png;base64,')\n            : data);\n\n  }\n\n  handleDeleteView() {\n\n    const viewname = this.view.getLabel();\n\n    if (this.view.isLocked()) {\n      $tm.notify('Forbidden!');\n      return;\n    }\n\n    // regex is non-greedy\n\n    const references = this.view.getOccurrences();\n    if (references.length) {\n\n      const fields = {\n        count : references.length.toString(),\n        filter : utils.joinAndWrap(references, '[[', ']]')\n      };\n\n      this.dialogManager.open('cannotDeleteViewDialog', fields);\n\n      return;\n\n    }\n\n    const message = `\n        You are about to delete the view ''${viewname}''\n        (no tiddler currently references this view).\n     `;\n\n    this.openStandardConfirmDialog((isConfirmed) => { // TODO: this dialog needs an update\n\n      if (!isConfirmed) {\n        return;\n      }\n\n      this.view.destroy();\n      this.setView($tm.misc.defaultViewLabel);\n      const msg = `view \"${viewname}' deleted`;\n      this.logger('debug', msg);\n      $tm.notify(msg);\n\n\n    }, message);\n\n  }\n\n  /**\n   * This will rebuild the graph after a trigger has been activated.\n   *\n   * Prior to TiddlyMap v0.9, an additional check was performed\n   * to verify, if the graph had actually changed before rebuilding\n   * the graph. This check, however, was an overkill and as such removed.\n   */\n  handleTriggeredRefresh(trigger) {\n\n    this.logger('log', trigger, 'Triggered a refresh');\n\n    // special case for the live tab\n    if (this.id === 'live_tab') {\n      const curTiddler = utils.getTiddler(utils.getText(trigger));\n      if (curTiddler) {\n        const view = (curTiddler.fields['tmap.open-view'] || $tm.config.sys.liveTab.fallbackView);\n        if (view && view !== this.view.getLabel()) {\n          this.setView(view);\n          return;\n        }\n      }\n    }\n\n    this.rebuildGraph({\n      resetFocus: {\n        delay: 1000,\n        duration: 1000\n      },\n    });\n\n  }\n\n  /**\n   * Called by vis when the user tries to delete nodes or edges.\n   * The action is delegated to subhandlers.\n   *\n   * @param {Array<Id>} nodes - Removed edges.\n   * @param {Array<Id>} edges - Removed nodes.\n   */\n  handleRemoveElements({ nodes, edges }) {\n\n    if (nodes.length) {\n      // the adapter also removes edges when nodes are removed.\n      this.handleRemoveNodes(nodes);\n\n    } else if (edges.length) {\n      this.handleRemoveEdges(edges);\n\n    }\n\n    this.resetVisManipulationBar();\n\n\n  }\n\n  handleRemoveEdges(edgeIds) {\n\n    $tm.adapter.deleteEdges(this.graphData.edges.get(edgeIds));\n    $tm.notify('edge' + (edgeIds.length > 1 ? 's' : '') + ' removed');\n\n  }\n\n\n  /**\n   * Handler that guides the user through the process of deleting a node\n   * from the graph. The nodes may be removed from the filter (if possible)\n   * or from the system.\n   *\n   * This action represents a direct graph manipulation by the user,\n   * which means it will prevent a graph fitting (viewport adjusting)\n   * in the course of the next rebuild.\n   */\n  handleRemoveNodes(nodeIds) {\n\n    const tiddlers = $tm.adapter.getTiddlersByIds(nodeIds);\n    const params = {\n      'count': nodeIds.length.toString(),\n      'tiddlers': $tw.utils.stringifyList(tiddlers),\n      dialog: {\n        preselects: {\n          'delete-from': 'filter'\n        }\n      }\n    };\n\n    this.dialogManager.open('deleteNodeDialog', params, (isConfirmed, outTObj) => {\n\n      if (!isConfirmed) return;\n\n      let deletionCount = 0;\n\n      if (outTObj.fields['delete-from'] === 'system') {\n\n        // will also delete edges\n        $tm.adapter.deleteNodes(nodeIds);\n        deletionCount = nodeIds.length; // we just say so ;)\n\n      } else {\n\n        for (let i = nodeIds.length; i--;) {\n          const success = this.view.removeNode(nodeIds[i]);\n          if (success) {\n            deletionCount++;\n          }\n        }\n\n      }\n\n      $tm.notify(`\n        Removed ${deletionCount}\n        of ${nodeIds.length}\n        from ${outTObj.fields['delete-from']}\n      `);\n\n    });\n\n  }\n\n  /**\n   * Calling this function will toggle the enlargement of the map\n   * instance. Markers need to be added at various places to ensure the\n   * map stretches properly. This includes marking ancestor dom nodes\n   * to be able to shift the stacking context.\n   *\n   * @param {string} type - either 'halfscreen' or 'fullscreen'.\n   */\n\n  toggleEnlargedMode(type) {\n\n    if (!this.isInSidebar && type === 'halfscreen') {\n      return;\n    }\n\n    this.logger('log', 'Toggled graph enlargement');\n\n    const enlargedMode = this.enlargedMode;\n\n    // in any case, exit enlarged mode if active\n    if (enlargedMode) {\n\n      // reset click to use\n      this.network.setOptions({ clickToUse: this.clickToUse });\n\n      // remove markers\n      utils.findAndRemoveClassNames([\n        `tmap-has-${enlargedMode}-widget`,\n        `tmap-${enlargedMode}`\n      ]);\n\n      // reset flag\n      this.enlargedMode = null;\n      document.body.scrollTop = this.scrollTop;\n    }\n\n    if (!enlargedMode\n       || (enlargedMode !== type\n           && (type === 'fullscreen'\n               || (type === 'halfscreen' && !this.isInSidebar)))) {\n\n      this.scrollTop = document.body.scrollTop;\n\n      this.enlargedMode = type;\n\n      const pContainer = (this.isInSidebar\n                        ? this.sidebar\n                        : utils.getFirstElementByClassName('tc-story-river'));\n\n      $tw.utils.addClass(this.document.body, `tmap-has-${type}-widget`);\n      $tw.utils.addClass(pContainer, `tmap-has-${type}-widget`);\n      $tw.utils.addClass(this.domNode, `tmap-${type}`);\n\n      // disable click to use by force\n      this.network.setOptions({ clickToUse: false });\n\n      $tm.notify(`Toggled ${type} mode`);\n\n    }\n\n    // always do resize\n    this.handleResizeEvent();\n\n  }\n\n  handleGenerateWidget(event) {\n\n    $tw.rootWidget.dispatchEvent({\n      type: 'tmap:tm-generate-widget',\n      paramObject: { view: this.view.getLabel() }\n    });\n\n  }\n\n  handleSetCentralTopic({ paramObject }) {\n\n    let nodeId = paramObject.id || this.network.getSelectedNodes()[0];\n\n    if (nodeId === this.view.getConfig('central-topic')) {\n      nodeId = '';\n    }\n\n    this.view.setCentralTopic(nodeId);\n\n  }\n\n  handleStorePositions(withNotify) {\n\n    const data = this.view.getNodeData();\n    const positions = this.network.getPositions();\n\n    for (let id in positions) {\n\n      data[id] = data[id] || {};\n      data[id].x = positions[id].x;\n      data[id].y = positions[id].y;\n\n    }\n\n    this.view.saveNodeData(data);\n    this.ignoreNextViewModification = true;\n\n    if (withNotify) {\n      $tm.notify('positions stored');\n    }\n\n  }\n\n  /**\n   * Called by vis when the graph has stabilized itself.\n   *\n   * ATTENTION: never store positions in a view's map during stabilize\n   * as this will affect other graphs positions and will cause recursion!\n   * Storing positions inside vis' nodes is fine though\n   */\n  handleVisStabilizedEvent(properties) {\n\n    if (this.hasNetworkStabilized) {\n      return;\n    }\n\n    this.hasNetworkStabilized = true;\n    this.logger('log', 'Network stabilized after', properties.iterations, 'iterations');\n\n    if (!this.view.isEnabled('physics_mode')) { // static mode\n\n      // store positions if new nodes without position were added\n      const nodes = this.graphData.nodesById;\n      const idsOfNodesWithoutPosition = [];\n\n      for (let id in nodes) {\n        if (!nodes[id].x) {\n          idsOfNodesWithoutPosition.push(id);\n        }\n      }\n\n      if (idsOfNodesWithoutPosition.length) {\n        this.setNodesMoveable(idsOfNodesWithoutPosition, false);\n        $tm.notify(`${idsOfNodesWithoutPosition.length} nodes were added to the graph`);\n      }\n\n      // after storing positions, set gravity to zero again\n      const physics = this.visOptions.physics;\n      physics[physics.solver].centralGravity = 0;\n      this.network.setOptions(this.visOptions);\n\n    }\n\n    if (this.resetFocus) {\n      this.fitGraph(this.resetFocus.delay, this.resetFocus.duration);\n      this.resetFocus = null;\n    }\n\n  }\n\n  /**\n   * Zooms on a specific node in the graph\n   */\n  handleFocusNode({ param: tRef }) {\n\n    this.network.focus($tm.adapter.getId(tRef), {\n      scale: 1.5,\n      animation: true\n    });\n\n  }\n\n  /**\n   * A zombie widget is a widget that is removed from the dom tree\n   * but still referenced or still partly executed -- I mean\n   * otherwise you couldn't call this function, right?\n   *\n   * If TiddlyMap is executed in a fake environment, the function\n   * always returns true.\n   */\n  isZombieWidget() {\n\n    return this.domNode.isTiddlyWikiFakeDom === true\n           || !this.document.body.contains(this.getContainer());\n\n  }\n\n  /**\n   * This method allows us to specify after what time and for how long\n   * the zoom-to-fit process should be executed for a graph.\n   *\n   * @param {number} [delay=0] - How long to wait before starting to zoom.\n   * @param {number} [duration=0] - After the delay, how long should it\n   *     take for the graph to be zoomed.\n   */\n  fitGraph(delay = 0, duration = 0) {\n\n    // clear any existing fitting attempt\n    window.clearTimeout(this.activeFitTimeout);\n\n    const fit = () => {\n\n      // happens when widget is removed after stabilize but before fit\n      if (this.isZombieWidget()) return;\n\n      // fixes #97\n      this.network.redraw();\n\n      this.network.fit({ // v4: formerly zoomExtent\n        animation: {\n          duration: duration,\n          easingFunction: 'easeOutQuart'\n        }\n      });\n\n    };\n\n    this.activeFitTimeout = window.setTimeout(fit, delay);\n\n  }\n\n  /**\n   * Spawns a dialog in which the user can specify node attributes.\n   * Once the dialog is closed, the node is inserted into the current\n   * view, unless the operation was cancelled.\n   */\n  handleInsertNode(node) {\n\n    this.dialogManager.open('addNodeToMap', {}, (isConfirmed, outTObj) => {\n\n      if (!isConfirmed) {\n        return;\n      }\n\n      const tRef = utils.getField(outTObj, 'draft.title');\n\n      if (utils.tiddlerExists(tRef)) {\n\n        // Todo: use graphData and test if node is match (!=neighbour)\n        if (utils.isMatch(tRef, this.view.getNodeFilter('compiled'))) {\n\n          $tm.notify('Node already exists');\n          return;\n\n        } else {\n\n          node = $tm.adapter.makeNode(tRef, node);\n          this.view.addNode(node);\n\n        }\n\n      } else {\n\n        const tObj = new $tw.Tiddler(outTObj, { 'draft.title': null });\n\n        node.label = tRef;\n        $tm.adapter.insertNode(node, this.view, tObj);\n\n      }\n\n    });\n\n  }\n\n  /**\n   * Open the node editor to style the node.\n   */\n  handleEditNode(node) {\n\n    const tRef = $tm.tracker.getTiddlerById(node.id);\n    const tObj = utils.getTiddler(tRef);\n    const globalDefaults = JSON.stringify($tm.config.vis);\n    const localDefaults = this.view.getConfig('vis');\n    const nodes = {};\n    nodes[node.id] = node;\n    const nodeStylesByTRef = $tm.adapter.getInheritedNodeStyles(nodes);\n    const groupStyles = JSON.stringify(nodeStylesByTRef[tRef]);\n    const globalNodeStyle = JSON.stringify(utils.merge(\n                            {},\n                            { color: tObj.fields['color'] },\n                            utils.parseJSON(tObj.fields['tmap.style'])));\n\n    const viewLabel = this.view.getLabel();\n\n    // we do not used the cashed version since we need a new object!\n    const nodeData = this.view.getNodeData(node.id, true) || {};\n    // we need to delete the positions so they are not reset when a user\n    // resets the style…\n    delete nodeData.x;\n    delete nodeData.y;\n\n    const args = {\n      'view': viewLabel,\n      'tiddler': tObj.fields.title,\n      'tidColor': tObj.fields['color'],\n      'tidIcon': tObj.fields[$tm.field.nodeIcon] || tObj.fields['tmap.fa-icon'],\n      'tidLabelField': `global.${$tm.field.nodeLabel}`,\n      'tidIconField': `global.${$tm.field.nodeIcon}`,\n      dialog: {\n        preselects: {\n          'inherited-global-default-style': globalDefaults,\n          'inherited-local-default-style': localDefaults,\n          'inherited-group-styles': groupStyles,\n          'global.tmap.style': globalNodeStyle,\n          'local-node-style': JSON.stringify(nodeData)\n        }\n      }\n    };\n\n    // function to iterate over attributes that shall be available\n    // in the dialog.\n    const addToPreselects = (scope, store, keys) => {\n      for (let i = keys.length; i--;) {\n        args.dialog.preselects[scope + '.' + keys[i]] = store[keys[i]] || '';\n      }\n    };\n\n    // local values are retrieved from the view's node data store\n    addToPreselects('local', nodeData, [\n      'label', 'tw-icon', 'fa-icon', 'open-view'\n    ]);\n\n    // global values are taken from the tiddler's field object\n    addToPreselects('global', tObj.fields, [\n      $tm.field.nodeLabel,\n      $tm.field.nodeIcon,\n      'tmap.fa-icon',\n      'tmap.open-view'\n    ]);\n\n    this.dialogManager.open('editNode', args, (isConfirmed, outTObj) => {\n\n      if (!isConfirmed) return;\n\n      const fields = outTObj.fields;\n\n      // save or remove global individual style\n      const global = utils.getPropertiesByPrefix(fields, 'global.', true);\n      for (let p in global) {\n\n        utils.setField(tRef, p, global[p] || undefined);\n      }\n\n      // save local individual data (style + config)\n      const local = utils.getPropertiesByPrefix(fields, 'local.', true);\n\n      // CAREFUL: Never change 'local-node-style' to 'local.node-style'\n      // (with a dot) because it will get included in the loop!\n      const data = utils.parseJSON(fields['local-node-style'], {});\n\n      for (let p in local) {\n        data[p] = local[p] || undefined;\n      }\n\n      this.view.saveNodeStyle(node.id, data);\n\n    });\n\n  }\n\n  /**\n   * This handler is registered at and called by the vis network event\n   * system.\n   */\n  handleVisSingleClickEvent(properties) {\n\n    const isActivated = utils.isTrue($tm.config.sys.singleClickMode);\n    if (isActivated && !this.editorMode) {\n      this.handleOpenMapElementEvent(properties);\n    }\n\n  }\n\n  /**\n   * This handler is registered at and called by the vis network event\n   * system.\n   *\n   * @see Coordinates not passed on click/tap events within the properties object\n   * @see https://github.com/almende/vis/issues/440\n   *\n   * @properties a list of nodes and/or edges that correspond to the\n   * click event.\n   */\n  handleVisDoubleClickEvent(properties) {\n\n    if (properties.nodes.length || properties.edges.length) {\n\n      if (this.editorMode\n         || !utils.isTrue($tm.config.sys.singleClickMode)) {\n        this.handleOpenMapElementEvent(properties);\n      }\n\n\n    } else { // = clicked on an empty spot\n      if (this.editorMode) {\n        this.handleInsertNode(properties.pointer.canvas);\n      }\n    }\n\n  }\n\n  handleOpenMapElementEvent({ nodes, edges }) {\n\n    if (nodes.length) { // clicked on a node\n\n      const node = this.graphData.nodesById[nodes[0]];\n      if (node['open-view']) {\n        $tm.notify('Switching view');\n        this.setView(node['open-view']);\n      } else {\n        this.openTiddlerWithId(nodes[0]);\n      }\n\n    } else if (edges.length) { // clicked on an edge\n\n      this.logger('debug', 'Clicked on an Edge');\n      const typeId = this.graphData.edgesById[edges[0]].type;\n      this.handleEditEdgeType(typeId);\n\n    } else {\n\n      return;\n\n    }\n\n    this.hidePopups(0, true);\n\n  }\n\n  handleEditEdgeType(type) {\n\n    if (!this.editorMode) return;\n\n    const behaviour = $tm.config.sys.edgeClickBehaviour;\n    if (behaviour !== 'manager') return;\n\n    $tw.rootWidget.dispatchEvent({\n      type: 'tmap:tm-manage-edge-types',\n      paramObject: {\n        type: type\n      }\n    });\n\n  };\n\n  /**\n   * Listener will be removed if the parent is not part of the dom anymore\n   *\n   * @see https://groups.google.com/d/topic/tiddlywikidev/yuQB1KwlKx8/discussion [TW5] Is there a destructor for widgets?\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\n   */\n  handleResizeEvent(event) {\n\n    if (this.isZombieWidget()) return;\n\n    let height = this.getAttr('height');\n    let width = this.getAttr('width');\n\n    if (this.isInSidebar) {\n\n      const rect = this.domNode.getBoundingClientRect();\n      const distRight = 15;\n      width = (document.body.clientWidth - rect.left - distRight) + 'px';\n\n      const distBottom = parseInt(this.getAttr('bottom-spacing')) || 15;\n      const calculatedHeight = window.innerHeight - rect.top;\n      height = (calculatedHeight - distBottom) + 'px';\n\n    }\n\n    this.domNode.style.height = height || '300px';\n    this.domNode.style.width = width;\n\n    this.repaintGraph(); // redraw graph\n\n  }\n\n  /**\n   * used to prevent nasty deletion as edges are not unselected when leaving vis\n   */\n  handleClickEvent(evt) {\n\n    if (this.isZombieWidget() || !this.network) return;\n\n    if (!this.graphDomNode.contains(evt.target)) { // clicked outside\n\n      const selected = this.network.getSelection();\n      if (selected.nodes.length || selected.edges.length) {\n        this.logger('debug', 'Clicked outside; deselecting nodes/edges');\n        // upstream bug: this.network.unselectAll() doesn't work\n        this.network.selectNodes([]); // deselect nodes and edges\n        this.resetVisManipulationBar();\n      }\n\n    } else {\n\n      this.canvas.focus();\n\n    }\n\n    this.contextMenu.hide(0, true);\n\n  }\n\n  handleVisSelectNode({ nodes }) {\n\n    // assign selected style\n    this.assignActiveStyle(nodes);\n\n  }\n\n  /**\n   * Assign some styles when the graph element becomes active, i.e.\n   * it is selected or hovered over.\n   *\n   * @param {Id|Array<Id>} nodeIds - A single id or an Array of ids.\n   */\n  assignActiveStyle(nodeIds) {\n\n    if (!Array.isArray(nodeIds)) nodeIds = [ nodeIds ];\n\n    const defaultColor = this.visOptions.nodes.color;\n\n    // iterate over selected nodes\n    for (let i = nodeIds.length; i--;) {\n      const id = nodeIds[i];\n      const node = this.graphData.nodesById[id];\n      const colorObj = utils.merge({}, defaultColor, node.color);\n      this.graphData.nodes.update({\n        id: id,\n        color: {\n          highlight: colorObj,\n          hover: colorObj\n        }\n      });\n    }\n\n  }\n\n  handleVisDeselectNode(properties) {\n\n    //~ var prevSelectedNodes = properties.previousSelection.nodes;\n    //~ for (var i = prevSelectedNodes.length; i--;) {\n    //~ };\n\n  }\n\n  /**\n   * Called by vis when the dragging of a node(s) has ended.\n   * Vis passes an object containing event-related information.\n   *\n   * @param {Array<Id>} nodes - Array of ids of the nodes\n   *     that were being dragged.\n   */\n  handleVisDragEnd({ nodes }) {\n\n    if (!nodes.length) {\n      return;\n    }\n\n    if (nodes.length === 1 && this.view.isEnabled('raster')) {\n      const pos = this.network.getPositions()[nodes[0]];\n      this.graphData.nodes.update({\n        id: nodes[0],\n        ...utils.getNearestRasterPosition(pos, parseInt(this.view.getConfig('raster'))),\n      });\n    }\n\n    // reset store\n    this.draggedNode = null;\n\n    // fix node again and store positions\n    // if in static mode, fixing will be ignored\n    this.setNodesMoveable(nodes, false);\n\n  }\n\n  /**\n   *\n   * @param context2d\n   */\n  handleVisBeforeDrawing(context2d) {\n\n    const { view, network, backgroundImage } = this;\n\n    if (backgroundImage) {\n      context2d.drawImage(backgroundImage, 0, 0);\n    }\n\n    if (view.isEnabled('raster')) {\n      utils.drawRaster(\n        context2d,\n        network.getScale(),\n        network.getViewPosition(),\n        parseInt(view.getConfig('raster'))\n      );\n    }\n\n  }\n\n  /**\n   *\n   * @param context2d\n   */\n  handleVisAfterDrawing(context2d) {\n\n    if (this.selectRect) {\n\n      const rect = this.selectRect.getRect();\n\n      context2d.beginPath();\n      context2d.globalAlpha = 0.5;\n      context2d.fillStyle = '#EAFFEF';\n      context2d.fillRect(...rect);\n\n      context2d.beginPath();\n      context2d.globalAlpha = 1;\n      context2d.strokeStyle = '#B4D9BD';\n      context2d.strokeRect(...rect);\n\n    }\n\n    if (this.draggedNode && this.view.isEnabled('raster')) {\n\n      const pos = this.network.getPositions()[this.draggedNode];\n      const rPos = utils.getNearestRasterPosition(pos, parseInt(this.view.getConfig('raster')));\n\n      context2d.strokeStyle = 'green';\n      context2d.fillStyle = 'green';\n\n      context2d.beginPath();\n      context2d.moveTo(pos.x, pos.y);\n      context2d.lineTo(rPos.x, rPos.y);\n      context2d.stroke();\n      context2d.beginPath();\n      context2d.arc(rPos.x, rPos.y, 5, 0, Math.PI * 2);\n      context2d.fill();\n\n    }\n\n  }\n\n  /**\n   * called by tooltip class when tooltip is displayed;\n   */\n  constructTooltip(signature, div) {\n\n    const ev = utils.parseJSON(signature);\n    const id = ev.node || ev.edge;\n\n    let text = null;\n    const outType = 'text/html';\n    const inType = 'text/vnd-tiddlywiki';\n\n    if (ev.node) { // node\n\n      const tRef = $tm.tracker.getTiddlerById(id);\n      const tObj = utils.getTiddler(tRef);\n\n      const descr = tObj.fields[$tm.field.nodeInfo];\n\n      if (descr) {\n\n        div.innerHTML = $tw.wiki.renderText(outType, inType, descr);\n\n      } else if (tObj.fields.text) {\n\n        // simply rendering the text is not sufficient as this prevents\n        // us from updating the tooltip content on refresh. So we need\n        // to create a temporary widget that is registered to the dom\n        // node passed by the tooltip.\n\n        utils.registerTransclude(this, 'tooltipWidget', tRef);\n        this.tooltipWidget.setVariable('tv-tiddler-preview', 'yes');\n        this.tooltipWidget.render(div);\n\n      } else {\n\n        div.innerHTML = tRef;\n\n      }\n\n    } else { // edge\n\n      const edge = this.graphData.edgesById[id];\n      const type = $tm.indeces.allETy[edge.type];\n\n      if (type.description) {\n        text = $tw.wiki.renderText(outType, inType, type.description);\n      }\n\n      div.innerHTML = (text || type.label || type.id);\n\n    }\n\n  }\n\n  handleVisHoverElement(ev) {\n\n    if ($tm.mouse.buttons) return;\n\n    //~ this.graphDomNode.style.cursor = 'pointer';\n\n    const id = ev.node || ev.edge;\n    const signature = JSON.stringify(ev);\n\n    if (ev.node) {\n\n      // override the hover color\n      this.assignActiveStyle(id);\n\n    }\n\n    // show tooltip if not in edit mode\n    if (!this.isVisInEditMode() && !this.contextMenu.isShown()) {\n      const populator = this.constructTooltip;\n      this.tooltip.show(signature, populator);\n    }\n\n  }\n\n  handleVisBlurElement(ev) {\n\n    this.tooltip.hide();\n\n  }\n\n  handleVisLoading({ total, iterations }) {\n\n    // we only start to show the progress bar after a while\n    //~ if (params.iterations / params.total < 0.05) return;\n\n    this.graphLoadingBarDomNode.style.display = 'block';\n    this.graphLoadingBarDomNode.setAttribute('max', total);\n    this.graphLoadingBarDomNode.setAttribute('value', iterations);\n\n    //~ var text = 'Loading ' + Math.round((iterations / total) * 100) + '%';\n    //~ this.graphLoadingBarDomNode.innerHTML = text;\n\n  }\n\n  handleVisLoadingDone(params) {\n\n    this.graphLoadingBarDomNode.style.display = 'none';\n\n  }\n\n   /**\n   * Called by vis when a node is being dragged.\n   * Vis passes an object containing event-related information.\n   * @param {Array<Id>} nodes - Array of ids of the nodes\n   *     that were being dragged.\n   */\n  handleVisDragStart({ nodes }) {\n\n    if (nodes.length) {\n\n      this.hidePopups(0, true);\n      this.assignActiveStyle(nodes);\n      this.setNodesMoveable(nodes, true);\n\n      if (nodes.length === 1) {\n        this.draggedNode = nodes[0];\n      }\n\n    }\n\n  }\n\n  /**\n   * called from outside.\n   */\n  destruct() {\n\n    // while the container should be destroyed and the listeners\n    // garbage collected, we remove them manually just to be save\n\n    utils.setDomListeners('remove', window, this.windowDomListeners);\n    utils.setDomListeners('remove', this.domNode, this.widgetDomListeners);\n\n    this._destructVis();\n\n  }\n\n  /**\n   * Only destructs stuff related to vis.\n   */\n  _destructVis() {\n\n    if (!this.network) return;\n\n    utils.setDomListeners('remove', this.canvas, this.canvasDomListeners);\n\n    this.network.destroy();\n    this.network = null;\n\n  }\n\n  /**\n   * Opens the tiddler that corresponds to the given id either as\n   * modal (when in fullscreen mode) or in the story river.\n   */\n  openTiddlerWithId(id) {\n\n    const tRef = $tm.tracker.getTiddlerById(id)\n\n    this.logger('debug', 'Opening tiddler', tRef, 'with id', id);\n\n    if (this.enlargedMode === 'fullscreen') {\n\n      let draftTRef = $tw.wiki.findDraft(tRef);\n      const wasInDraftAlready = !!draftTRef;\n\n      if (!wasInDraftAlready) {\n\n        const type = 'tm-edit-tiddler';\n        this.dispatchEvent({ type: type, tiddlerTitle: tRef });\n        draftTRef = $tw.wiki.findDraft(tRef);\n\n      }\n\n      const args = { draftTRef, originalTRef: tRef };\n\n      this.dialogManager.open('fullscreenTiddlerEditor', args, (isConfirmed, outTObj) => {\n\n        if (isConfirmed) {\n\n          const type = 'tm-save-tiddler';\n          this.dispatchEvent({ type: type, tiddlerTitle: draftTRef });\n\n        } else if (!wasInDraftAlready) {\n\n          // also removes the draft from the river before deletion!\n          utils.deleteTiddlers([ draftTRef ]);\n\n        }\n\n        // in any case, remove the original tiddler from the river\n        const type = 'tm-close-tiddler';\n        this.dispatchEvent({ type: type, tiddlerTitle: tRef });\n\n      });\n\n    } else {\n\n      const bounds = this.domNode.getBoundingClientRect();\n\n      this.dispatchEvent({\n        type: 'tm-navigate',\n        navigateTo: tRef,\n        navigateFromTitle: this.getVariable('storyTiddler'),\n        navigateFromNode: this,\n        navigateFromClientRect: {\n          top: bounds.top,\n          left: bounds.left,\n          width: bounds.width,\n          right: bounds.right,\n          bottom: bounds.bottom,\n          height: bounds.height\n        }\n      });\n\n    }\n  }\n\n  /**\n   * The view holder is a tiddler that stores a references to the current\n   * view. If the graph is not bound to a view by the user via an\n   * attribute, the default view holder is used. Otherwise, a temporary\n   * holder is created whose value is set to the view specified by the user.\n   * This way, the graph is independent from view changes made in a\n   * tiddlymap editor.\n   *\n   * This function will only calculate a new reference to the holder\n   * on first call (that is when no view holder is registered to 'this'.\n   *\n   */\n  getViewHolderRef() {\n\n    // the viewholder is never recalculated once it exists\n    if (this.viewHolderRef) {\n      return this.viewHolderRef;\n    }\n\n    this.logger('info', 'Retrieving or generating the view holder reference');\n\n    // if given, try to retrieve the viewHolderRef by specified attribute\n    const viewName = this.getAttr('view');\n    let holderRef = null;\n\n    if (viewName) {\n\n      this.logger('log', `User wants to bind view \"${viewName}' to graph`);\n\n      const viewRef = `${$tm.path.views}/${viewName}`;\n\n      if ($tw.wiki.getTiddler(viewRef)) {\n\n        // create a view holder that is exclusive for this graph\n\n        holderRef = `${$tm.path.localHolders}/${utils.genUUID()}`;\n        this.logger('log', `Created an independent temporary view holder \"${holderRef}\"`);\n\n        // we do not use setView here because it would store and reload the view unnecessarily...\n        utils.setText(holderRef, viewRef);\n\n        this.logger('log', `View \"${viewRef}' inserted into independend holder`);\n\n      } else {\n        this.logger('log', `View \"${viewName}\" does not exist`);\n      }\n\n    }\n\n    if (!holderRef) {\n      this.logger('log', 'Using default (global) view holder');\n      holderRef = $tm.ref.defaultViewHolder;\n    }\n\n    return holderRef;\n\n  }\n\n  /**\n   * This function will switch the current view reference of the\n   * view holder.\n   *\n   * NOTE:\n   * The changes will be picked up in the next refresh cycle.\n   * This function will never update the view object currently\n   * held by this widget (this.view)! This would create a race\n   * condition where the view has changed, but the graph data hasn't\n   * and maybe a stabilization event fires in this moment. At this point\n   * it would work with graph data that doesn't relate to the view\n   * and do bad things, trust me, big time bad things.\n   *\n   * @param {ViewAbstraction|string} view – A reference to the view.\n   * @param {string} [viewHolderRef] – A reference to the view holder.\n   */\n  setView(view, viewHolderRef) {\n\n    view = new ViewAbstraction(view);\n\n    if (!view.exists()) {\n      return;\n    }\n\n    const viewLabel = view.getLabel();\n    viewHolderRef = viewHolderRef || this.viewHolderRef;\n    this.logger('info', `Inserting view \"${viewLabel}\" into holder \"${viewHolderRef}\"`);\n    $tw.wiki.addTiddler(new $tw.Tiddler({\n      title : viewHolderRef,\n      text : viewLabel\n    }));\n\n    // WARNING: Never set this.view to the new view state at this point.\n    // e.g. via `this.view = this.getView(true)` This would produce a\n    // race condition!\n\n  }\n\n  /**\n   * This function will return a view abstraction that is based on the\n   * view specified in the view holder of this graph.\n   *\n   * @param {boolean} noCache - Retrieve the view reference again\n   *     from the holder and recreate the view abstraction object.\n   * @return {ViewAbstraction} the view\n   */\n  getView(noCache) {\n\n    if (!noCache && this.view) {\n      return this.view;\n    }\n\n    const viewHolderRef = this.getViewHolderRef();\n\n    // transform into view object\n    const text = utils.getText(viewHolderRef);\n    let view = new ViewAbstraction(text);\n\n    this.logger('debug', 'Retrieved view from holder');\n\n    if (!view.exists()) {\n      this.logger('debug', `Warning: View \"${text}\" doesn't exist. Default is used instead.`);\n      view = new ViewAbstraction('Default');\n    }\n\n    return view;\n\n  }\n\n  reloadBackgroundImage(msg) {\n\n    this.backgroundImage = null;\n\n    const bgFieldValue = this.view.getConfig('background_image');\n    const imgTObj = utils.getTiddler(bgFieldValue);\n    if (!imgTObj && !bgFieldValue) return;\n\n    const img = new Image();\n    const ajaxCallback = function(b64) { img.src = b64; };\n    img.onload = () => {\n      // only now set the backgroundImage to the img object!\n      this.backgroundImage = img;\n      this.repaintGraph();\n      if (msg) {\n        $tm.notify(msg);\n      }\n    };\n\n    if (imgTObj) { // try loading from tiddler\n      const urlField = imgTObj.fields['_canonical_uri'];\n      if (urlField) { // try loading by uri field\n        utils.getImgFromWeb(urlField, ajaxCallback);\n      } else if (imgTObj.fields.text) { // try loading from base64\n        img.src = $tw.utils.makeDataUri(imgTObj.fields.text, imgTObj.fields.type);\n      }\n\n    } else if (bgFieldValue) { // try loading directly from reference\n      utils.getImgFromWeb(bgFieldValue, ajaxCallback);\n\n    }\n\n  }\n\n  /**\n   * The graph of this widget is only repainted if the following counts:\n   *\n   * The network object exists (prerequisit).\n   *\n   * 1. We are not in fullscreen at all\n   * 2. This particular graph instance is currently running fullscreen.\n   */\n  repaintGraph() {\n\n    const isInFS = $tw.utils.hasClass(this.document.body,\n                                    'tmap-has-fullscreen-widget');\n    if (this.network && (!isInFS || (isInFS && this.enlargedMode))) {\n\n      this.logger('info', 'Repainting the whole graph');\n\n      this.network.redraw();\n      this.fitGraph(0, 1000);\n\n    }\n\n  }\n\n  /**\n   * If a button is enabled it means it is displayed on the graph canvas.\n   *\n   * @param {string} name - The name of the button to enabled. Has to\n   *     correspond with the css button name.\n   * @param {boolean} enable - True if the button should be visible,\n   *     false otherwise.\n   */\n  setGraphButtonEnabled(name, enable) {\n\n    const className = `vis-button tmap-${name}`;\n    const b = utils.getFirstElementByClassName(className, this.domNode);\n    $tw.utils.toggleClass(b, 'tmap-button-enabled', enable);\n\n  }\n\n  /**\n   * Allow the given nodes to be moveable.\n   *\n   * @param {Array<number>} nodeIds - The ids of the nodes for which\n   *     we allow or disallow the movement.\n   * @param {boolean} isMoveable - True, if the nodes are allowed to\n   *     move or be moved.\n   */\n  setNodesMoveable(nodeIds, isMoveable) {\n\n    if (!nodeIds || !nodeIds.length || this.view.isEnabled('physics_mode')) {\n    // = no ids passed or in floating mode\n      return;\n    }\n\n    //~ this.network.storePositions();\n\n    const updates = [];\n    const isFixed = !isMoveable;\n    for (let i = nodeIds.length; i--;) {\n\n      updates.push({\n        id: nodeIds[i],\n        fixed: { x: isFixed, y: isFixed }\n      });\n\n    }\n\n    this.graphData.nodes.update(updates);\n\n    if (isFixed) {\n\n      this.logger('debug', 'Fixing', updates.length, 'nodes');\n\n      // if we fix nodes in static mode then we also store the positions\n      this.handleStorePositions();\n    }\n\n  }\n\n  /**\n   * This function will create the dom elements for all tiddlymap-vis\n   * buttons and register the event listeners.\n   *\n   * @param {Object<string, function>} buttonEvents - The label of the\n   *     button that is used as css class and the click handler.\n   */\n  addGraphButtons(buttonEvents) {\n\n    const parent = utils.getFirstElementByClassName('vis-navigation', this.domNode);\n\n    for (let name in buttonEvents) {\n      const div = this.document.createElement('div');\n      div.className = `vis-button tmap-${name}`;\n\n      div.addEventListener('click', buttonEvents[name].bind(this), false);\n      parent.appendChild(div);\n\n\n      this.setGraphButtonEnabled(name, true);\n\n    }\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport {\n  MapWidget as tmap,\n  MapWidget as tiddlymap, // legacy\n};\n"],"sourceRoot":"../../../../../../src/plugins"}