{"version":3,"sources":["felixhayashi/tiddlymap/js/services/Adapter.js"],"names":["_ViewAbstraction","require","_EdgeType","_NodeType","_utils","_Edge","_vis","_environment","env","_contrastcolour","Adapter","tracker","edgeTypeSubscriberRegistry","_classCallCheck","this","getTiddlerById","bind","getId","getIdByTiddler","assignId","indeces","$tm","wiki","$tw","visShapesWithTextInside","_utils2","default","getLookupTable","edge","_processEdge","edges","convert","i","length","deleteEdge","logger","action","fromTRef","from","tiddlerExists","tObj","getTiddler","type","allETy","_EdgeType2","handlers","getAllForType","fn","exists","save","groupBy","opts","arguments","undefined","start","tRefs","getMatches","selector","allPotentialNodes","getEdgesForSet","typeWL","adjList","groupByProperty","stop","matches","_this","toWL","steps","visited","getArrayValuesAsHashmapKeys","_ViewAbstraction2","view","allEdgesLeadingToNeighbours","makeHashMap","allNeighbours","maxSteps","parseInt","direction","getConfig","isWalkBoth","isWalkIn","isWalkOut","getAdjacencyList","addAsNeighbour","role","neighboursOfThisStep","id","tRef","node","makeNode","addProperties","push","step","isSystemOrDraft","getEdges","t","toArrow","invertedArrow","outgoing","incoming","j","neighbourhood","_ref","filter","edgeTypeWL","neighbourhoodScope","getNodeFilter","neighScope","getEdgeTypeFilter","graph","nodes","outputType","neighbours","getNeighbours","Object","assign","isEnabled","nodeTRefs","getTiddlersByIds","removeObsoleteViewData","attachStylesToNodes","tiddler","group","eTySubscribers","getAll","l","loadEdges","tiddlers","_defineProperty","getAllPotentialNodes","_ref2","newName","selectEdgesByType","addStyleToEdge","newType","load","deleteTiddler","fullPath","_ref3","result","keys","nodeIds","options","selectNodesByReferences","selectNodesByIds","_NodeType2","protoNode","merge","nodeLabel","label","field","fields","title","src","protoByTRef","glNTy","inheritors","getInheritors","proto","style","inheritedStyles","getInheritedNodeStyles","viewNodeData","getNodeData","isStaticMode","twIcon","faIcon","color","parseJSON","fixed","x","isColorObject","background","border","addNodeIcon","font","shape","run","icon","glNTyById","_typeof","deleteTiddlers","viewRefs","allViews","removeNode","deleteEdges","deleteNode","ids","positions","saveNodeData","protoTiddler","getRandomLabel","Tiddler","text","tmap.id","getModificationFields","getCreationFields","addTiddler","addNode","Array","isArray","_vis2","DataSet","getFAdigits","str","substr","face","code","String","fromCharCode","imgTObj","generateNewTitle","getDataUri","data","obsoleteDataItems","getLabel","isTrue"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/services/Adapter.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Adapter\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport ViewAbstraction              from '$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction';\nimport EdgeType                     from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport NodeType                     from '$:/plugins/felixhayashi/tiddlymap/js/NodeType';\nimport utils                        from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport Edge                         from '$:/plugins/felixhayashi/tiddlymap/js/Edge';\nimport vis                          from '$:/plugins/felixhayashi/vis/vis.js';\nimport * as env                     from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\nimport { run as getContrastColour } from '$:/core/modules/macros/contrastcolour.js';\n\n/***************************** CODE ********************************/\n\n/**\n * This library acts as an abstraction layer above the tiddlywiki\n * system. All the provided methods give the api-user the chance\n * to interact with tiddlywiki as if it was a simple graph database.\n *\n * Everything that is related to retrieving or inserting nodes and\n * edges is handled by the adapter class.\n *\n * You don't need to create your own instance of this class.\n * The adapter service may be accessed from anywhere using\n * `$tm.apapter`.\n *\n * @constructor\n */\nclass Adapter {\n\n  /**\n   * @param {Tracker} tracker\n   * @param {EdgeTypeSubscriberRegistry} edgeTypeSubscriberRegistry\n   */\n  constructor(tracker, edgeTypeSubscriberRegistry) {\n\n    this.getTiddlerById = tracker.getTiddlerById.bind(tracker);\n    this.getId = tracker.getIdByTiddler.bind(tracker);\n    this.assignId = tracker.assignId.bind(tracker);\n\n    this.edgeTypeSubscriberRegistry = edgeTypeSubscriberRegistry;\n\n    this.indeces = $tm.indeces;\n    this.wiki = $tw.wiki;\n\n    this.visShapesWithTextInside = utils.getLookupTable([\n      'ellipse', 'circle', 'database', 'box', 'text'\n    ]);\n\n  }\n\n  /**\n   * This function will delete the specified edge object from the system.\n   *\n   * @param {Edge} edge - The edge to be deleted. The edge necessarily\n   *     needs to possess an `id` and a `from` property.\n   * @return {Edge} The deleted edge is returned.\n   */\n  deleteEdge(edge) {\n\n    return this._processEdge(edge, 'delete');\n\n  }\n\n  /**\n   * Persists an edge by storing the vector (from, to, type).\n   *\n   * @param {Edge} edge - The edge to be saved. The edge necessarily\n   *     needs to possess a `to` and a `from` property.\n   * @return {Edge} The newly inserted edge.\n   */\n  insertEdge(edge) {\n\n    return this._processEdge(edge, 'insert');\n\n  }\n\n  /**\n   * Removes multiple edges from several stores.\n   *\n   * @param {EdgeCollection} edges - The edges to be deleted.\n   */\n  deleteEdges(edges) {\n\n    edges = utils.convert(edges, 'array');\n    for (let i = edges.length; i--;) {\n      this.deleteEdge(edges[i]);\n    }\n\n  }\n\n  /**\n   * Private function to handle the insertion or deletion of an edge.\n   * It prepares the process according to the action type and delegates\n   * the task to more specific functions.\n   *\n   * @private\n   * @return {Edge} The processed edge.\n   */\n  _processEdge(edge, action) {\n\n    $tm.logger('debug', 'Edge', action, edge);\n\n    // get from-node and corresponding tiddler\n    const fromTRef = this.getTiddlerById(edge.from);\n\n    if (!fromTRef || !utils.tiddlerExists(fromTRef)) {\n      return;\n    }\n\n    const tObj = utils.getTiddler(fromTRef);\n    const type = this.indeces.allETy[edge.type] || new EdgeType(edge.type);\n    const handlers = this.edgeTypeSubscriberRegistry.getAllForType(type);\n    const fn = `${action}Edge`;\n\n    for (let i = handlers.length; i--;) {\n      (handlers[i][fn])(tObj, edge, type);\n    }\n\n    // if type didn't exist yet, create it\n    if (action === 'insert' && !type.exists()) {\n      type.save();\n    }\n\n    return edge;\n\n  }\n\n  /**\n   * This function will return an adjacency list for the nodes\n   * present in the current system. The list may be restricted by\n   * optional filters.\n   *\n   * @param {string} [groupBy='to'] - Specifies by which property the\n   *     adjacency list is indexed. May be either 'from' or 'to'.\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edge-types are included.\n   * @param {Hashmap} [opts.edges] - A set of edges on which basis\n   *     the adjacency list is build. If not provided,\n   *     all edges in the system are considered.\n   * @return {Object<Id, Array<Edge>>} For each key (a node id) an\n   *     array of edges pointing 'from' (or 'to'; depends on `groupBy`)\n   *     is supplied as value.\n   */\n  getAdjacencyList(groupBy, opts = {}) {\n\n    $tm.start('Creating adjacency list');\n\n    if (!opts.edges) {\n      const tRefs = utils.getMatches(env.selector.allPotentialNodes);\n      opts.edges = this.getEdgesForSet(tRefs, opts.toWL, opts.typeWL);\n    }\n\n    const adjList = utils.groupByProperty(opts.edges, groupBy || 'to');\n\n    $tm.stop('Creating adjacency list');\n\n    return adjList;\n\n  }\n\n  /**\n   * This function will return all neighbours of a graph denoted by\n   * a set of tiddlers.\n   *\n   * @todo parts of this code may be outsourced into a function to\n   * prevent repeating code.\n   *\n   * @param {Array<TiddlerReference>} matches - The original set that\n   *     defines the starting point for the neighbourhood discovery\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edges are travelled to reach a neighbour.\n   * @param {Hashmap} [opts.edges] - An initial set of edges that is\n   *    used in the first step to reach immediate neighbours, if no\n   *    set of edges is specified, all exsisting edges will be considered.\n   * @param {number} [opts.steps] - An integer value that specifies\n   *    the scope of the neighbourhood. A node is considered a neighbour\n   *    if it can be reached within the given number of steps starting\n   *    from original set of tiddlers returned by the node filter.\n   * @param {Hashmap} [opts.addProperties] - a hashmap\n   *     containing properties to be added to each node.\n   *     For example:\n   *     {\n   *       group: 'g1',\n   *       color: 'red'\n   *     }\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all neighbouring nodes* },\n   *       edges: { *all edges connected to neighbours* },\n   *     }\n   */\n  getNeighbours(matches, opts = {}) {\n\n    $tm.start('Get neighbours');\n\n    const { addProperties, toWL, typeWL, steps } = opts;\n    const { allETy } = this.indeces;\n\n    // index of all tiddlers have already are been visited, either by\n    // having been included in the original set, or by having been\n    // recorded as neighbour during the discovery.\n    const visited = utils.getArrayValuesAsHashmapKeys(matches);\n    const view = new ViewAbstraction(opts.view);\n    const allEdgesLeadingToNeighbours = utils.makeHashMap();\n    const allNeighbours = utils.makeHashMap();\n    const maxSteps = (parseInt(steps) > 0 ? steps : 1);\n    const direction = (opts.direction || (view.exists() && view.getConfig('neighbourhood_directions')));\n    const isWalkBoth = (!direction || direction === 'both');\n    const isWalkIn = (isWalkBoth || direction === 'in');\n    const isWalkOut = (isWalkBoth || direction === 'out');\n\n    // adjacency receives whitelists through opts\n    const adjList = this.getAdjacencyList('to', opts);\n\n    const addAsNeighbour = (edge, role, neighboursOfThisStep) => {\n      allEdgesLeadingToNeighbours[edge.id] = edge;\n      const tRef = this.getTiddlerById(edge[role]);\n      if (!visited[tRef]) {\n        visited[tRef] = true;\n        const node = this.makeNode(tRef, addProperties);\n        if (node) { // saveguard against obsolete edges or other problems\n          // record node\n          allNeighbours[node.id] = node;\n          neighboursOfThisStep.push(tRef);\n        }\n      }\n    };\n\n    // needed later\n    let step;\n\n    // loop if still steps to be taken and we have a non-empty starting set\n    for (step = 0; step < maxSteps && matches.length; step++) {\n\n      // neighbours that are discovered in the current step;\n      // starting off from the current set of matches;\n      const neighboursOfThisStep = [];\n\n      // loop over all nodes in the original set\n      for (let i = matches.length; i--;) {\n\n        if (utils.isSystemOrDraft(matches[i])) {\n          // = this might happen if the user manually created edges\n          // that link to a system/draft tiddler or if the original\n          // set contained system/draft tiddlers.\n          continue;\n        }\n\n        // get all outgoing edges\n        // = edges originating from the starting set and point outwards\n        const outgoing = this.getEdges(matches[i], toWL, typeWL);\n        for (let id in outgoing) {\n\n          const t = allETy[outgoing[id].type];\n          if (isWalkBoth || isWalkOut && t.toArrow || isWalkIn && t.invertedArrow) {\n\n            addAsNeighbour(outgoing[id], 'to', neighboursOfThisStep);\n          }\n        }\n\n        // get all incoming edges\n        // = edges originating from outside pointing to the starting set\n        const incoming = adjList[this.getId(matches[i])];\n        if (!incoming) {\n          continue;\n        }\n\n        for (let j = incoming.length; j--;) {\n          const t = allETy[incoming[j].type];\n          if (isWalkBoth || isWalkIn && t.toArrow || isWalkOut && t.invertedArrow) {\n            addAsNeighbour(incoming[j], 'from', neighboursOfThisStep);\n          }\n        }\n      }\n\n      // the current set of newly discovered neighbours forms the\n      // starting point for the next discovery\n      matches = neighboursOfThisStep;\n\n    }\n\n    const neighbourhood = {\n      nodes: allNeighbours,\n      edges: allEdgesLeadingToNeighbours\n    };\n\n    $tm.logger('debug', 'Retrieved neighbourhood', neighbourhood, 'steps', step);\n\n    $tm.stop('Get neighbours');\n\n    return neighbourhood;\n\n  }\n\n  /**\n   * This function will assemble a graph object based on the supplied\n   * node and edge filters. Optionally, a neighbourhood may be\n   * merged into the graph neighbourhood.\n   *\n   * @param {string|ViewAbstraction} [view] - The view in which\n   *     the graph will be displayed.\n   * @param {string|ViewAbstraction} [filter] - If supplied,\n   *     this will act as node filter that defines which nodes\n   *     are to be displayed in the graph; a possible view node filter\n   *     would be ignored.\n   * @param {Hashmap} [edgeTypeWL] - A whitelist lookup-table\n   *     that restricts which edges are travelled to reach a neighbour.\n   * @param {number} [neighbourhoodScope] - An integer value that\n   *     specifies the scope of the neighbourhood in steps.\n   *     See {@link Adapter#getNeighbours}\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all nodes in the graph* },\n   *       edges: { *all edges in the graph* },\n   *     }\n   *     Neighbours will be receive the 'tmap:neighbour' type.\n   */\n  getGraph({ view, filter, edgeTypeWL, neighbourhoodScope } = {}) {\n\n    $tm.start('Assembling Graph');\n\n    view = new ViewAbstraction(view);\n    const matches = utils.getMatches(filter || (view.exists() && view.getNodeFilter('compiled')));\n    const neighScope = parseInt(neighbourhoodScope || (view.exists() && view.getConfig('neighbourhood_scope')));\n    const typeWL = (edgeTypeWL || (view.exists() && view.getEdgeTypeFilter('whitelist')));\n    const toWL = utils.getArrayValuesAsHashmapKeys(matches);\n\n    const graph = {\n      edges: this.getEdgesForSet(matches, toWL, typeWL),\n      nodes: this.selectNodesByReferences(matches, {\n        view: view,\n        outputType: 'hashmap'\n      })\n    };\n\n    if (neighScope) {\n      const neighbours = this.getNeighbours(matches, {\n        steps: neighScope,\n        view: view,\n        typeWL: typeWL,\n        addProperties: {\n          group: 'tmap:neighbour'\n        }\n      });\n\n      // add neighbours (nodes and edges) to graph\n      Object.assign(graph.nodes, neighbours.nodes);\n      Object.assign(graph.edges, neighbours.edges);\n\n      if (view.exists() && view.isEnabled('show_inter_neighbour_edges')) {\n        const nodeTRefs = this.getTiddlersByIds(neighbours.nodes);\n        // this time we need a whitelist based on the nodeTRefs\n        const toWL = utils.getArrayValuesAsHashmapKeys(nodeTRefs);\n        Object.assign(graph.edges, this.getEdgesForSet(nodeTRefs, toWL));\n      }\n    }\n\n    // this is pure maintainance!\n    removeObsoleteViewData(graph.nodes, view);\n\n    // add styles to nodes\n    this.attachStylesToNodes(graph.nodes, view);\n\n    $tm.stop('Assembling Graph');\n\n    $tm.logger('debug', 'Assembled graph:', graph);\n\n    return graph;\n\n  }\n\n  /**\n   * Returns all edges stored in a given tiddler. Any edge stored in a\n   * tiddler is orginally an outgoing edge. Depending on how the user\n   * changes the arrow head (by manipulating the Visjs edge-type style),\n   * the edge may change its orientation and become an incoming edge or\n   * bi-directional. Therefore, the edges retrieved may be incoming,\n   * outgoing or both!\n   *\n   * Returned edges may be of the following type:\n   *\n   * - Edges stored in the tiddler text (=links).\n   * - Edges stored in fields denoted by magic edge-types.\n   * - TiddlyMap edges stored in a json format\n   *\n   * @param {Tiddler} tiddler - A tiddler reference or object from\n   *     which to retrieve the edges.\n   * @param {Hashmap<TiddlerReference, boolean>} [toWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge that leads to a certain tiddler in the result or not.\n   *     In this case, all edges stored in the tiddler are treated as\n   *     outgoing and the arrow head is ignored. If not specified,\n   *     all edges are included.\n   * @param {Hashmap<string, boolean>} [typeWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge of a given type in the result or not. If not\n   *     specified, all edges are included.\n   */\n  getEdges(tiddler, toWL, typeWL) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) {\n      return;\n    }\n\n    const { allETy } = this.indeces;\n    const edges = utils.makeHashMap();\n    const eTySubscribers = this.edgeTypeSubscriberRegistry.getAll();\n\n    for (let i = 0, l = eTySubscribers.length; i < l; i++) {\n      Object.assign(edges, (eTySubscribers[i]).loadEdges(tObj, toWL, typeWL));\n    }\n\n    for (let id in edges) {\n\n      const edge = edges[id];\n\n      // check exists for historical reasons...\n      if (!edge.from || !edge.to) {\n        continue;\n      }\n\n      const type = allETy[edge.type] || new EdgeType(edge.type);\n      addStyleToEdge(edges[id], type);\n\n      edges[id] = edge;\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * The method will return all outgoing edges for a subset of tiddlers.\n   *\n   * @param {Array<Tiddler>} tiddlers - The set of tiddlers to consider.\n   * @param toWL\n   * @param typeWL\n   * @return {Hashmap<Id, Edge>} An edge collection.\n   */\n  getEdgesForSet(tiddlers, toWL, typeWL) {\n\n    const edges = utils.makeHashMap();\n    for (let i = tiddlers.length; i--;) {\n      Object.assign(edges, this.getEdges(tiddlers[i], toWL, typeWL));\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * Select all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   */\n  selectEdgesByType(type) {\n\n    const typeWL = utils.makeHashMap({\n      [new EdgeType(type).id]: true,\n    });\n\n    return this.getEdgesForSet(this.getAllPotentialNodes(), null, typeWL);\n\n  }\n\n  /**\n   *\n   * @return {*}\n   */\n  getAllPotentialNodes() {\n\n    return utils.getMatches($tm.selector.allPotentialNodes);\n\n  };\n\n  /**\n   * Deletes or renames all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   * @param {('rename'|'delete')} [action='delete']\n   * @param {string} [newName]\n   */\n  _processEdgesWithType(type, { action, newName }) {\n\n    type = new EdgeType(type);\n\n    $tm.logger('debug', 'Processing edges', type, action);\n\n    // get edges\n    const edges = this.selectEdgesByType(type);\n\n    if (action === 'rename') {\n\n      // clone type first to prevent auto-creation\n      const newType = new EdgeType(newName);\n      newType.load(type);\n      newType.save();\n\n    }\n\n    for (let id in edges) {\n\n      this._processEdge(edges[id], 'delete');\n\n      if (action === 'rename') {\n        edges[id].type = newName;\n        this._processEdge(edges[id], 'insert');\n      }\n    }\n\n    // finally remove the old type\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Returns a set of nodes that corresponds to a set of tiddlers.\n   *\n   * @param {TiddlerCollection} tiddlers - A collection of tiddlers.\n   * @param {Hashmap} [addProperties] - a hashmap\n   * @param {CollectionTypeString} [outputType='dataset'] - The result type.\n   *\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByReferences(tiddlers, { addProperties, outputType } = {}) {\n\n    const result = utils.makeHashMap();\n    const keys = Object.keys(tiddlers);\n\n    for (let i = keys.length; i--;) {\n\n      const node = this.makeNode(tiddlers[keys[i]], addProperties);\n      if (node) {\n        result[node.id] = node;\n      }\n\n    }\n\n    return utils.convert(result, outputType);\n\n  }\n\n  /**\n   * Retrieve nodes based on the a list of ids that corrspond to tiddlers\n   * id fields.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids of the tiddlers\n   *     that represent the nodes.\n   * @param {Hashmap} [options] - See {@link Adapter#selectNodesByReferences}.\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByIds(nodeIds, options) {\n\n    const tRefs = this.getTiddlersByIds(nodeIds);\n\n    return this.selectNodesByReferences(tRefs, options);\n\n  }\n\n  /**\n   * Select a single node by id.\n   *\n   * @param {Id} id - A node's id\n   * @param {Hashmap} [options]\n   *     Except from the outputType option, all options\n   *     are inherited from {@link Adapter#selectNodesByIds}.\n   * @return {Node|undefined} A node or nothing.\n   */\n  selectNodeById(id, options) {\n\n    options = Object.assign({}, options, { outputType: 'hashmap' });\n    const result = this.selectNodesByIds([ id ], options);\n\n    return result[id];\n\n  }\n\n  /**\n   * Deletes a node type from the system.\n   * @param {NodeType|string} type - the node type id or the actual NodeType\n   */\n  removeNodeType(type) {\n\n    type = new NodeType(type);\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Gets a Node representation for a tiddler.\n   *\n   * @param {Tiddler} tiddler - the tiddler to represent as node\n   * @param {Object} protoNode - default node properties\n   *\n   * @return {Node|void}\n   */\n  makeNode(tiddler, protoNode) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) return;\n\n    // merge(!) so later node manipulations do not affect other nodes\n    const node = utils.merge({}, protoNode);\n\n    // note: assignId() will not assign an id if the tiddler already has one\n    node.id = this.assignId(tObj);\n\n    // add label\n    const label = tObj.fields[$tm.field.nodeLabel];\n    node.label = (label && $tm.field.nodeLabel !== 'title'\n      ? this.wiki.renderText('text/plain', 'text/vnd-tiddlywiki', label)\n      : tObj.fields.title);\n\n    return node;\n\n  }\n\n  /**\n   * Return node styles that are inherited from system styles or node types.\n   *\n   * @param nodes\n   * @return {Object<TiddlerReference, Object>}\n   */\n  getInheritedNodeStyles(nodes) {\n\n    const src = this.getTiddlersByIds(nodes);\n    const protoByTRef = {};\n    const glNTy = this.indeces.glNTy;\n\n    for (let i = glNTy.length; i--;) {\n      const type = glNTy[i];\n\n      let inheritors = [];\n      if (type.id === 'tmap:neighbour') { // special case\n        for (let id in nodes) {\n\n          if (nodes[id].group === 'tmap:neighbour') {\n\n            inheritors.push(this.getTiddlerById(id));\n          }\n        }\n      } else {\n        inheritors = type.getInheritors(src);\n      }\n\n      for (let j = inheritors.length; j--;) {\n        const tRef = inheritors[j];\n        const proto = protoByTRef[tRef] = (protoByTRef[tRef] || {});\n        proto.style = utils.merge(\n          proto.style || {},\n          type.style\n        );\n\n        // ATTENTION: only override proto icons when the type provides\n        // an icon since otherwise we might erase previously\n        // inherited icons.\n        if (type['fa-icon']) {\n          proto['fa-icon'] = type['fa-icon'];\n        } else if (type['tw-icon']) {\n          proto['tw-icon'] = type['tw-icon'];\n        }\n\n      }\n    }\n\n    return protoByTRef;\n\n  }\n\n  /**\n   * Adds styles to nodes.\n   *\n   * @param {Object<string, Node>} nodes\n   * @param {ViewAbstraction|string} view\n   */\n  attachStylesToNodes(nodes, view) {\n\n    view = new ViewAbstraction(view);\n\n    const inheritedStyles = this.getInheritedNodeStyles(nodes);\n\n    const viewNodeData = view.exists() ? view.getNodeData() : utils.makeHashMap();\n    const isStaticMode = view.exists() && !view.isEnabled('physics_mode');\n\n    for (let id in nodes) {\n\n      const tRef = this.getTiddlerById(id);\n      const tObj = this.wiki.getTiddler(tRef);\n      const fields = tObj.fields;\n\n      const node = nodes[id];\n      let faIcon = null;\n      let twIcon = null;\n\n      // == group styles ==\n\n      // will add local and global group styles\n      if (inheritedStyles[tRef]) {\n\n        if (inheritedStyles[tRef].style) {\n          utils.merge(node, inheritedStyles[tRef].style);\n        }\n        faIcon = inheritedStyles[tRef]['fa-icon'];\n        twIcon = inheritedStyles[tRef]['tw-icon'];\n      }\n\n      // == global node styles ==\n\n      // background color\n      if (fields.color) {\n        node.color = fields.color;\n      }\n\n      // global node style from vis editor\n      if (fields['tmap.style']) {\n        utils.merge(node, utils.parseJSON(fields['tmap.style']));\n      }\n\n      faIcon = fields['tmap.fa-icon'] || faIcon;\n      twIcon = fields['icon'] || twIcon;\n\n      // == local node styles ==\n\n      // local node style and positions\n\n      if (viewNodeData[id]) {\n\n        utils.merge(node, viewNodeData[id]);\n        if (isStaticMode) {\n          // fix x if x-position is set; same for y\n          node.fixed = {\n            x: (node.x != null),\n            y: (node.y != null)\n          };\n        }\n\n        faIcon = viewNodeData[id]['fa-icon'] || faIcon;\n\n        twIcon = viewNodeData[id]['tw-icon'] || twIcon;\n      }\n\n      // == tweaks ==\n\n      const isColorObject = (node.color !== null\n      && typeof node.color === 'object');\n      // color/border-color may be undefined\n      const color = (isColorObject ? node.color.background : node.color);\n\n      node.color = {\n        background: color,\n        border: (isColorObject ? node.color.border : undefined)\n      };\n\n      // ATTENTION: this function needs to be called after color is assigned\n      addNodeIcon(node, faIcon, twIcon);\n\n      // determine font color if not defined via a group- or node-style;\n      // in case of global and local default styles, the user is responsible\n      // him- or herself to adjust the font\n      node.font = node.font || {};\n\n      if (node.shape && !this.visShapesWithTextInside[node.shape]) {\n        node.font.color = 'black'; // force a black color\n      } else if (!node.font.color && color) {\n        node.font.color = getContrastColour(color, color, 'black', 'white');\n      }\n\n      if (node.shape === 'icon' && typeof node.icon === 'object') {\n        node.icon.color = color;\n      }\n\n    }\n\n    if (view.exists()) {\n      const node = nodes[view.getConfig('central-topic')];\n      if (node) {\n        utils.merge(node, this.indeces.glNTyById['tmap:central-topic'].style);\n      }\n    }\n\n  }\n\n  /**\n   * This function will remove all tiddlers from the wiki that correspond\n   * to a node in the collection. Drafts are also removed. The default\n   * storylist is updated eventually.\n   * call deleteNode which does the following\n   * 1. get id using IdByT\n   * 2. remove id using adapter.deleteEdgesByTo(idByT[tRef])\n   * 3. remove from all indeces\n   *\n   * @see: https://github.com/Jermolene/TiddlyWiki5/issues/1550\n   *\n   * @param {Node|string} node.\n   */\n  deleteNode(node) {\n\n    if (!node) return;\n\n    const id = (typeof node === 'object' ? node.id : node);\n    const tRef = this.getTiddlerById(id);\n\n    // delete tiddler and remove it from the river; this will\n    // automatically remove the global node style and the outgoing edges\n\n    if (tRef) {\n      // checking for tRef is needed;\n      // see: https://github.com/Jermolene/TiddlyWiki5/issues/1919\n      utils.deleteTiddlers([ tRef ]);\n    }\n\n    // delete local node-data in views containing the node\n\n    const viewRefs = utils.getMatches(env.selector.allViews);\n    for (let i = viewRefs.length; i--;) {\n      const view = new ViewAbstraction(viewRefs[i]);\n      view.removeNode(id);\n      if (view.getNodeData(id)) {\n        view.saveNodeData(id, null);\n      }\n    }\n\n    // remove obsolete connected edges\n\n    const neighbours = this.getNeighbours([ tRef ]);\n    this.deleteEdges(neighbours.edges);\n\n    // -------------------------------------------\n    // NEVER DELETE AN INDEX THAT ALREADY EXISTED!\n    // -------------------------------------------\n    // Some instances may have cached the index and get confused!\n    // It does not do harm to leave indeces as is since we do not\n    // iterate over them(!) and when a tiddler has the same title or\n    // id as a deleted tiddler, which is highly unlikely, then it will\n    // simply override the index, which is totally fine. The indeces\n    // are refreshed on every boot anyway so it is not a big deal.\n    //\n    // THEREFORE:\n    //\n    // DO NOT DO delete this.tById[id];\n    // DO NOT DO delete this.idByT[tRef];\n\n  }\n\n  /**\n   * Delete all nodes from the system.\n   *\n   * @param {string[]} ids ids\n   */\n  deleteNodes(ids) {\n\n    for (let i = ids.length; i--;) {\n      this.deleteNode(ids[i]);\n    }\n\n  }\n\n  /**\n   * Public API function; will store the positions into the sprecified view.\n   *\n   * @param {object} positions A hashmap ids as keys and x, y properties as values\n   * @param {ViewAbstraction|Tiddler|string} view\n   */\n  storePositions(positions, view) {\n\n    view = new ViewAbstraction(view);\n    if (!view.exists()) return;\n\n    view.saveNodeData(positions);\n\n  }\n\n  /**\n   * Create a new tiddler that gets a non-existant title and is opened\n   * for edit. If a view is registered, the fields of the tiddler match\n   * the current view. If arguments network and position are specified,\n   * the node is also inserted directly into the graph at the given\n   * position.\n   *\n   * @TODO: Description is obsolete!\n   *\n   * @param {object} node A node object to be inserted\n   * @param {ViewAbstraction|string} view - used to set positions and register the node to\n   * @param {Tiddler} protoTiddler\n   */\n  insertNode(node = {}, view, protoTiddler) {\n\n    // title might has changed after generateNewTitle()\n    node.label = this.wiki.generateNewTitle(node.label || utils.getRandomLabel());\n\n    // add to tiddler store\n    const tObj = new $tw.Tiddler(\n      { text: '' }, // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n      protoTiddler,\n      {\n        title: node.label, // force title\n        'tmap.id': null // force empty id (generated later)\n      },\n      this.wiki.getModificationFields(),\n      this.wiki.getCreationFields()\n    );\n\n    this.wiki.addTiddler(tObj);\n\n    node = this.makeNode(tObj, node);\n\n    view = new ViewAbstraction(view);\n    if (view.exists()) {\n      view.addNode(node);\n    }\n\n    return node;\n\n  }\n\n  /**\n   * Retrieve tiddlers based on the a list of corresponding ids.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids.\n   * @return {Array<TiddlerReference>} The resulting tiddlers.\n   */\n  getTiddlersByIds(nodeIds) {\n\n    // transform into a hashmap with all values being true\n    if (Array.isArray(nodeIds)) {\n      nodeIds = utils.getArrayValuesAsHashmapKeys(nodeIds);\n    } else if (nodeIds instanceof vis.DataSet) {\n      nodeIds = utils.getLookupTable(nodeIds, 'id'); // use id field as key\n    }\n\n    const result = [];\n    for (let id in nodeIds) {\n      const tRef = this.getTiddlerById(id);\n      if (tRef) {\n        result.push(tRef);\n      }\n    }\n\n    return result;\n\n  }\n}\n\n/**** Helper *******************************************************/\n\n/**\n * Returns the short symbol identifier (`&#xf2bc;` → `f206`).\n *\n * @param str FontAwesome id\n * @return {string}\n * @private\n */\nconst getFAdigits = (str) => (str.length === 4 ? str : str.substr(3, 4));\n\n/**\n * Adds an icon to the specified node.\n *\n * @param {Node} node\n * @param {string} faIcon\n * @param {string} twIcon\n * @private\n */\nconst addNodeIcon = (node, faIcon, twIcon) => {\n\n  // Font Awesome style\n\n  if (faIcon) {\n    node.shape = 'icon';\n    node.icon = {\n      shape: 'icon',\n      face: 'FontAwesome',\n      color: node.color,\n      code: String.fromCharCode('0x' + getFAdigits(faIcon))\n    };\n\n    return;\n  }\n\n  // TiddlyWiki stored icons\n\n  if (twIcon) {\n\n    const imgTObj = utils.getTiddler(twIcon);\n    if (!imgTObj) return;\n\n    if (imgTObj.fields['_canonical_uri']) { // image is a url address\n      node.image = imgTObj.fields['_canonical_uri'];\n      node.shape = 'image';\n\n    } else if (imgTObj.fields.text) {\n      node.image = utils.getDataUri(imgTObj);\n      node.shape = 'image';\n    }\n\n  }\n\n};\n\n/**\n * Garbage collector for obsolete node data.\n *\n * @param {Object<string, Node>} nodes\n * @param {ViewAbstraction|string} view\n * @private\n */\nconst removeObsoleteViewData = (nodes, view) => {\n\n  view = new ViewAbstraction(view);\n  if (!view.exists() || !nodes) return;\n\n  const data = view.getNodeData();\n\n  let obsoleteDataItems = 0;\n  for (let id in data) {\n    if (nodes[id] === undefined && data[id] != null) {\n      // we only set this to undefined as deletion would\n      // slow down V8, however, this necessarily requires\n      // a safeguard agains recursion: data[id] != null\n\n      data[id] = undefined;\n      obsoleteDataItems++;\n    }\n  }\n\n  if (obsoleteDataItems) {\n    $tm.logger('debug', '[Cleanup]',\n      'Removed obsolete node data:',\n      view.getLabel(), obsoleteDataItems);\n    view.saveNodeData(data);\n  }\n\n};\n\n/**\n * Sets up an edge object that is ready to be consumed by vis.\n *\n * @param {Edge} edge\n * @param {EdgeType} type\n */\nconst addStyleToEdge = (edge, type) => {\n\n  edge = Object.assign(edge, type.style);\n\n  if (utils.isTrue(type['show-label'], true)) {\n    edge.label = type.getLabel();\n  }\n\n};\n\n/*** Exports *******************************************************/\n\nexport default Adapter;\n"],"sourceRoot":"../../../../../../src/plugins"}