{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/ViewAbstraction.js"],"names":["_EdgeType","require","_utils","ViewAbstraction","view","options","this","_registerPaths","isCreate","_createView","exists","rebuildCache","prototype","_noNeedToRebuildCache","comp","_utils2","default","makeHashMap","config","_getConfigPath","nodeFilter","edgeTypeFilter","$tw","Tiddler","fields","title","getWithoutPrefix","$tm","path","views","hasSubString","t","getRandomLabel","plural","generateNewTitle","getPaths","_ref","arguments","length","undefined","isForce","protoView","isHidden","destroy","results","cp","getRoot","viewMarker","id","genUUID","filter","defaultEdgeTypeFilter","field","wiki","isShadowTiddler","isLocked","updates","changedTiddlers","edgeTypes","hasKeyWithPrefix","getConfig","getNodeFilter","addPlaceholder","tRef","tiddlerExists","getCreationDate","asString","val","getTiddler","Date","getLabel","getBasename","deleteTiddlers","getMatches","getOccurrences","newLabel","rename","inArray","notify","oldLabel","mv","oldRoot","newRoot","sys","defaultView","setEntry","ref","sysUserConf","liveTab","tObj","each","startsWith","setField","nodes","getNodeData","saveNodeData","isEnabled","name","isTrue","isRebuild","getPropertiesByPrefix","getHierarchyEdgeTypes","orderByEdges","labels","tracker","getTiddlerById","args","setConfig","logger","_typeof","prop","addTiddler","match","regex","isExplicitNode","node","utils","escapeRegExp","_getAddNodeFilterPart","setNodeFilter","isLiveView","expr","misc","liveViewLabel","setEdgeTypeFilter","replace","getEdgeTypeFilter","force","addNode","part","saveNodePosition","removeNode","f","indeces","src","type","allETy","Object","keys","raw","pretty","getPrettyFilter","matches","getEdgeTypeMatches","whitelist","getLookupTable","isEdgeTypeVisible","namespace","compiled","compileFilter","isEdgeTypeMatch","data","nodeData","parseFieldData","map","equals","p","extend","style","writeFieldData","jsonIndentation","x","y","setCentralTopic","saveNodeStyle"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/graph/ViewAbstraction.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport EdgeType from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/*** Code **********************************************************/\n\n/**\n * This class abstracts the various pieces that together make up the\n * view such as map, edge filter, node filter, config etc.\n * If {@code isCreate} is not specified, the viewAbstraction will only\n * represent the view and not create it or any missing part of it.\n *\n * @param {string|ViewAbstraction|Tiddler} view - The view\n * @param {Object} options\n * @param {boolean} [options.isCreate] - True if the view should be created and override\n *     any existing view, false otherwise.\n * @constructor\n */\nfunction ViewAbstraction(view, options) {\n\n  options = options || {};\n\n  if (view instanceof ViewAbstraction) {\n    // bounce back the object we received\n    return view;\n  }\n\n  // start building paths\n  this._registerPaths(view, options.isCreate);\n\n  if (options.isCreate) {\n\n    this._createView(options);\n\n  } else if (!this.exists()) { // no valid config path\n\n    // if the view doesn't exist, then we return a dummy object\n    // whose sole purpose is to tell the world that this\n    // view doesn't exist.\n    return { exists: function() {  return false; } };\n\n  }\n\n  // force complete rebuild\n  this.rebuildCache();\n\n}\n\n/**\n * If a ViewAbstraction instance has been modified and changes\n * have been persisted, then the next refresh cycle would trigger\n * a rebuild of the cache since tiddlers related to this view\n * changed. To avoid this, all functions that modify the state\n * of this view related to cached properties need to set a flag\n * in this variable. This flag prevents a rebuild in the next\n * refresh cycle.\n *\n * NOTE: This is done for mere performance reasons, if some\n * function is implemented without setting this flag to true\n * at the end, it doesn't real cause trouble.\n *\n */\nViewAbstraction.prototype._noNeedToRebuildCache = false;\n\n/**\n *\n */\nViewAbstraction.prototype._registerPaths = function(view, isCreate) {\n\n  // attention: To ensure that the refresh mechanism detects changes,\n  // comp is only allowed to have direct child properties\n  this.comp = this.comp || utils.makeHashMap();\n  this.comp.config = this._getConfigPath(view, isCreate);\n\n  // the view's store (=local store) for node properties\n  this.comp.map = this.comp.config + '/map';\n\n  // filter stores\n  this.comp.nodeFilter = this.comp.config + '/filter/nodes';\n  this.comp.edgeTypeFilter = this.comp.config + '/filter/edges';\n\n};\n\n/**\n * Will try to translate the constructor param into the config path.\n *\n * @private\n * @param {*} view - The constructor param to abstract or create the view.\n * @param {boolean} isCreate - If true and the supplied view did not\n *     result in a proper path, we will create one.\n * @result {string|undefined} The path or undefined if translation failed.\n */\nViewAbstraction.prototype._getConfigPath = function(view, isCreate) {\n\n  if (view instanceof $tw.Tiddler) { // is a tiddler object\n    return view.fields.title;\n  }\n\n  if (typeof view === 'string') {\n\n    // remove prefix and slash\n    view = utils.getWithoutPrefix(view, $tm.path.views + '/');\n\n    if (view && !utils.hasSubString(view, '/')) {\n      // a valid label must not contain any slashes\n      return $tm.path.views + '/' + view; // add prefix (again)\n    }\n  }\n\n  if (isCreate) {\n    var t = $tm.path.views + '/' + utils.getRandomLabel({ plural: true });\n    return $tw.wiki.generateNewTitle(t);\n  }\n\n};\n\n/**\n * A hashmap of all paths (tiddler titles) that make up this view.\n *\n * @return {Hashmap} The paths.\n */\nViewAbstraction.prototype.getPaths = function() {\n\n  return this.comp;\n\n};\n\n/**\n * Will create the config tiddler which means that the view will\n * start to exist.\n *\n * @private\n */\nViewAbstraction.prototype._createView = function({ isForce, protoView, isHidden } = {}) {\n\n  // destroy any former view that existed in this path\n  if (this.exists()) {\n\n    if (!isForce) return;\n\n    this.destroy();\n  }\n\n  protoView = new ViewAbstraction(protoView);\n  if (protoView.exists()) {\n    var results = utils.cp(protoView.getRoot(), this.comp.config, true);\n  }\n\n  // create new view\n  var fields = {};\n  fields.title = this.comp.config;\n\n  if (!isHidden) {\n    fields[$tm.field.viewMarker] = true;\n  }\n\n  // an id is actually not used for view in TM, I just reserve it…\n  fields.id = utils.genUUID();\n\n  $tw.wiki.addTiddler(new $tw.Tiddler(\n    utils.getTiddler(this.comp.config), // in case we cloned the view\n    fields\n  ));\n\n  this.setEdgeTypeFilter($tm.filter.defaultEdgeTypeFilter);\n\n};\n\nViewAbstraction.prototype.isLocked = function() {\n\n  return $tw.wiki.isShadowTiddler(this.comp.config);\n\n};\n\n/**\n *\n * @see ViewAbstraction#rebuildCache\n *\n * @return {boolean} True if the instance has updated itself\n */\nViewAbstraction.prototype.update = function(updates) {\n\n  var changedTiddlers = updates.changedTiddlers;\n\n  if (updates[$tm.path.edgeTypes]\n     || utils.hasKeyWithPrefix(changedTiddlers, this.comp.config)) {\n\n    this.rebuildCache();\n\n    return true;\n\n  }\n\n};\n\n/**\n * This method will rebuild the cache.\n */\nViewAbstraction.prototype.rebuildCache = function(isForce) {\n\n  if (!isForce && this._noNeedToRebuildCache) {\n    this._noNeedToRebuildCache = false;\n    return;\n  }\n\n  this.config = this.getConfig(null, true);\n  this.nodeData = this.getNodeData(null, true);\n  this.nodeFilter = this.getNodeFilter(null, true);\n  this.edgeTypeFilter = this.getEdgeTypeFilter(null, true);\n\n};\n\n/**\n * clones the tiddler denoted via tRef and uses it as placeholder\n * for this view when a widget using this view is displayed in\n * static mode\n */\nViewAbstraction.prototype.addPlaceholder = function(tRef) {\n\n  utils.cp(tRef, this.getRoot() + '/snapshot', true);\n\n};\n\n/**\n * A view exists if the constructor parameter was successfully\n * translated into a {@link TiddlerReference} that corresponds to\n * an existing view tiddler in the store.\n *\n * @return {boolean} True if it exists, false otherwise.\n */\nViewAbstraction.prototype.exists = function() {\n  return utils.tiddlerExists(this.comp.config);\n};\n\n/**\n * The path to the config tiddler that represents the view.\n *\n * @return {TiddlerReference} The view path.\n */\nViewAbstraction.prototype.getRoot = function() {\n  return this.comp.config;\n};\n\n/**\n * Returns this view's creation date.\n *\n * @param {boolean} [asString] True if the returned value should be\n *     a string in any case.\n * @return {string|object|undefined} The creation date in the specified\n *     output format.\n */\nViewAbstraction.prototype.getCreationDate = function(asString) {\n\n  var val = $tw.wiki.getTiddler(this.comp.config).fields['created'];\n  if (asString) {\n    // note: th will be translated as well!\n    return (val instanceof Date\n            ? $tw.utils.formatDateString(val, 'DDth MMM YYYY')\n            : '');\n  }\n\n  return val;\n\n};\n\n/**\n * The label of the view (which is basically the roots basename).\n *\n * @return {string} The label (name) of the view.\n */\nViewAbstraction.prototype.getLabel = function() {\n\n  return utils.getBasename(this.comp.config);\n\n};\n\n/**\n * Method to remove all tiddlers prefixed with the views root. This\n * will make the view non-existent.\n *\n * ATTENTION: Do not use the object anymore after you called\n * this function!\n */\nViewAbstraction.prototype.destroy = function() {\n\n  // delete the view and all tiddlers stored in its path (map, edge-filter etc.)\n  var filter = '[prefix[' + this.getRoot() + ']]';\n  utils.deleteTiddlers(utils.getMatches(filter));\n\n};\n\n/**\n *\n */\nViewAbstraction.prototype.getOccurrences = function() {\n\n  var filter = '[regexp:text[<\\\\$(tiddlymap|tmap).*?view=.'\n               + this.getLabel()\n               + '..*?>]]';\n  return utils.getMatches(filter);\n\n};\n\nViewAbstraction.prototype.rename = function(newLabel) {\n\n  if (typeof newLabel !== 'string') return false;\n\n  if (utils.inArray('/', newLabel)) {\n    $tm.notify('A view name must not contain any \"/\"');\n    return false;\n  }\n\n  // keep a reference to the old label before we change it\n  var oldLabel = this.getLabel();\n\n  // start the renaming\n  var newRoot = $tm.path.views + '/' + newLabel;\n  var oldRoot = this.getRoot();\n  var results = utils.mv(oldRoot, newRoot, true);\n\n  // update references\n\n  if ($tm.config.sys.defaultView === oldLabel) {\n    utils.setEntry($tm.ref.sysUserConf,\n                    'defaultView',\n                    newLabel);\n  }\n\n  if ($tm.config.sys.liveTab.fallbackView === oldLabel) {\n    utils.setEntry($tm.ref.sysUserConf,\n                    'liveTab.fallbackView',\n                    newLabel);\n  }\n\n  $tw.wiki.each(function(tObj, tRef) {\n\n    if (tObj.fields['tmap.open-view'] === oldLabel) {\n\n      // update global node data fields referencing this view\n      utils.setField(tRef, 'tmap.open-view', newLabel);\n\n    } else if (utils.startsWith(tRef, $tm.path.views)) {\n\n      // update all local node data referencing this view\n      var view = new ViewAbstraction(tRef);\n      if (!view.exists()) return;\n\n      var nodes = view.getNodeData();\n      for (var id in nodes) {\n\n        if (nodes[id]['open-view'] === oldLabel) {\n\n          nodes[id]['open-view'] = newLabel;\n        }\n      }\n      view.saveNodeData(nodes);\n\n    }\n\n  });\n\n  this._registerPaths(newLabel);\n  this.rebuildCache();\n\n};\n\n/**\n * All configurations that are toggled via checkboxes to have a value\n * either `true` or `false` can be accessed via this method.\n *\n * @param {string} name - The configs name without the `_config` prefix.\n * @return {boolean} True if the configuration is enabled, false otherwise.\n */\nViewAbstraction.prototype.isEnabled = function(name) {\n\n  return utils.isTrue(this.getConfig(name), false);\n\n};\n\n/**\n * Returns a configuration value relating to the given name. If no name\n * is given, an object with all configurations is returned.\n *\n * @param {string} [name] - Instead of all configurations being returned,\n *     only the configuration named name is returned. The initial \"config.\"\n *     may be omitted.\n * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\n * @result {string|Object} If `type` is not specified an object containing\n *     all configurations is returned, otherwise a single value will be returned.\n */\nViewAbstraction.prototype.getConfig = function(name, isRebuild) {\n\n  if (!isRebuild && this.config) {\n\n    var config = this.config;\n\n  } else {\n\n    var fields = $tw.wiki.getTiddler(this.comp.config).fields;\n    var config = utils.getPropertiesByPrefix(fields, 'config.');\n\n  }\n\n  // TODO use regex to add \"config.\"\n  return (name ? config[(utils.startsWith(name, 'config.') ? name : 'config.' + name)] : config);\n\n};\n\n/**\n * If the active layout is set to *hierarchical*, this function will\n * return all edges that define the hierarchical order of this view.\n * If the layout is not set to *hierarchical*, an empty array is\n * returned.\n *\n * @return {Array<string>} A list of edge labels of edges that define\n *     the hierarchy.\n */\nViewAbstraction.prototype.getHierarchyEdgeTypes = function() {\n\n  if (this.getConfig('layout.active') !== 'hierarchical') return [];\n\n  var orderByEdges = utils.getPropertiesByPrefix(this.getConfig(), 'config.layout.hierarchical.order-by-', true);\n\n  var labels = utils.makeHashMap();\n  for (var id in orderByEdges) {\n\n    if (orderByEdges[id] === 'true') {\n\n      var tObj = utils.getTiddler($tm.tracker.getTiddlerById(id));\n      if (tObj) {\n        labels[utils.getBasename(tObj.fields.title)] = true;\n      }\n    }\n  }\n\n  return labels;\n\n};\n\n/**\n *\n */\nViewAbstraction.prototype.setConfig = function() {\n\n  var args = arguments;\n\n  if (args[0] == null) return; // null or undefined\n\n  if (args.length === 1 && typeof args[0] === 'object') {\n\n    for (var prop in args[0]) {\n\n      this.setConfig(prop, args[0][prop]);\n    }\n\n  } else if (args.length === 2 && typeof args[0] === 'string') {\n\n    var prop = utils.getWithoutPrefix(args[0], 'config.');\n    var val = args[1];\n\n    if (val === undefined) return;\n\n    if (val === null) {\n\n      $tm.logger('debug', 'Removing config', prop);\n      delete this.config['config.'+prop]; // todo set this to null\n\n    } else {\n\n      if (prop === 'edge_type_namespace') {\n        var match = val.match(/[^:]+/);\n        val = (match ? match[0] : '');\n      }\n\n    }\n\n    $tm.logger('log', 'Setting config', prop, val);\n    this.config['config.'+prop] = val;\n\n\n  } else { // not allowed\n\n    return;\n\n  }\n\n  // save\n  $tw.wiki.addTiddler(new $tw.Tiddler(\n    $tw.wiki.getTiddler(this.comp.config),\n    this.config\n  ));\n\n  this._noNeedToRebuildCache = true;\n\n};\n\n/**\n * Whether the node is already explicitly contained in the filter,\n * i.e. whether it is explicitly referenced by its title.\n */\nViewAbstraction.prototype.isExplicitNode = function(node) {\n\n  // @Todo: this way of testing is not 100% save as a node might\n  // have been added to the filter explicitly AND via a group filter.\n  const regex = $tw.utils.escapeRegExp(this._getAddNodeFilterPart(node));\n  return this.getNodeFilter('raw').match(regex);\n\n};\n\nViewAbstraction.prototype.isLiveView = function() {\n\n  return (this.getLabel() === $tm.misc.liveViewLabel);\n\n};\n\nViewAbstraction.prototype._getAddNodeFilterPart = function(node) {\n\n  if (!node) { throw 'Supplied param is not a node!'; }\n\n  const id = (typeof node === 'object' ? node.id : node);\n  return '[field:tmap.id[' + id + ']]';\n\n};\n\n/**\n * Sets and rebuilds the node filter according to the expression provided.\n *\n * @param {string} expr - A tiddlywiki filter expression.\n * @param {boolean} force\n */\nViewAbstraction.prototype.setNodeFilter = function(expr, force) {\n\n  expr = expr.replace(/[\\n\\r]/g, ' ');\n\n  if (this.getNodeFilter('raw') === expr) {\n    // already up to date;\n    // This check is critical to prevent recursion!\n    return;\n  }\n\n  if (this.isLiveView() && !force) {\n    $tm.notify('You must not change the live view\\'s node filter!');\n    return;\n  }\n\n  utils.setField(this.comp.nodeFilter, 'filter', expr);\n\n  $tm.logger('debug','Node filter set to', expr);\n\n  // rebuild filter now and prevent another rebuild at refresh\n  this.nodeFilter = this.getNodeFilter(null, true);\n\n  this._noNeedToRebuildCache = true;\n\n};\n\nViewAbstraction.prototype.setEdgeTypeFilter = function(expr) {\n\n  expr = expr.replace(/[\\n\\r]/g, ' ');\n\n  if (this.getEdgeTypeFilter('raw') === expr) { // already up to date\n    // This check is critical to prevent recursion!\n    return;\n  }\n\n  utils.setField(this.comp.edgeTypeFilter, 'filter', expr);\n\n  $tm.logger('debug','Edge filter set to', expr);\n\n  // rebuild filter now\n  this.edgeTypeFilter = this.getEdgeTypeFilter(null, true);\n\n  // and prevent another unecessary rebuild at refresh\n  this._noNeedToRebuildCache = true;\n\n};\n\n/**\n * Method to append a filter part to the current filter (*or*-style).\n *\n * @param {Node} node\n */\nViewAbstraction.prototype.addNode = function(node) {\n\n  if (this.isExplicitNode(node)) return false;\n\n  const part = this._getAddNodeFilterPart(node);\n  this.setNodeFilter(this.getNodeFilter('raw') + ' ' + part);\n\n  this.saveNodePosition(node);\n\n};\n\n/**\n * Removes a node from the the view filter that has been\n * explicitly added before.\n *\n * ATTENTION: Never remove the node data (i.e. style and positions)\n * from the node-data store. This will be done by a garbage\n * collector. See Adapter.prototype._removeObsoleteViewData\n */\nViewAbstraction.prototype.removeNode = function(node) {\n\n  if (!this.isExplicitNode(node)) return false;\n\n  const part = this._getAddNodeFilterPart(node);\n  const f = this.getNodeFilter('raw').replace(part, '');\n\n  this.setNodeFilter(f);\n  return true;\n\n};\n\n/**\n * Method will return a tiddlywiki edge-type filter that is used to\n * decide which edge types are displayed by the graph.\n *\n * @param {(\"raw\"|\"pretty\"|\"matches\"|\"whitelist\")} [type]\n *     Use this param to control the output type.\n * @param {boolean} [isRebuild] - True if to rebuild the cache,\n *     false otherwise.\n * @result {*}\n *     Depends on the type param:\n *     - raw: the original filter string\n *     - pretty: the prettyfied filter string for usage in textareas\n *     - matches: {Array<string>} all matches\n *     - whitelist: A lookup table where all matches are true\n */\nViewAbstraction.prototype.getEdgeTypeFilter = function(type, isRebuild) {\n\n  if (!isRebuild && this.edgeTypeFilter) {\n\n    var f = this.edgeTypeFilter;\n\n  } else {\n\n    var f = utils.makeHashMap();\n    var allETy = $tm.indeces.allETy;\n    var src = Object.keys(allETy);\n    var tObj = $tw.wiki.getTiddler(this.comp.edgeTypeFilter);\n\n    f.raw = (tObj && tObj.fields.filter || '');\n    f.pretty = utils.getPrettyFilter(f.raw);\n    f.matches = utils.getEdgeTypeMatches(f.raw, allETy);\n    f.whitelist = utils.getLookupTable(f.matches);\n\n  }\n\n  return (type ? f[type] : f);\n\n};\n\nViewAbstraction.prototype.isEdgeTypeVisible = function(type) {\n\n  const options = {\n    namespace: this.getConfig('edge_type_namespace')\n  };\n\n  type = new EdgeType(type, null, options);\n\n  return utils.isEdgeTypeMatch(type.id, this.edgeTypeFilter.raw);\n\n};\n\n/**\n * Method will return a tiddlywiki node filter that is used to\n * decide which nodes are displayed by the graph.\n *\n * @param {(\"raw\"|\"pretty\"|\"compiled\")} [type]\n *     Use this param to control the output type.\n * @param {boolean} [isRebuild] - True if to rebuild the cache,\n *     false otherwise.\n * @result {*}\n *     Depends on the type param:\n *     - raw: the original filter string\n *     - pretty: the prettyfied filter string for usage in textareas\n *     - compiled: {Array<string>} all matches\n */\nViewAbstraction.prototype.getNodeFilter = function(type, isRebuild) {\n\n  if (!isRebuild && this.nodeFilter) {\n\n    var f = this.nodeFilter;\n\n  } else {\n\n    var f = utils.makeHashMap();\n    var tObj = $tw.wiki.getTiddler(this.comp.nodeFilter);\n\n    f.raw = (tObj && tObj.fields.filter) || '';\n    f.pretty = utils.getPrettyFilter(f.raw);\n    f.compiled = $tw.wiki.compileFilter(f.raw);\n\n  }\n\n  return (type ? f[type] : f);\n\n};\n\n/**\n * This method will return the node data stored in the view.\n *\n * @todo When to delete obsolete data?\n *\n * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\n * @result {Hashmap<Id, Object>} A Hashmap with node data.\n *     Note: If the view doesn't exist, the hashmap will be empty.\n */\nViewAbstraction.prototype.getNodeData = function(id, isRebuild) {\n\n  var data = (!isRebuild && this.nodeData\n              ? this.nodeData\n              : utils.parseFieldData(this.comp.map, 'text', {}));\n\n  return (id ? data[id] : data);\n\n};\n\nViewAbstraction.prototype.equals = function(view) {\n\n  if (view === this) return true;\n\n  view = new ViewAbstraction(view);\n  return (view.exists() && this.getRoot() === view.getRoot());\n\n};\n\n/**\n * This function will merge the given data in the view's node store.\n *\n * If two arguments are provided, the first parameter is assumed\n * to be a node id and the second to be the data object. The data\n * will extend the existing data. If data is not an object, it is\n * assumed to be a delete directive and consequently the node data\n * in the store will be deleted.\n *\n * Otherwise, if a single object parameter is provided, it is regarded\n * as a node collection and the whole object is used to extend the store.\n *\n * @TODO I need to delete data of nodes that are not in view anymore\n */\nViewAbstraction.prototype.saveNodeData = function() {\n\n  const args = arguments;\n  const data = this.getNodeData();\n\n  if (args.length === 2) {\n\n    if (typeof args[1] === 'object') {\n      if (args[1] === null) {\n        // remember – in js null is an object :D\n        // we use null as a signal for deletion of the item\n        data[args[0]] = undefined;\n      } else {\n        data[args[0]] = $tw.utils.extend(data[args[0]] || {}, args[1]);\n      }\n    }\n\n  } else if (args.length === 1 && typeof args[0] === 'object') {\n\n    $tm.logger('log', 'Storing data in', this.comp.map);\n\n    $tw.utils.extend(data, args[0]);\n\n  } else {\n    return;\n  }\n\n  utils.writeFieldData(this.comp.map, 'text', data, $tm.config.sys.jsonIndentation);\n\n  // cache new values and prevent rebuild at refresh\n  this.nodeData = data;\n\n  this._noNeedToRebuildCache = true;\n\n};\n\nViewAbstraction.prototype.saveNodePosition = function(node) {\n\n  if (node.id && node.x && node.y) {\n    this.saveNodeData(node.id, { x: node.x, y: node.y });\n  }\n\n};\n\nViewAbstraction.prototype.setCentralTopic = function(id) {\n\n  this.setConfig('central-topic', id);\n\n};\n\nViewAbstraction.prototype.saveNodeStyle = function(id, style) {\n\n  // remove any previos style from store;\n  // @TODO: optimize this only null in style var needs to be removed\n  var data = this.getNodeData()[id];\n  if (data) {\n    // delete all previous properties, except positions\n    for (var p in data) {\n      if (p !== 'x' && p !== 'y') {\n        data[p] = undefined;\n      }\n    }\n  }\n\n  // save new style\n  this.saveNodeData(id, style);\n\n};\n\n/*** Exports *******************************************************/\n\nexport default ViewAbstraction;\n"],"sourceRoot":"../../../../../../src/plugins"}