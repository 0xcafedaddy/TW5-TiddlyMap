{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/basic.js"],"names":["_exception","require","ucFirst","string","toUpperCase","slice","hasElements","obj","Object","keys","length","escapeRegex","str","replace","path","separator","arguments","undefined","substring","lastIndexOf","startsWith","prefix","identity","_typeof","JSON","stringify","sort","map","key","isEqual","obj1","obj2","min","max","Math","floor","random","inArray","needle","haystack","indexOf","hasSubString","sub","parseJSON","data","Error","joinAndWrap","arr","left","right","join","makeHashMap","initialValues","enumerable","configurable","writable","value","prototype","hasOwnProperty","bind","getWithoutNewLines","el","className","document","classList","contains","findAndRemoveClassNames","classNames","i","elements","getElementsByClassName","j","remove","isInteger","Number","replaceAll","defaultReplacement","subStrings","subString","replacement","isTrue","confVal","defVal","n","parseInt","isNaN","removeArrayElement","index","splice","r","removePrefix","p","substr","getWithoutPrefix","pickRandom","getRandomInt","getImgFromWeb","imgUri","callback","xhr","XMLHttpRequest","open","responseType","onerror","e","console","log","onload","this","readyState","status","response","size","createObjectURL","blob","send","getFirstElementByClassName","cls","root","isRequired","text","EnvironmentError","getRandomLabel","options","adjective","noun","object","plural","_merge","dest","src","merge","_len","sources","Array","_key","l","setDomListeners","task","target","listeners","isCapt","event","childNodes","removeChild","mod","divident","divisor","remainder","_ref","y","distPrevX","x","raster","distPrevY","rasterHalf","bindTo","context","fnNames","fn"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/basic.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport {\n  EnvironmentError\n} from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/**\n * Uppercase the first letter of a string.\n */\nexport const ucFirst = string => string && string[0].toUpperCase() + string.slice(1);\n\n/**\n * Function to find out whether an object has any enumerable properties\n * or, in case of an array, elements.\n *\n * @param {Object} obj\n * @return {boolean} True if at least one enumerable property exists,\n *     false otherwise.\n */\nexport const hasElements = obj => Object.keys(obj).length > 0;\n\n/**\n * When we do not know the string, we need to escape it.\n * @deprecated use tw's escapeRegExp instead\n */\nexport const escapeRegex = str => str.replace(/[-$^?.+*[\\]\\\\(){}|]/g, '\\\\$&');\n\n/**\n * Returns the basename of a path.\n * A path is a string with slashes (or another separator).\n *\n * @param {string} path - The path\n * @param {string} [separator='/']\n * @return {string} The basename\n */\nexport const getBasename = (path, separator = '/') => path.substring(path.lastIndexOf(separator) + 1);\n\n/**\n * Helper to increase the code semantics.\n *\n * @param {string} str - The string to work with.\n * @param {string} prefix - The sequence to test.\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\n */\nexport const startsWith = (str, prefix) => str.substring(0, prefix.length) === prefix;\n\n\n/**\n * If two objects have the same properties, with the same values\n * then identity identity(obj) === identity(obj2) will return true.\n *\n * @param obj\n * @return string\n */\nexport const identity = obj =>\n  (typeof obj === 'object' && obj !== null\n    ?  JSON.stringify(Object.keys(obj).sort().map(key => [ key, obj[key] ]))\n    : null);\n\n/**\n * Returns true if both objects have the same properties\n * @param obj1\n * @param obj2\n */\nexport const isEqual = (obj1, obj2) => identity(obj1) === identity(obj2);\n\n/**\n *\n * @param min\n * @param max\n */\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min) + min);\n\n/**\n * Checks if a value exists in an array. A strict search is used\n * which means that also the type of the needle in the haystack\n * is checked.\n *\n * @param {*} needle - The searched value.\n * @param {Array} haystack - The array.\n * @return Returns true if needle is found in the array, false otherwise.\n */\nexport const inArray = (needle, haystack) => haystack.indexOf(needle) !== -1;\n\n/**\n * Checks if a string exists in a string.\n */\nexport const hasSubString = (str, sub) => str.indexOf(sub) !== -1;\n\n/**\n * Try to turn the string into a javascript object. If the\n * transformation fails, return the optionally provided `data` object.\n *\n * @param {string} str - The string to parse.\n * @param {*} data - The default value if the operation fails.\n * @return {*} Either the object resulting from the parsing operation\n *     or `undefined` or `data` if the operation failed.\n */\nexport const parseJSON = (str, data) => {\n\n  try {\n\n    return JSON.parse(str);\n\n  } catch (Error) {\n\n    return data;\n\n  }\n\n};\n\n/**\n * Joins all elements of an array into a string where all elements\n * are wrapped between `left` and `right`.\n *\n * @param {Array} arr - The array to perform the join on.\n * @param {string} left - The wrapping string for the left side.\n * @param {string} right - The wrapping string for the right side.\n * @param {string} [separator] - The separator between a wrapped element\n *     and the next one. Defaults to space.\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\n */\nexport const joinAndWrap = (arr, left, right, separator = ' ') =>\n  left + arr.join(right + separator + left) + right;\n\n/**\n * Remove any newline from a string\n */\nexport const getWithoutNewLines = str =>\n  (typeof str === 'string') ? str.replace(/[\\n\\r]/g, ' ') : str;\n\n\n/**\n * Factory function to return a prototypeless object that is used as\n * map. It only has the property hasOwnProperty in order to to be\n * exchangeble with other framworks that depend on this method like\n * e.g. visjs.\n *\n * @param {Object} [initialValues] - an object whose own properties will be\n *     used to initialize the map.\n */\nexport const makeHashMap = initialValues => {\n\n  const map = Object.create(null);\n  Object.defineProperty(map, 'hasOwnProperty', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.prototype.hasOwnProperty.bind(map)\n  });\n\n  if (initialValues) {\n    for (let key in initialValues) {\n      if (initialValues.hasOwnProperty(key)) {\n        map[key] = initialValues[key];\n      }\n    }\n  }\n\n  return map;\n\n};\n\n/**\n * If an ancestor that possesses a specified class exists the the\n * element will be returned, otherwise undefined is returned.\n *\n * @param {Element} el\n * @param {string} className\n */\nexport const getAncestorWithClass = (el, className) => {\n\n  if (typeof el !== 'object' || typeof className !== 'string') {\n    return;\n  }\n\n  while (el.parentNode && el.parentNode !== document) {\n    el = el.parentNode;\n    if (el.classList.contains(className)) {\n      return el;\n    }\n  }\n\n};\n\n/**\n * Searches the dom for elements that possess a certain class\n * and removes this class from each element.\n *\n * @param {Array<string>} classNames - The class names to remove.\n */\nexport const findAndRemoveClassNames = function(classNames) {\n\n  for (let i = classNames.length; i--;) {\n    const elements = document.getElementsByClassName(classNames[i]);\n    for (let j = elements.length; j--;) {\n      elements[j].classList.remove(classNames[i]);\n    }\n  }\n\n};\n\n/**\n * Polyfill until `isInteger` has become official. If the target\n * value is an integer, return true, otherwise return false.\n * If the value is NaN or infinite, return false.\n *\n * @param {*} value - The value to be tested for being an integer.\n * @return {boolean} True if the value is an integer, false otherwise.\n */\nexport const isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n         isFinite(value) &&\n         Math.floor(value) === value;\n};\n\n/**\n *\n * @param {string} str\n * @param defaultReplacement\n * @param subStrings\n * @return {*}\n */\nexport const replaceAll = (str, defaultReplacement = '', subStrings) => {\n\n  for (let i = subStrings.length; i--;) {\n\n    let subString = subStrings[i];\n    let replacement = defaultReplacement;\n\n    if (Array.isArray(subString)) {\n      replacement = subString[1];\n      subString = subString[0];\n    }\n\n    str = str.replace(subString, replacement);\n  }\n\n  return str;\n\n};\n\n/**\n * Sadly, setting fields with tw means that we lose the type information\n * since field values are persisted as strings and the type is not\n * included.\n *\n * To ensure that flags are always interpreted correctly, the following\n * function exists.\n *\n * We regard the following values as `true` (order matters):\n *\n * # Any string that can be translated into a number unequal `0`\n * # `\"true\"`\n * # Any number unequal `0`\n * # Boolean `true`\n *\n * The following as false (order matters):\n *\n * # Any string that can be translated into number `0`\n * # Every string unequal `\"true\"`\n * # The number `0`\n * # Boolean `false`\n *\n */\nexport const isTrue = (confVal, defVal) => {\n\n  if (confVal == null) {\n    return !!defVal;\n  } else if (typeof confVal === 'string') {\n    var n = parseInt(confVal);\n    return (isNaN(n) ? (confVal === 'true') : (n !== 0));\n  } else if (typeof confVal === 'boolean') {\n    return confVal;\n  } else if (typeof confVal === 'number') {\n    return (n !== 0);\n  }\n\n  return false;\n\n};\n\n/**\n * If the array contains the element, the element is removed from\n * the array in-place and the removed element.\n */\nexport const removeArrayElement = (arr, el) => {\n\n  const index = arr.indexOf(el);\n  if (index > -1) {\n    return arr.splice(index, 1)[0];\n  }\n\n};\n\n/**\n * Returns a new object that contains only properties that start with\n * a certain prefix. The prefix is optionally removed from the result.\n *\n * @param {Object} obj\n * @param {string} prefix - The start sequence\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\n *     from the resulting property name, false otherwise.\n * @result {object}\n */\nexport const getPropertiesByPrefix = (obj, prefix, removePrefix) => {\n\n  const r = makeHashMap();\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      r[(removePrefix ? p.substr(prefix.length) : p)] = obj[p];\n    }\n  }\n\n  return r;\n\n};\n\n/**\n * Function to remove the prefix of a string\n */\nexport const getWithoutPrefix =\n  (str, prefix) => startsWith(str, prefix) ? str.substr(prefix.length) : str;\n\n\n/**\n *\n */\nexport const hasKeyWithPrefix = (obj, prefix) => {\n\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n\n};\n\n/**\n *\n * @param arr\n */\nexport const pickRandom = arr => arr[getRandomInt(0, arr.length-1)];\n\n/**\n * Loads the image from web and passes it to the callback as\n * object url.\n */\nexport const getImgFromWeb = (imgUri, callback) => {\n\n  if (!imgUri || typeof callback !== 'function') return;\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', imgUri, true);\n  xhr.responseType = 'blob';\n  xhr.onerror = function(e) { console.log(e); };\n  xhr.onload = function(e) {\n    if (this.readyState === 4 && (this.status===200 || (this.status === 0 && this.response.size > 0))) {\n      const blob = this.response;\n      callback(window.URL.createObjectURL(blob));\n    }\n  };\n\n  try { xhr.send();  } catch (e) { console.log(e); }\n\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n  //~ propPath = propPath.split(\".\");\n  //~ for (var i = propPath.length; i--;) {\n    //~ if (obj !== null && typeof obj === \"object\") {\n      //~ obj = obj[propPath[i]];\n  //~ }\n  //~\n//~ };\n\n/**\n * Works like get `getElementById()` but is based on a class name.\n * It will return the first element inside an optional parent (root)\n * that has a class of this name.\n *\n * @param {string} cls - The class name to search for.\n * @param {Element} [root=document] - The context to search in.\n * @param {boolean} [isRequired=true] - If true, an exception will be\n *     thrown if no element can be retrieved. This is important\n *     when depending on third party modules and class names change!\n * @throws {EnvironmentError} - May be thrown if\n *    `isRequired` is set to true.\n * @return {Element} Either a dom element or null is returned.\n */\nexport const getFirstElementByClassName = (cls, root, isRequired) => {\n\n  const el = (root || document).getElementsByClassName(cls)[0];\n  if (!el && (typeof isRequired === 'boolean' ? isRequired : true)) {\n    const text = `Missing element with class \"${cls}\" inside ${root}`;\n    throw new EnvironmentError(text);\n  }\n\n  return el;\n\n};\n\nexport const getRandomLabel = (options = {}) => {\n\n  const adjective = pickRandom([\n    'exciting', 'notable', 'epic', 'new', 'fancy',\n    'great', 'cool', 'fresh', 'funky', 'clever'\n  ]);\n\n  const noun = (options.object || pickRandom([\n    'concept', 'idea', 'thought', 'topic', 'subject'\n  ])) + (options.plural ? 's' : '');\n\n  return `My ${adjective} ${noun}`;\n\n};\n\nconst _merge = (dest, src) => {\n\n  if (typeof dest !== 'object') {\n    dest = {};\n  }\n\n  for (let p in src) {\n    if (src.hasOwnProperty(p)) {\n      if (src[p] != null) { // skip null or undefined\n        dest[p] = (typeof src[p] === 'object'\n          ? _merge(dest[p], src[p])\n          : src[p]); // primitive type, stop recursion\n      }\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Merges `src` into `dest` which means that the merge transforms\n * the `dest` object itself. If src and dest both have the same\n * property path, src does only replace the primitive data type\n * at the end of the path.\n *\n * @todo Should null really be skipped or treated as value?\n *\n * @param {Object} dest - The destination object.\n * @param {...Object} sources - At least one object to merge into `dest`.\n * @return {Object} The original `dest` object.\n */\nexport const merge = (dest, ...sources) => {\n\n  // start the merging; i = 1 since first argument is the destination\n  for (let i = 0, l = sources.length; i < l; i++) {\n    const src = sources[i];\n    if (src != null && typeof src === 'object') {\n      dest = _merge(dest, src);\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Adds or removes listeners from the target in capture or\n * non-capture (bubbling) mode.\n *\n * @param {string} task - Either \"add\" or \"remove\". Make sure to\n *     always call add and remove with *excatly* the same listeners\n *     Note: if you use bind, you change the function object.\n * @param {Element} target - The element to attach or remove the\n *     listener to or from.\n * @param {Object<string, (Function|Array)>} listeners - The key is\n *     the event name and the value is either a handler function\n *     or an array where the first index is the handler function and\n *     the second is a boolean that specifies whether to use capture\n *     or not.\n * @param {boolean} [isCapt=false] - Whether to run the handler in\n *     bubbling or capturing phase.\n */\nexport const setDomListeners = (task, target, listeners, isCapt) => {\n\n  isCapt = (typeof isCapt === 'boolean' ? isCapt : false);\n  task = task + 'EventListener';\n\n  for (let event in listeners) {\n\n    const l = listeners[event];\n\n    if (typeof l === 'function') {\n\n      target[task](event, l, isCapt);\n    } else { // expect Array\n\n      target[task](event, l[0], (typeof l[1] === 'boolean' ? l[1] : isCapt));\n    }\n\n  }\n\n};\n\n/**\n * Removes all child nodes of a DOM element. This includes element\n * and non-element objects.\n */\nexport const removeDOMChildNodes = el => {\n\n  for (let i = el.childNodes.length; i--;) {\n    el.removeChild(el.childNodes[i]);\n  }\n\n};\n\n/**\n * Implementation of the algebraic modulus operation.\n *\n * In javascript '%' is really a remainder operator, not a modulus.\n * Algebraically speaking, a modulus operation always yields\n * positive results, while '%' in js can yield negative results.\n *\n * Note: divident mod divisor\n *\n * @param {number} divident\n * @param {number} divisor\n * @return {number}\n */\nexport const mod = (divident, divisor) => {\n\n  const remainder = divident % divisor;\n\n  return Math.floor(remainder >= 0 ? remainder : remainder + divisor);\n\n};\n\n/**\n * Maps a coordinate to the nearest raster coordinate.\n *\n * @param {number} x\n * @param {number} y\n * @param {number} raster\n * @return {{x: number, y: number}}\n */\nexport const getNearestRasterPosition = ({ x, y }, raster) => {\n\n  const rasterHalf = raster / 2;\n\n  // calculate distances to previous raster lines\n  const distPrevX = mod(x, raster);\n  const distPrevY = mod(y, raster);\n\n  return {\n    x: distPrevX < rasterHalf ? x - distPrevX : x - distPrevX + raster,\n    y: distPrevY < rasterHalf ? y - distPrevY : y - distPrevY + raster\n  };\n\n};\n\n/**\n * Force early binding of functions to this context.\n *\n * @param context the context to bind this function to (typically `this`)\n * @param {Array<string>} fnNames - The prototype function names\n *     to bind to this context.\n */\nexport const bindTo = (context, fnNames) => {\n\n  for (let i = fnNames.length; i--;) {\n    const fn = context[fnNames[i]];\n    context[fnNames[i]] = fn.bind(context);\n  }\n\n};\n"],"sourceRoot":"../../../../../../../src/plugins"}