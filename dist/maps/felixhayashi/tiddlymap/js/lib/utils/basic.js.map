{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/basic.js"],"names":["_exception","require","ucFirst","string","toUpperCase","slice","hasElements","obj","Object","keys","length","escapeRegex","str","replace","path","separator","arguments","undefined","substring","lastIndexOf","startsWith","prefix","identity","JSON","stringify","sort","map","key","getRandomInt","min","max","Math","floor","random","inArray","needle","haystack","indexOf","hasSubString","sub","parseJSON","data","parse","right","left","arr","join","getWithoutNewLines","makeHashMap","initialValues","create","joinAndWrap","enumerable","configurable","writable","value","prototype","hasOwnProperty","bind","el","className","parentNode","document","findAndRemoveClassNames","classNames","getAncestorWithClass","elements","getElementsByClassName","i","j","classList","remove","isInteger","Number","isFinite","replaceAll","defaultReplacement","subStrings","subString","replacement","Array","isArray","isTrue","confVal","defVal","n","parseInt","isNaN","index","splice","getPropertiesByPrefix","removePrefix","r","p","getWithoutPrefix","substr","pickRandom","getImgFromWeb","imgUri","callback","xhr","XMLHttpRequest","open","responseType","onerror","e","console","log","onload","this","readyState","status","response","size","blob","send","getFirstElementByClassName","cls","root","isRequired","text","EnvironmentError","getRandomLabel","options","adjective","noun","object","plural","_merge","dest","_typeof","src","merge","_len","sources","_key","l","setDomListeners","task","target","listeners","isCapt","event","removeDOMChildNodes","childNodes","removeChild","mod","divident","divisor","remainder","getNearestRasterPosition","_ref","raster","x","y","rasterHalf","distPrevY","distPrevX","bindTo","context","fnNames","fn","isEqual","obj1","obj2"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/basic.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport {\n  EnvironmentError\n} from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/**\n * Uppercase the first letter of a string.\n */\nexport const ucFirst = string => string && string[0].toUpperCase() + string.slice(1);\n\n/**\n * Function to find out whether an object has any enumerable properties\n * or, in case of an array, elements.\n *\n * @param {Object} obj\n * @return {boolean} True if at least one enumerable property exists,\n *     false otherwise.\n */\nexport const hasElements = obj => Object.keys(obj).length > 0;\n\n/**\n * When we do not know the string, we need to escape it.\n * @deprecated use tw's escapeRegExp instead\n */\nexport const escapeRegex = str => str.replace(/[-$^?.+*[\\]\\\\(){}|]/g, '\\\\$&');\n\n/**\n * Returns the basename of a path.\n * A path is a string with slashes (or another separator).\n *\n * @param {string} path - The path\n * @param {string} [separator='/']\n * @return {string} The basename\n */\nexport const getBasename = (path, separator = '/') => path.substring(path.lastIndexOf(separator) + 1);\n\n/**\n * Helper to increase the code semantics.\n *\n * @param {string} str - The string to work with.\n * @param {string} prefix - The sequence to test.\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\n */\nexport const startsWith = (str, prefix) => str.substring(0, prefix.length) === prefix;\n\n\n/**\n * If two objects have the same properties, with the same values\n * then identity identity(obj) === identity(obj2) will return true.\n *\n * @param obj\n * @return string\n */\nexport const identity = obj => JSON.stringify(Object.keys(obj).sort().map(key => [ key, obj[key] ]));\n\n/**\n *\n * @param min\n * @param max\n */\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min) + min);\n\n/**\n * Checks if a value exists in an array. A strict search is used\n * which means that also the type of the needle in the haystack\n * is checked.\n *\n * @param {*} needle - The searched value.\n * @param {Array} haystack - The array.\n * @return Returns true if needle is found in the array, false otherwise.\n */\nexport const inArray = (needle, haystack) => haystack.indexOf(needle) !== -1;\n\n/**\n * Checks if a string exists in a string.\n */\nexport const hasSubString = (str, sub) => str.indexOf(sub) !== -1;\n\n/**\n * Try to turn the string into a javascript object. If the\n * transformation fails, return the optionally provided `data` object.\n *\n * @param {string} str - The string to parse.\n * @param {*} data - The default value if the operation fails.\n * @return {*} Either the object resulting from the parsing operation\n *     or `undefined` or `data` if the operation failed.\n */\nexport const parseJSON = (str, data) => {\n\n  try {\n\n    return JSON.parse(str);\n\n  } catch (Error) {\n\n    return data;\n\n  }\n\n};\n\n/**\n * Joins all elements of an array into a string where all elements\n * are wrapped between `left` and `right`.\n *\n * @param {Array} arr - The array to perform the join on.\n * @param {string} left - The wrapping string for the left side.\n * @param {string} right - The wrapping string for the right side.\n * @param {string} [separator] - The separator between a wrapped element\n *     and the next one. Defaults to space.\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\n */\nexport const joinAndWrap = (arr, left, right, separator = ' ') =>\n  left + arr.join(right + separator + left) + right;\n\n/**\n * Remove any newline from a string\n */\nexport const getWithoutNewLines = str =>\n  (typeof str === 'string') ? str.replace(/[\\n\\r]/g, ' ') : str;\n\n\n/**\n * Factory function to return a prototypeless object that is used as\n * map. It only has the property hasOwnProperty in order to to be\n * exchangeble with other framworks that depend on this method like\n * e.g. visjs.\n *\n * @param {Object} [initialValues] - an object whose own properties will be\n *     used to initialize the map.\n */\nexport const makeHashMap = initialValues => {\n\n  const map = Object.create(null);\n  Object.defineProperty(map, 'hasOwnProperty', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.prototype.hasOwnProperty.bind(map)\n  });\n\n  if (initialValues) {\n    for (let key in initialValues) {\n      if (initialValues.hasOwnProperty(key)) {\n        map[key] = initialValues[key];\n      }\n    }\n  }\n\n  return map;\n\n};\n\n/**\n * If an ancestor that possesses a specified class exists the the\n * element will be returned, otherwise undefined is returned.\n *\n * @param {Element} el\n * @param {string} className\n */\nexport const getAncestorWithClass = (el, className) => {\n\n  if (typeof el !== 'object' || typeof className !== 'string') {\n    return;\n  }\n\n  while (el.parentNode && el.parentNode !== document) {\n    el = el.parentNode;\n    if (el.classList.contains(className)) {\n      return el;\n    }\n  }\n\n};\n\n/**\n * Searches the dom for elements that possess a certain class\n * and removes this class from each element.\n *\n * @param {Array<string>} classNames - The class names to remove.\n */\nexport const findAndRemoveClassNames = function(classNames) {\n\n  for (let i = classNames.length; i--;) {\n    const elements = document.getElementsByClassName(classNames[i]);\n    for (let j = elements.length; j--;) {\n      elements[j].classList.remove(classNames[i]);\n    }\n  }\n\n};\n\n/**\n * Polyfill until `isInteger` has become official. If the target\n * value is an integer, return true, otherwise return false.\n * If the value is NaN or infinite, return false.\n *\n * @param {*} value - The value to be tested for being an integer.\n * @return {boolean} True if the value is an integer, false otherwise.\n */\nexport const isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n         isFinite(value) &&\n         Math.floor(value) === value;\n};\n\n/**\n *\n * @param {string} str\n * @param defaultReplacement\n * @param subStrings\n * @return {*}\n */\nexport const replaceAll = (str, defaultReplacement = '', subStrings) => {\n\n  for (let i = subStrings.length; i--;) {\n\n    let subString = subStrings[i];\n    let replacement = defaultReplacement;\n\n    if (Array.isArray(subString)) {\n      replacement = subString[1];\n      subString = subString[0];\n    }\n\n    str = str.replace(subString, replacement);\n  }\n\n  return str;\n\n};\n\n/**\n * Sadly, setting fields with tw means that we lose the type information\n * since field values are persisted as strings and the type is not\n * included.\n *\n * To ensure that flags are always interpreted correctly, the following\n * function exists.\n *\n * We regard the following values as `true` (order matters):\n *\n * # Any string that can be translated into a number unequal `0`\n * # `\"true\"`\n * # Any number unequal `0`\n * # Boolean `true`\n *\n * The following as false (order matters):\n *\n * # Any string that can be translated into number `0`\n * # Every string unequal `\"true\"`\n * # The number `0`\n * # Boolean `false`\n *\n */\nexport const isTrue = (confVal, defVal) => {\n\n  if (confVal == null) {\n    return !!defVal;\n  } else if (typeof confVal === 'string') {\n    var n = parseInt(confVal);\n    return (isNaN(n) ? (confVal === 'true') : (n !== 0));\n  } else if (typeof confVal === 'boolean') {\n    return confVal;\n  } else if (typeof confVal === 'number') {\n    return (n !== 0);\n  }\n\n  return false;\n\n};\n\n/**\n * If the array contains the element, the element is removed from\n * the array in-place and the removed element.\n */\nexport const removeArrayElement = (arr, el) => {\n\n  const index = arr.indexOf(el);\n  if (index > -1) {\n    return arr.splice(index, 1)[0];\n  }\n\n};\n\n/**\n * Returns a new object that contains only properties that start with\n * a certain prefix. The prefix is optionally removed from the result.\n *\n * @param {Object} obj\n * @param {string} prefix - The start sequence\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\n *     from the resulting property name, false otherwise.\n * @result {object}\n */\nexport const getPropertiesByPrefix = (obj, prefix, removePrefix) => {\n\n  const r = makeHashMap();\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      r[(removePrefix ? p.substr(prefix.length) : p)] = obj[p];\n    }\n  }\n\n  return r;\n\n};\n\n/**\n * Function to remove the prefix of a string\n */\nexport const getWithoutPrefix =\n  (str, prefix) => startsWith(str, prefix) ? str.substr(prefix.length) : str;\n\n\n/**\n *\n */\nexport const hasKeyWithPrefix = (obj, prefix) => {\n\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n\n};\n\n/**\n *\n * @param arr\n */\nexport const pickRandom = arr => arr[getRandomInt(0, arr.length-1)];\n\n/**\n * Loads the image from web and passes it to the callback as\n * object url.\n */\nexport const getImgFromWeb = (imgUri, callback) => {\n\n  if (!imgUri || typeof callback !== 'function') return;\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', imgUri, true);\n  xhr.responseType = 'blob';\n  xhr.onerror = function(e) { console.log(e); };\n  xhr.onload = function(e) {\n    if (this.readyState === 4 && (this.status===200 || (this.status === 0 && this.response.size > 0))) {\n      const blob = this.response;\n      callback(window.URL.createObjectURL(blob));\n    }\n  };\n\n  try { xhr.send();  } catch (e) { console.log(e); }\n\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n  //~ propPath = propPath.split(\".\");\n  //~ for (var i = propPath.length; i--;) {\n    //~ if (obj !== null && typeof obj === \"object\") {\n      //~ obj = obj[propPath[i]];\n  //~ }\n  //~\n//~ };\n\n/**\n * Works like get `getElementById()` but is based on a class name.\n * It will return the first element inside an optional parent (root)\n * that has a class of this name.\n *\n * @param {string} cls - The class name to search for.\n * @param {Element} [root=document] - The context to search in.\n * @param {boolean} [isRequired=true] - If true, an exception will be\n *     thrown if no element can be retrieved. This is important\n *     when depending on third party modules and class names change!\n * @throws {EnvironmentError} - May be thrown if\n *    `isRequired` is set to true.\n * @return {Element} Either a dom element or null is returned.\n */\nexport const getFirstElementByClassName = (cls, root, isRequired) => {\n\n  const el = (root || document).getElementsByClassName(cls)[0];\n  if (!el && (typeof isRequired === 'boolean' ? isRequired : true)) {\n    const text = `Missing element with class \"${cls}\" inside ${root}`;\n    throw new EnvironmentError(text);\n  }\n\n  return el;\n\n};\n\nexport const getRandomLabel = (options = {}) => {\n\n  const adjective = pickRandom([\n    'exciting', 'notable', 'epic', 'new', 'fancy',\n    'great', 'cool', 'fresh', 'funky', 'clever'\n  ]);\n\n  const noun = (options.object || pickRandom([\n    'concept', 'idea', 'thought', 'topic', 'subject'\n  ])) + (options.plural ? 's' : '');\n\n  return `My ${adjective} ${noun}`;\n\n};\n\nconst _merge = (dest, src) => {\n\n  if (typeof dest !== 'object') { dest = {}; }\n\n  for (let p in src) {\n    if (src.hasOwnProperty(p)) {\n      if (src[p] != null) { // skip null or undefined\n        dest[p] = (typeof src[p] === 'object'\n          ? _merge(dest[p], src[p])\n          : src[p]); // primitive type, stop recursion\n      }\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Merges `src` into `dest` which means that the merge transforms\n * the `dest` object itself. If src and dest both have the same\n * property path, src does only replace the primitive data type\n * at the end of the path.\n *\n * @todo Should null really be skipped or treated as value?\n *\n * @param {Object} dest - The destination object.\n * @param {...Object} sources - At least one object to merge into `dest`.\n * @return {Object} The original `dest` object.\n */\nexport const merge = (dest, ...sources) => {\n\n  // start the merging; i = 1 since first argument is the destination\n  for (let i = 0, l = sources.length; i < l; i++) {\n    const src = sources[i];\n    if (src != null && typeof src === 'object') {\n      dest = _merge(dest, src);\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Adds or removes listeners from the target in capture or\n * non-capture (bubbling) mode.\n *\n * @param {string} task - Either \"add\" or \"remove\". Make sure to\n *     always call add and remove with *excatly* the same listeners\n *     Note: if you use bind, you change the function object.\n * @param {Element} target - The element to attach or remove the\n *     listener to or from.\n * @param {Object<string, (Function|Array)>} listeners - The key is\n *     the event name and the value is either a handler function\n *     or an array where the first index is the handler function and\n *     the second is a boolean that specifies whether to use capture\n *     or not.\n * @param {boolean} [isCapt=false] - Whether to run the handler in\n *     bubbling or capturing phase.\n */\nexport const setDomListeners = (task, target, listeners, isCapt) => {\n\n  isCapt = (typeof isCapt === 'boolean' ? isCapt : false);\n  task = task + 'EventListener';\n\n  for (let event in listeners) {\n\n    const l = listeners[event];\n\n    if (typeof l === 'function') {\n\n      target[task](event, l, isCapt);\n    } else { // expect Array\n\n      target[task](event, l[0], (typeof l[1] === 'boolean' ? l[1] : isCapt));\n    }\n\n  }\n\n};\n\n/**\n * Removes all child nodes of a DOM element. This includes element\n * and non-element objects.\n */\nexport const removeDOMChildNodes = el => {\n\n  for (let i = el.childNodes.length; i--;) {\n    el.removeChild(el.childNodes[i]);\n  }\n\n};\n\n/**\n * Implementation of the algebraic modulus operation.\n *\n * In javascript '%' is really a remainder operator, not a modulus.\n * Algebraically speaking, a modulus operation always yields\n * positive results, while '%' in js can yield negative results.\n *\n * Note: divident mod divisor\n *\n * @param {number} divident\n * @param {number} divisor\n * @return {number}\n */\nexport const mod = (divident, divisor) => {\n\n  const remainder = divident % divisor;\n\n  return Math.floor(remainder >= 0 ? remainder : remainder + divisor);\n\n};\n\n/**\n * Maps a coordinate to the nearest raster coordinate.\n *\n * @param {number} x\n * @param {number} y\n * @param {number} raster\n * @return {{x: number, y: number}}\n */\nexport const getNearestRasterPosition = ({ x, y }, raster) => {\n\n  const rasterHalf = raster / 2;\n\n  // calculate distances to previous raster lines\n  const distPrevX = mod(x, raster);\n  const distPrevY = mod(y, raster);\n\n  return {\n    x: distPrevX < rasterHalf ? x - distPrevX : x - distPrevX + raster,\n    y: distPrevY < rasterHalf ? y - distPrevY : y - distPrevY + raster\n  };\n\n};\n\n/**\n * Force early binding of functions to this context.\n *\n * @param context the context to bind this function to (typically `this`)\n * @param {Array<string>} fnNames - The prototype function names\n *     to bind to this context.\n */\nexport const bindTo = (context, fnNames) => {\n\n  for (let i = fnNames.length; i--;) {\n    const fn = context[fnNames[i]];\n    context[fnNames[i]] = fn.bind(context);\n  }\n\n};\n\n/**\n * Returns true if both objects have the same properties\n * @param obj1\n * @param obj2\n */\nexport const isEqual = (obj1, obj2) => identity(obj1) === identity(obj2);\n"],"sourceRoot":"../../../../../../../src/plugins"}