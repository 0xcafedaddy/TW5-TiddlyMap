{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/tmap.js"],"names":["_vis","require","_exception","_basic","basicUtils","_wiki","wikiUtils","getLabel","tiddler","aliasField","tObj","getTiddler","fields","title","getIterableCollection","col","_vis2","default","DataSet","get","getValues","Array","isArray","result","keys","Object","i","length","push","convert","outputType","_typeof","InvalidArgumentException","mapper","array","hashmap","returnType","dataset","getDataUri","type","isForceBase64","imgTObj","body","text","encoding","$tw","config","contentTypeInfo","replace","hasSubString","getEdgeTypeMatches","filter","arguments","undefined","titles","window","$tm","path","edgeTypes","iterator","removePrefix","eTyFiltAutoPrefix","getMatches","isEdgeTypeMatch","groupByProperty","prop","makeHashMap","item","val","getPrettyFilter","expr","operands","match","re","trim","stringsPlusDummies","split","operandIndex","parts","l","rasterSize","color","parseInt","canvas","join","width","scaleFactor","height","offsetLeft","viewPosition","x","offsetTop","y","context","moveTo","lineTo","drawRaster","strokeStyle","inserted","removed","id","ltNew","ltOld","isEqual","refreshDataSet","ds","remove","updated","withoutPosition","add","getId","getDublicates","tiddlers","getTiddlersWithField","limit","getTiddlerRef","key","index","keyOfItemWithProperty","keysOfItemsWithProperty","lookupKey","lookupTable","idx","getLookupTable","getSnapshotTitle","viewLabel","Date","toDateString"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/tmap.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport vis                  from '$:/plugins/felixhayashi/vis/vis.js';\nimport {\n  EnvironmentError,\n  InvalidArgumentException,\n}                           from '$:/plugins/felixhayashi/tiddlymap/js/exception';\nimport * as basicUtils      from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic';\nimport * as wikiUtils       from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki';\n\n/**\n * @param {Tiddler} tiddler\n * @param {string} aliasField - A tiddler field that contains an\n *     alternative title (e.g. \"caption\").\n * @return {string|undefined} If the `aliasField` exists and is not\n *     empty, the value of the `aliasField` otherwise the tiddler's\n *     title or undefined if the tiddler doesn't exist.\n */\nexport const getLabel = (tiddler, aliasField) => {\n  const tObj = wikiUtils.getTiddler(tiddler);\n  return (tObj && tObj.fields[aliasField]? tObj.fields[aliasField] : tObj.fields.title);\n};\n\n/**\n * This function will return a collection object whose data can be\n * via `Object.keys(col)` in a loop.\n *\n * @param {Collection} col - A collection\n * @return {Hashmap} The iterable object.\n */\nexport const getIterableCollection = col => col instanceof vis.DataSet ? col.get() : col;\n\n/**\n * Extract all the values from a collection. If `col` is an object,\n * only properties are considered that are its own and iterable.\n *\n * @param {Collection} col\n * @return {Array} An array\n */\nexport const getValues = col => {\n\n  if (Array.isArray(col)) {\n\n    return col; // bounce back.\n\n  } else if (col instanceof vis.DataSet) { // a dataset\n\n    return col.get({ returnType: 'Array' });\n\n  }\n\n  const result = [];\n  const keys = Object.keys(col);\n  for (let i = keys.length; i--;) {\n    result.push(col[keys[i]]);\n  }\n\n  return result;\n\n};\n\n/**\n * Transforms a collection of a certain type into a collection of\n * another type.\n *\n * **Attention**: When trying to convert an array into a object, the\n * array will be simply bounced back. Let's hope no one added enumerable\n * properties to Array.prototype :)\n *\n * @param {Collection} col - The collection to convert.\n * @param {CollectionTypeString} [outputType=\"dataset\"] - The output type.\n * @return {Collection} A **new** collection of type `outputType`.\n */\nexport const convert = (col, outputType) => {\n\n  if (typeof col !== 'object') {\n    throw new InvalidArgumentException(col, outputType);\n  }\n\n  if (outputType === 'object') {\n    outputType = 'hashmap';\n  }\n\n  const mapper = {\n    array: col => getValues(col),\n    hashmap: col =>\n      col instanceof vis.DataSet ? col.get({ returnType: 'Object' }) : col,\n    dataset: col =>\n      col instanceof vis.DataSet ? col : (!Array.isArray(col) ? getValues(col) : new vis.DataSet(col))\n  };\n\n  return mapper[outputType](col);\n\n};\n\n/**\n * @param {Tiddler} tiddler\n * @param {string} [type]\n * @param {boolean} [isForceBase64]\n * @return {string}\n */\nexport const getDataUri = (tiddler, type, isForceBase64) => {\n\n  const imgTObj = wikiUtils.getTiddler(tiddler);\n  type = type || imgTObj.fields.type || 'image/svg+xml';\n  let body = imgTObj.fields.text;\n  let encoding = $tw.config.contentTypeInfo[type].encoding;\n\n  if (type === 'image/svg+xml') {\n\n    // see http://stackoverflow.com/questions/10768451/inline-svg-in-css\n    body = body.replace(/\\r?\\n|\\r/g, ' ');\n\n    if (!basicUtils.hasSubString('xmlns', body)) {\n      // @tiddlywiki it is bad to remove the xmlns attribute!\n\n      body = body.replace(/<svg/, '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n    }\n\n  }\n\n  if (isForceBase64 && encoding !== 'base64') {\n    encoding = 'base64';\n    body = window.btoa(body);\n  }\n\n  return `data:${type};${encoding},${body}`;\n\n};\n\n// @todo move this to environment\nconst eTyFiltAutoPrefix = '[all[]] ';\n\n/**\n *\n * @param filter\n * @param titles\n * @return {*}\n */\nexport const getEdgeTypeMatches = (filter = '', titles) => {\n\n  if (!titles) {\n    titles = wikiUtils.getTiddlersByPrefix(`${$tm.path.edgeTypes}/`, {\n      iterator: 'eachTiddlerPlusShadows',\n      removePrefix: true\n    });\n  }\n\n  if (titles != null && !Array.isArray(titles)) {\n    titles = Object.keys(titles);\n  }\n\n  return wikiUtils.getMatches(eTyFiltAutoPrefix + filter, titles);\n\n};\n\nexport const isEdgeTypeMatch = (title, filter = '') =>\n  wikiUtils.isMatch(title, eTyFiltAutoPrefix + (filter));\n\n/**\n *\n */\nexport const groupByProperty = (col, prop) => {\n\n  col = getIterableCollection(col);\n\n  const result = basicUtils.makeHashMap();\n  const keys = Object.keys(col);\n\n  for (let i in keys) {\n\n    const item = col[keys[i]];\n    const val = item[prop];\n\n    if (val == null) { // null or undefined\n\n      // @todo use exception class\n      throw 'Cannot group by property ' + prop;\n\n    } else {\n\n      if (!Array.isArray(result[val])) {\n        result[val] = [];\n      }\n      result[val].push(item);\n\n    }\n  }\n\n  return result;\n\n};\n\n/**\n * Turns the filter expression in a nicely formatted (but unusable)\n * text, making it easier to edit long filter expressions.\n *\n * @param {string} expr - A valid filter expression.\n * @result {string} A formatted (unusable) filter expression.\n */\nexport const getPrettyFilter = expr => {\n\n  // remove outer spaces and separate operands\n  expr = expr.trim().replace('][', '] [');\n\n  // regex to identify operands\n  const re = /[+-]?\\[.+?[\\]\\}\\>]\\]/g;\n\n  // get operands\n  const operands = expr.match(re);\n\n  // replace operands with dummies and trim again to avoid trailing spaces\n  expr = expr.replace(re, ' [] ').trim();\n\n  // turn it into an array\n  const stringsPlusDummies = expr.split(/\\s+/);\n\n  let operandIndex = 0;\n  const parts = [];\n  for (let i = 0, l = stringsPlusDummies.length; i < l; i++) {\n    parts[i] = (stringsPlusDummies[i] === '[]' ? operands[operandIndex++] : stringsPlusDummies[i]);\n  }\n\n  return parts.join('\\n');\n\n};\n\n/**\n * This function will draw a raster on the network canvas that will\n * adjust to the network's current scaling factor and viewport offset.\n *\n * @param {CanvasRenderingContext2D} context - The canvas's context\n *     passed by vis.\n * @param {number} scaleFactor - The current scale factor of the network.\n * @param {Object} viewPosition - Object with x and y that represent the\n *     current central focus point of the view.\n * @param {number} rasterSize - The size of the squares that are drawn.\n * @param {string} color - A string parsed as CSS color value.\n */\nexport const drawRaster = (context, scaleFactor, viewPosition, rasterSize, color) => {\n\n  rasterSize = parseInt(rasterSize) || 10;\n\n  const canvas = context.canvas;\n  const width = canvas.width / scaleFactor;\n  const height = canvas.width / scaleFactor;\n  const offsetLeft = viewPosition.x - (width / 2);\n  const offsetTop = viewPosition.y - (height / 2);\n\n  // draw vertical lines\n  for (let x = offsetLeft; x < width; x += rasterSize) {\n    context.moveTo(x, offsetTop);\n    context.lineTo(x, height);\n  }\n\n  // draw horizontal lines\n  for (let y = offsetTop; y < height; y += rasterSize) {\n    context.moveTo(offsetLeft, y);\n    context.lineTo(width, y);\n  }\n\n  context.strokeStyle = color || '#D9D9D9';\n  context.stroke();\n\n};\n\n/**\n * Updates a dataset.\n *\n * Note: never use the dataset's update() method, it does not properly remove\n * obsolete properties! – use remove and add instead.\n *\n * @param {vis.DataSet} [ds] - The dataset to be updated\n * @param {Hashmap<id, Node>} ltNew - Lookup table that contains the *new* set of nodes.\n */\nexport const refreshDataSet = (ds, ltNew) => {\n\n  const ltOld = ds.get({ returnType: 'Object' });\n\n  const inserted = [];\n  const updated = [];\n  const withoutPosition = [];\n  const removed = [];\n\n  for (let id in ltNew) {\n\n    if (ltOld[id]) { // element already exists in graph\n\n      if (basicUtils.isEqual(ltOld[id], ltNew[id])) {\n        // simply keep element\n        continue;\n      }\n\n      updated.push(id);\n      ds.remove(id);\n\n    } else {\n\n      inserted.push(id);\n\n    }\n\n    if (!ltNew[id].x) {\n      withoutPosition.push(id);\n    }\n\n    ds.add(ltNew[id]);\n  }\n\n  for (let id in ltOld) {\n    if (!ltNew[id]) {\n      removed.push(id);\n      ds.remove(id);\n    }\n  }\n\n  return {\n    withoutPosition,\n    inserted,\n    updated,\n    removed,\n  };\n\n};\n\n/**\n * Returns the tmap id that is stored in a designated field in the tiddler.\n *\n * @param tiddler\n * @return {string} the tmap id of this tiddler\n */\nexport const getId = tiddler => wikiUtils.getTiddler(tiddler).fields['tmap.id'];\n\n/**\n * Returns all other tiddlers that have the same tmap.id field entry.\n *\n * Note: typically tiddlers don't have the same id assigned, however,\n * this can happen when tiddlers are imported or cloned.\n *\n * @param {Tiddler} tiddler\n * @return {array<TiddlerReference>} a list of tiddlers with the same id as the\n *    provided tiddler (excluding the provided tiddler itself).\n */\nexport const getDublicates = tiddler => {\n\n  const id = getId(tiddler);\n\n  if (!id) {\n\n    return [];\n\n  }\n\n  const tiddlers = wikiUtils.getTiddlersWithField('tmap.id', id, {limit: 2});\n  delete tiddlers[wikiUtils.getTiddlerRef(tiddler)];\n\n  return Object.keys(tiddlers);\n\n};\n\n/**\n * Function that searches an array for an object with a property\n * having a certain value.\n *\n * Attention: Not the item itself but the item's key is returned.\n *\n * @param {Collection} col - The collection to search in.\n * @param {string} key - The property name to look for.\n * @param {*} [val] - An optional value that the object's property must have\n *     in order to match.\n * @param {number} [limit] - An optional result limit (>0) to stop the search.\n * @return {Array<Id>} An array containing the indeces of matching items.\n */\nexport const keysOfItemsWithProperty = (col, key, val, limit) => {\n\n  col = getIterableCollection(col);\n\n  const keys = Object.keys(col);\n  const result = [];\n\n  limit = (typeof limit === 'number' ? limit : keys.length);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const index = keys[i];\n    if (typeof col[index] === 'object' && col[index][key]) {\n      if (!val || col[index][key] === val) {\n        result.push(index);\n        if (result.length === limit) {\n          break;\n        }\n      }\n    }\n  }\n\n  return result;\n\n};\n\n/**\n *\n * @param col\n * @param key\n * @param val\n * @return {*}\n */\nexport const keyOfItemWithProperty = (col, key, val) =>\n  keysOfItemsWithProperty(col, key, val, 1)[0];\n\n/**\n * In a collection where all elements have a **distinct** property\n * `lookupKey`, use the value of each element's `lookupKey` as key\n * to identify the object. If no property `lookupKey` is specified,\n * the collection's values are used as keys and `true` is used as value,\n * however, if the used keys are not strings, an error is thrown.\n *\n * @param {Collection} col - The collection for which to create a lookup table.\n * @param {string} [lookupKey] - The property name to use as index in\n *     the lookup table. If not specified, the collection values are tried\n *     to be used as indeces.\n * @return {Hashmap} The lookup table.\n */\nexport const getLookupTable = (col, lookupKey) => {\n\n  col = getIterableCollection(col);\n\n  const lookupTable = basicUtils.makeHashMap();\n  const keys = Object.keys(col);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n\n    const key = keys[i];\n    const idx = (lookupKey ? col[key][lookupKey] : col[key]);\n    const type = typeof idx;\n\n    if ((type === 'string' && idx !== '') || type === 'number') {\n      if (!lookupTable[idx]) { // doesn't exist yet!\n        lookupTable[idx] = (lookupKey ? col[key] : true);\n        continue;\n      }\n    }\n\n    // @todo use exception class\n    throw new Error(`Cannot use \"${idx}\" as lookup table index`);\n\n  }\n\n  return lookupTable;\n\n};\n\n/**\n * Alias for {@link getLookupTable}\n */\nexport const getArrayValuesAsHashmapKeys = getLookupTable;\n\n/**\n *\n * @param viewLabel\n * @param type\n */\nexport const getSnapshotTitle = (viewLabel, type) =>\n  `Snapshot – ${viewLabel} (${new Date().toDateString()}). ${type || 'png'}`;\n"],"sourceRoot":"../../../../../../../src/plugins"}