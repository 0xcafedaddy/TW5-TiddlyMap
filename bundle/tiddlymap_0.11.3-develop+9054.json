[
  {
    "title": "$:/plugins/felixhayashi/tiddlymap",
    "description": "TiddlyMap – Map drawing and topic visualization for your wiki",
    "author": "Felix Küppers",
    "version": "0.11.3-develop+9054",
    "released": "Sun, 07 Aug 2016 22:28:44 GMT",
    "core-version": ">=5.1.13",
    "source": "https://github.com/felixhayashi/TW5-TiddlyMap",
    "type": "application/json",
    "plugin-type": "plugin",
    "list": "readme license",
    "dependents": "$:/plugins/felixhayashi/vis",
    "depends": "$:/plugins/felixhayashi/vis",
    "suggested": "$:/plugins/felixhayashi/topstoryview",
    "text": "{\n    \"tiddlers\": {\n        \"$:/plugins/felixhayashi/tiddlymap/layout\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/layout\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"tags\": [\n                \"$:/tags/Stylesheet\"\n            ],\n            \"text\": \"\\\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline \\n\\n@charset \\\"UTF-8\\\";\\n/********************************************************************\\n * README                                                           \\n ********************************************************************\\n * \\n * If you add some non-valid css string that won't compile and \\n * unquote also doesn't help, do the following: in this stylesheet,\\n * add a placeholder of the form __yourVariable__ at the point where\\n * you need the string to be inserted. Then visit the gulpfile.js\\n * file and add a replace instruction for your variable so it will\\n * be replaced after the sass compiler has finished.\\n * \\n * Careful of the variable scope. Variables defined in partials\\n * are visible everywhere https://gist.github.com/matyus/4339721.\\n * \\n *******************************************************************/\\n/**\\n * Returns a makedatauri macro\\n */\\n/**\\n * Do not allow blurred background for dialogs\\n * see: https://github.com/Jermolene/TiddlyWiki5/issues/1893\\n */\\nbody .tc-page-container-wrapper.tc-modal-displayed {\\n  -webkit-filter: inherit;\\n  -moz-filter: inherit;\\n  filter: inherit; }\\n\\nbody .tc-modal-wrapper {\\n  z-index: 1010; }\\n  body .tc-modal-wrapper .tc-modal-header svg {\\n    vertical-align: sub; }\\n  body .tc-modal-wrapper .tc-modal-header h3 {\\n    line-height: 10px; }\\n  body .tc-modal-wrapper .tc-modal-body {\\n    min-height: 250px;\\n    max-height: 70vh;\\n    padding-top: 0px;\\n    padding-bottom: 0px;\\n    overflow: auto; }\\n  body .tc-modal-wrapper .tc-modal-footer {\\n    padding: 8px; }\\n    body .tc-modal-wrapper .tc-modal-footer .tmap-dialog-button {\\n      font-weight: bold; }\\n    body .tc-modal-wrapper .tc-modal-footer .tmap-hidden-close-button {\\n      display: none; }\\n\\ntable.tmap-table tr, .tc-modal-body table.tmap-config-table tr {\\n  /*\\n    &:hover {\\n      background-color: #FFFFF3;\\n    }\\n*/ }\\n  table.tmap-table tr:nth-child(odd), .tc-modal-body table.tmap-config-table tr:nth-child(odd) {\\n    background-color: #F0F0F0; }\\n  table.tmap-table tr:nth-child(even), .tc-modal-body table.tmap-config-table tr:nth-child(even) {\\n    background-color: #FFFFFF; }\\n\\n.tmap-save-canvas-preview {\\n  text-align: center; }\\n  .tmap-save-canvas-preview img {\\n    background-color: white;\\n    border: 1px solid lightgray;\\n    max-width: 100%;\\n    max-height: 100px; }\\n\\n.tmap-list-separator {\\n  display: block;\\n  background-color: #efefef;\\n  margin: 10px 0 5px 0;\\n  cursor: default;\\n  border-bottom: 1px dotted gray;\\n  font-weight: bold;\\n  font-size: 0.8em; }\\n\\n.tmap-unicode-icon {\\n  width: 1em;\\n  display: inline-block;\\n  text-align: center;\\n  color: black; }\\n\\nhtml .tmap-link {\\n  color: #5778D8; }\\n  html .tmap-link:hover {\\n    color: white;\\n    background: #5778D8; }\\n\\nhtml .tmap-small-list, html .tmap-smaller-list, html .tmap-very-small-list {\\n  overflow: auto;\\n  min-height: 2em;\\n  max-height: 9em;\\n  display: block; }\\n\\nhtml .tmap-smaller-list {\\n  max-height: 7em; }\\n\\nhtml .tmap-very-small-list {\\n  max-height: 5empx; }\\n\\nhtml .tc-tiddler-controls button.tmap-active-button svg {\\n  fill: #888888; }\\n\\nhtml #tmap-node-filter-dialog #tmap-filter-tips {\\n  font-size: 0.8em; }\\n\\nhtml #tmap-node-filter-dialog textarea {\\n  height: 100px;\\n  max-height: 300px;\\n  overflow: auto;\\n  width: 100%;\\n  font-size: 11px;\\n  font-family: \\\"Courier New\\\", Courier, monospace; }\\n\\n@media (max-width: {{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}}) {\\n  .tc-sidebar-scrollable .tmap-desktop-editor .tmap-widget:not(.tmap-fullscreen) {\\n    display: none; } }\\n\\n@media (min-width: {{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}}) {\\n  .tc-sidebar-scrollable .tmap-mobile-editor {\\n    display: none; }\\n  .tc-modal-wrapper {\\n    z-index: 1010; }\\n    .tc-modal-wrapper .tc-modal {\\n      boder: 1px solid #999999;\\n      left: calc(50% - 400px);\\n      width: 802px; }\\n    .tc-modal-wrapper .tc-modal-body {\\n      left: calc(50% - 400px);\\n      width: 800px; } }\\n\\n/**\\n * see https://developer.mozilla.org/en/docs/Web/CSS/animation\\n */\\n/*** Keyframes for animations *************************************/\\n@-o-keyframes fadein-keyframes {\\n  0% {\\n    opacity: 0; }\\n  100% {\\n    opacity: 1; } }\\n\\n@-moz-keyframes fadein-keyframes {\\n  0% {\\n    opacity: 0; }\\n  100% {\\n    opacity: 1; } }\\n\\n@-webkit-keyframes fadein-keyframes {\\n  0% {\\n    opacity: 0; }\\n  100% {\\n    opacity: 1; } }\\n\\n@keyframes flash fadein-keyframes {\\n  0% {\\n    opacity: 0; }\\n  100% {\\n    opacity: 1; } }\\n\\n@-o-keyframes fadeout-keyframes {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n@-moz-keyframes fadeout-keyframes {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n@-webkit-keyframes fadeout-keyframes {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n@keyframes flash fadeout-keyframes {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n.tmap-config-widget {\\n  background: #F0F0F0;\\n  padding: 5px;\\n  margin: 5px 0;\\n  box-sizing: border-box;\\n  display: block; }\\n  .tmap-config-widget .vis-network {\\n    display: none; }\\n  .tmap-config-widget .vis-configuration-wrapper {\\n    width: 100%; }\\n    .tmap-config-widget .vis-configuration-wrapper .vis-config-rangeinput {\\n      height: inherit;\\n      margin-left: 4px; }\\n    .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item {\\n      width: 100%;\\n      height: inherit;\\n      background: none;\\n      padding-left: 0px;\\n      left: 0; }\\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item.tmap-vis-config-item-active .vis-config-label::after {\\n        content: \\\"(inherited)\\\";\\n        position: absolute;\\n        display: inline-block;\\n        margin-left: 10px;\\n        -o-animation: fadein-keyframes 1s;\\n        -moz-animation: fadein-keyframes 1s;\\n        -webkit-animation: fadein-keyframes 1s;\\n        animation: fadein-keyframes 1s;\\n        content: \\\"✔\\\";\\n        color: green;\\n        font-weight: bold;\\n        font-size: 15px; }\\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item.tmap-vis-config-item-inactive .vis-config-label::after {\\n        /*\\n        @include marker;\\n        content: \\\"✔\\\";\\n        color: lightgray;\\n        position: absolute;\\n*/ }\\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item button.tmap-config-item-reset {\\n        vertical-align: top;\\n        margin-left: 5px; }\\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item .vis-config-range {\\n        width: 150px; }\\n        .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item .vis-config-range::-moz-range-track {\\n          width: 150px !important; }\\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item .vis-config-label {\\n        width: 150px; }\\n  .tmap-config-widget::after {\\n    clear: both;\\n    content: \\\"\\\";\\n    display: block; }\\n\\n/*\\n$color-picker-height: 200;\\ndiv div.vis-color-picker {\\n  div.vis-color {\\n    width: $color-picker-height + px;\\n    height: $color-picker-height + px;\\n  }\\n  \\n  div.vis-brightness {\\n    top: ($color-picker-height + 30) + px;\\n  }\\n  \\n  div.vis-label.vis-brightness {\\n    top: ($color-picker-height + 43) + px;\\n  }\\n  \\n  div.vis-label.vis-opacity {\\n    top: 338px\\n  }\\n  \\n  div.vis-opacity {\\n    top: 351px;\\n  }\\n  div.vis-initial-color, vis-new-color {\\n    top: 381px;\\n  }\\n  \\n  div.vis-button {\\n    top: 411px;\\n  }\\n\\n}\\n*/\\n.tmap-flash-message {\\n  border: 1px solid lightgray;\\n  padding: 5px;\\n  margin: 6px 0;\\n  display: block;\\n  color: #333333; }\\n  .tmap-flash-message.tmap-info, .tmap-flash-message.tmap-plain, .tmap-flash-message.tmap-neutral {\\n    background: #F0F0F0; }\\n    .tmap-flash-message.tmap-info::before, .tmap-flash-message.tmap-plain::before, .tmap-flash-message.tmap-neutral::before {\\n      content: \\\"i\\\";\\n      display: inline-block;\\n      border-radius: 50%;\\n      width: 0.8em;\\n      border: 2px solid;\\n      font-family: serif;\\n      text-align: center;\\n      height: 0.8em;\\n      font-weight: bold;\\n      line-height: 0.8em;\\n      vertical-align: text-top;\\n      margin-right: 2px; }\\n  .tmap-flash-message.tmap-valid, .tmap-flash-message.tmap-success {\\n    background: #D1EED4; }\\n    .tmap-flash-message.tmap-valid::before, .tmap-flash-message.tmap-success::before {\\n      content: \\\"i\\\";\\n      display: inline-block;\\n      border-radius: 50%;\\n      width: 0.8em;\\n      border: 2px solid;\\n      font-family: serif;\\n      text-align: center;\\n      height: 0.8em;\\n      font-weight: bold;\\n      line-height: 0.8em;\\n      vertical-align: text-top;\\n      margin-right: 2px; }\\n  .tmap-flash-message.tmap-warning {\\n    background: #FFF6D1; }\\n    .tmap-flash-message.tmap-warning::before {\\n      content: \\\"\\\";\\n      display: inline-block;\\n      background: url(<<tmap \\\"datauri\\\" \\\"$:/core/images/warning\\\" \\\"\\\">>);\\n      display: inline-block;\\n      width: 1em;\\n      height: 1em;\\n      background-size: 100% 100%;\\n      vertical-align: text-top;\\n      margin-right: 2px; }\\n  .tmap-flash-message.tmap-malformed, .tmap-flash-message.tmap-invalid, .tmap-flash-message.tmap-danger {\\n    background: #EED5D1; }\\n    .tmap-flash-message.tmap-malformed::before, .tmap-flash-message.tmap-invalid::before, .tmap-flash-message.tmap-danger::before {\\n      content: \\\"\\\";\\n      display: inline-block;\\n      background: url(<<tmap \\\"datauri\\\" \\\"$:/core/images/warning\\\" \\\"\\\">>);\\n      display: inline-block;\\n      width: 1em;\\n      height: 1em;\\n      background-size: 100% 100%;\\n      vertical-align: text-top;\\n      margin-right: 2px; }\\n\\n.tmap-widget {\\n  background: #FFFFFF;\\n  width: auto;\\n  position: relative;\\n  border: 1px dotted lightgray;\\n  padding: 2px;\\n  color: #666666;\\n  display: block; }\\n  .tmap-widget.tmap-click-to-use:not(.tmap-fullscreen) .vis-network:not(.vis-active) {\\n    cursor: pointer; }\\n    .tmap-widget.tmap-click-to-use:not(.tmap-fullscreen) .vis-network:not(.vis-active) .vis-navigation {\\n      display: none; }\\n    .tmap-widget.tmap-click-to-use:not(.tmap-fullscreen) .vis-network:not(.vis-active):hover:before {\\n      color: gray;\\n      background: white;\\n      content: \\\"Click to use\\\";\\n      font-size: 14px;\\n      font-weight: bold;\\n      right: calc(50% - 65px - 5px);\\n      position: absolute;\\n      text-align: center;\\n      top: calc(50% - 14px - 5px);\\n      width: 130px;\\n      z-index: 2000;\\n      padding: 5px;\\n      pointer-events: none;\\n      background-color: rgba(255, 255, 255, 0.3); }\\n  .tmap-widget .tmap-loading-bar {\\n    display: none;\\n    position: absolute;\\n    text-align: center;\\n    font-size: 2em;\\n    padding: 10px;\\n    top: 50%;\\n    background: rgba(245, 245, 245, 0.5);\\n    z-index: 1;\\n    width: 250px;\\n    margin: auto;\\n    left: 0px;\\n    right: 0px; }\\n  .tmap-widget .tmap-vis-graph {\\n    height: calc(100% - 35px); }\\n  .tmap-widget.tmap-no-buttons .vis-navigation {\\n    display: none; }\\n  .tmap-widget.tmap-advanced-editor .tmap-topbar {\\n    background: #d6d9d8; }\\n    .tmap-widget.tmap-advanced-editor .tmap-topbar .tmap-active-button {\\n      color: #488DCD; }\\n      .tmap-widget.tmap-advanced-editor .tmap-topbar .tmap-active-button svg {\\n        fill: #488DCD; }\\n    .tmap-widget.tmap-advanced-editor .tmap-topbar .tmap-neigh-scope-button {\\n      font-size: 1.5em;\\n      vertical-align: bottom; }\\n  .tmap-widget .tmap-menu-bar {\\n    width: 100%; }\\n  .tmap-widget .tmap-topbar {\\n    background: #F5F5F5;\\n    border-bottom: 1px solid lightgray;\\n    padding: 3px 5px;\\n    height: 35px;\\n    position: relative; }\\n    .tmap-widget .tmap-topbar .tmap-view-label {\\n      width: 100%;\\n      text-align: center;\\n      font-weight: bold;\\n      padding-top: 3px; }\\n    .tmap-widget .tmap-topbar .tmap-focus-button {\\n      position: absolute;\\n      right: 10px; }\\n      .tmap-widget .tmap-topbar .tmap-focus-button input {\\n        width: 140px; }\\n    .tmap-widget .tmap-topbar .tmap-search-dropdown {\\n      position: relative; }\\n      .tmap-widget .tmap-topbar .tmap-search-dropdown .tc-drop-down {\\n        position: absolute;\\n        z-index: 999;\\n        right: 0px; }\\n    .tmap-widget .tmap-topbar [hidden] {\\n      display: none; }\\n    .tmap-widget .tmap-topbar select {\\n      width: 30%;\\n      max-width: 200px;\\n      word-wrap: initial;\\n      padding: 0px; }\\n    .tmap-widget .tmap-topbar button {\\n      line-height: inherit;\\n      color: #666666; }\\n    .tmap-widget .tmap-topbar > * {\\n      display: inline-block; }\\n    .tmap-widget .tmap-topbar .tmap-separator:after {\\n      color: #bdbdbd;\\n      margin: 3px;\\n      content: \\\" | \\\"; }\\n    .tmap-widget .tmap-topbar .tc-edit-add-tag .tc-add-tag-name input {\\n      width: 70%; }\\n    .tmap-widget .tmap-topbar .tc-sidebar-header {\\n      text-shadow: none; }\\n    .tmap-widget .tmap-topbar .tc-edit-tags {\\n      border: none;\\n      padding: inherit;\\n      box-shadow: none; }\\n\\n.tmap-widget.tmap-static-mode .tmap-topbar {\\n  height: initial; }\\n\\n.tmap-widget.tmap-static-mode .tmap-vis-graph {\\n  text-align: center;\\n  cursor: not-allowed; }\\n  .tmap-widget.tmap-static-mode .tmap-vis-graph:not(.tmap-graph-placeholder):hover::before {\\n    box-shadow: 10px 10px 5px lightgray;\\n    color: gray;\\n    background: white;\\n    content: \\\"Static\\\";\\n    font-size: 18px;\\n    font-weight: bold;\\n    left: 50%;\\n    margin-left: -100px;\\n    position: absolute;\\n    text-align: center;\\n    top: 50px;\\n    width: 200px;\\n    z-index: 2000;\\n    padding: 5px;\\n    pointer-events: none; }\\n  .tmap-widget.tmap-static-mode .tmap-vis-graph.tmap-graph-placeholder::before {\\n    content: \\\"No Preview\\\";\\n    display: block;\\n    text-align: center;\\n    padding: 20px; }\\n\\n.tmap-widget .tc-drop-down {\\n  min-width: 170px;\\n  max-width: 210px;\\n  padding: 5px;\\n  margin: 5px 0; }\\n  .tmap-widget .tc-drop-down button, .tmap-widget .tc-drop-down a {\\n    padding: 0 2px;\\n    text-decoration: none; }\\n    .tmap-widget .tc-drop-down button:hover, .tmap-widget .tc-drop-down a:hover {\\n      color: #ffffff; }\\n    .tmap-widget .tc-drop-down button svg, .tmap-widget .tc-drop-down a svg {\\n      vertical-align: middle; }\\n\\n.tmap-widget .tc-block-dropdown {\\n  width: 370px;\\n  min-width: 370px;\\n  padding: 5px;\\n  margin: 15px 0 0 -370px; }\\n  .tmap-widget .tc-block-dropdown a {\\n    display: inline;\\n    padding: 0px; }\\n\\n.tmap-widget.tmap-plain-design {\\n  border: none;\\n  padding: 0px; }\\n  .tmap-widget.tmap-plain-design .tmap-topbar {\\n    display: none; }\\n\\n.tc-sidebar-scrollable .tmap-widget {\\n  position: absolute;\\n  min-height: 350px; }\\n\\n/*** vis ***********************************************************/\\n.tmap-widget div.vis-network .vis-edit-mode {\\n  height: 26px; }\\n\\n.tmap-widget div.vis-network .vis-manipulation {\\n  height: 34px;\\n  border-top: 1px solid #d6d9d8;\\n  background: rgba(245, 245, 245, 0.7); }\\n\\n.tmap-widget div.vis-network .vis-navigation .vis-button.tmap-button-enabled {\\n  right: 15px; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button.tmap-button-enabled.tmap-fullscreen-button {\\n    bottom: 90px;\\n    background-image: url(<<tmap \\\"datauri\\\" \\\"$:/plugins/felixhayashi/tiddlymap/media/fullscreen.png\\\" \\\"\\\">>); }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button.tmap-button-enabled.tmap-halfscreen-button {\\n    bottom: 130px;\\n    background-image: url(<<tmap \\\"datauri\\\" \\\"$:/plugins/felixhayashi/tiddlymap/media/halfscreen.png\\\" \\\"\\\">>); }\\n\\n.tmap-widget div.vis-network .vis-navigation .vis-button:hover {\\n  box-shadow: 0 0 3px 3px rgba(75, 75, 75, 0.3); }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover:before {\\n    background: beige;\\n    display: block;\\n    color: black;\\n    padding: 3px;\\n    position: relative;\\n    border: 1px solid lightgray;\\n    width: 80px;\\n    left: -100px;\\n    top: -50px;\\n    z-index: 1000;\\n    text-align: center; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-up:before {\\n    left: 30px;\\n    content: \\\"Scroll up\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-down:before {\\n    left: 30px;\\n    content: \\\"Scroll down\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-right:before {\\n    left: 30px;\\n    content: \\\"Scroll right\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-left:before {\\n    left: 30px;\\n    content: \\\"Scroll left\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-zoomOut:before {\\n    content: \\\"Zoom out\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-zoomIn:before {\\n    content: \\\"Zoom in\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-zoomExtends:before {\\n    content: \\\"Fit whole graph\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.tmap-fullscreen-button:before {\\n    content: \\\"Toggle Fullscreen\\\"; }\\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.tmap-halfscreen-button:before {\\n    content: \\\"Toggle Halfscreen\\\"; }\\n\\n.tc-dropzone > .tc-story-river .tmap-widget .vis-navigation .tmap-halfscreen-button {\\n  display: none; }\\n\\n.tc-dropzone > .tc-story-river .tmap-widget:not(.tmap-fullscreen) .vis-navigation .vis-button {\\n  display: none; }\\n\\n.tc-dropzone > .tc-story-river .tmap-widget:hover .vis-navigation .vis-button.tmap-fullscreen-button {\\n  display: block; }\\n\\n.tc-dropzone > .tc-story-river .tmap-widget:hover .vis-navigation .vis-button.vis-zoomExtends {\\n  display: block; }\\n\\n/*** Fullscreen ****************************************************/\\nbody.tmap-has-fullscreen-widget {\\n  overflow: hidden; }\\n  body.tmap-has-fullscreen-widget .tmap-widget.tmap-fullscreen {\\n    background: white !important;\\n    height: 100% !important;\\n    width: 100% !important;\\n    position: fixed !important;\\n    top: 0 !important;\\n    right: 0 !important;\\n    bottom: 0 !important;\\n    left: 0 !important;\\n    z-index: 999 !important;\\n    border: none !important;\\n    margin: 0 !important; }\\n  body.tmap-has-fullscreen-widget .tc-dropzone > *.tmap-has-fullscreen-widget {\\n    background: white !important;\\n    height: 100% !important;\\n    width: 100% !important;\\n    position: fixed !important;\\n    top: 0 !important;\\n    right: 0 !important;\\n    bottom: 0 !important;\\n    left: 0 !important;\\n    z-index: 999 !important;\\n    border: none !important;\\n    margin: 0 !important; }\\n  body.tmap-has-fullscreen-widget .tc-dropzone > *:not(.tmap-has-fullscreen-widget) {\\n    display: none; }\\n\\nbody.tmap-has-halfscreen-widget .tmap-widget.tmap-halfscreen {\\n  background: white !important;\\n  height: 100% !important;\\n  width: 100% !important;\\n  position: fixed !important;\\n  top: 0 !important;\\n  right: 0 !important;\\n  bottom: 0 !important;\\n  left: 0 !important;\\n  z-index: 999 !important;\\n  border: none !important;\\n  margin: 0 !important;\\n  position: absolute !important;\\n  border-left: 1px solid lightgray !important; }\\n\\n.tc-modal-footer .tmap-hidden-close-button {\\n  display: none; }\\n\\n.tmap-modal-content {\\n  position: relative;\\n  padding: 1em 0;\\n  padding-top: 0; }\\n  .tmap-modal-content table tr td {\\n    vertical-align: top; }\\n  .tmap-modal-content :not(pre) > code {\\n    padding: 1px;\\n    font-size: 0.9em;\\n    position: relative;\\n    top: -1px; }\\n  .tmap-modal-content :not(pre) > code {\\n    color: #666666; }\\n  .tmap-modal-content .tc-tab-set .tc-tab-content {\\n    margin-top: 0.5em; }\\n  .tmap-modal-content .tc-image-button {\\n    font-size: 14px; }\\n  .tmap-modal-content fieldset {\\n    margin: 0px; }\\n    .tmap-modal-content fieldset legend {\\n      font-weight: bold; }\\n\\n.tc-modal-body .tmap-modal-editor > p {\\n  margin: 0px; }\\n\\n.tc-modal-body .tmap-modal-editor .tmap-template-select select {\\n  width: 50%; }\\n\\n.tc-modal-body .tmap-modal-editor .tc-tiddler-frame {\\n  margin: auto;\\n  width: auto; }\\n  .tc-modal-body .tmap-modal-editor .tc-tiddler-frame .tc-tiddler-controls {\\n    display: none; }\\n  .tc-modal-body .tmap-modal-editor .tc-tiddler-frame .tc-tiddler-title {\\n    display: none; }\\n\\n.tc-modal-body table {\\n  margin: 6px 0;\\n  border: none;\\n  width: 100%; }\\n  .tc-modal-body table td, .tc-modal-body table th {\\n    border: 1px solid lightgray; }\\n  .tc-modal-body table.tmap-key-value-table th {\\n    width: 30%;\\n    background-color: #F0F0F0; }\\n  .tc-modal-body table.tmap-config-table.tmap-large-input tr td:last-child {\\n    width: 20%; }\\n  .tc-modal-body table.tmap-config-table.tmap-small-input tr td:last-child {\\n    width: 60%; }\\n  .tc-modal-body table.tmap-config-table tr td {\\n    border: none;\\n    vertical-align: top;\\n    padding: 5px; }\\n    .tc-modal-body table.tmap-config-table tr td:first-child {\\n      width: 15%; }\\n    .tc-modal-body table.tmap-config-table tr td:last-child {\\n      width: 40%; }\\n    .tc-modal-body table.tmap-config-table tr td input:not([type=radio]), .tc-modal-body table.tmap-config-table tr td textarea, .tc-modal-body table.tmap-config-table tr td select {\\n      width: 100%;\\n      /* prevents bad looking select boxes and wrapping in textareas */\\n      word-wrap: normal; }\\n    .tc-modal-body table.tmap-config-table tr td textarea {\\n      height: 100%; }\\n    .tc-modal-body table.tmap-config-table tr td .tmap-no-stretch input, .tc-modal-body table.tmap-config-table tr td .tmap-no-stretch textarea, .tc-modal-body table.tmap-config-table tr td .tmap-no-stretch select {\\n      width: auto; }\\n    .tc-modal-body table.tmap-config-table tr td div.tmap-button-wrapper {\\n      text-align: center; }\\n    .tc-modal-body table.tmap-config-table tr td .tmap-note {\\n      margin-top: 0.5em; }\\n    .tc-modal-body table.tmap-config-table tr td .tmap-description {\\n      font-style: italic; }\\n\\n#tmap-element-type-manager > div:first-child {\\n  height: 50vh;\\n  float: left;\\n  width: 21%;\\n  background: linear-gradient(90deg, whitesmoke 0%, white 50%); }\\n  #tmap-element-type-manager > div:first-child .tmap-searchbar {\\n    padding: 1em 0 0 0; }\\n    #tmap-element-type-manager > div:first-child .tmap-searchbar input {\\n      width: calc(100% - 36px); }\\n    #tmap-element-type-manager > div:first-child .tmap-searchbar button {\\n      width: 30px;\\n      float: right; }\\n  #tmap-element-type-manager > div:first-child ul {\\n    height: calc(100% - 65px);\\n    overflow: auto;\\n    margin-top: 1em;\\n    padding: 0; }\\n    #tmap-element-type-manager > div:first-child ul.no-bullets li {\\n      list-style: none; }\\n    #tmap-element-type-manager > div:first-child ul li {\\n      white-space: nowrap; }\\n      #tmap-element-type-manager > div:first-child ul li .tmap-ranking {\\n        width: 30px;\\n        display: inline-block; }\\n\\n#tmap-element-type-manager > div:last-child {\\n  height: 100%;\\n  width: calc(79% - 15px);\\n  float: right; }\\n  #tmap-element-type-manager > div:last-child .tc-tab-set .tc-tab-content {\\n    overflow: auto;\\n    height: 50vh; }\\n\\n.tmap-manage-node-types .tmap-edge-type-specific {\\n  display: none !important; }\\n\\n.tmap-manage-edge-types .tmap-node-type-specific {\\n  display: none !important; }\\n\\n.tmap-modal-fullscreen-editor .tc-tab-content p {\\n  margin: 1em 0; }\\n\\n.tmap-has-pending-template {\\n  background-color: #C1EDC4; }\\n\\n#tmap-search-table td {\\n  border: none;\\n  padding-left: 0px; }\\n  #tmap-search-table td:first-child {\\n    width: 30px; }\\n\\n#tmap-search-table b {\\n  display: inline-block;\\n  width: 40px;\\n  text-align: right; }\\n\\n#tmap-search-table ul {\\n  padding-left: 20px;\\n  margin: 1em 0 0 0; }\\n  #tmap-search-table ul li {\\n    list-style: inherit; }\\n  #tmap-search-table ul button {\\n    text-align: left; }\\n\\nbutton.tmap-go-back {\\n  margin-bottom: 1em;\\n  font-weight: bold; }\\n\\n.tmap-badges > span, .tmap-badge {\\n  background: gray;\\n  font-size: 11px;\\n  color: white;\\n  padding: 3px 4px;\\n  display: inline-block;\\n  font-weight: bold;\\n  border-radius: 2px;\\n  line-height: 1em;\\n  cursor: help; }\\n  .tmap-badges > span.tmap-red-flag, .tmap-badge.tmap-red-flag {\\n    background: red; }\\n\\n/**\\n * See http://stackoverflow.com/questions/3331353/transitions-on-the-display-property\\n */\\n.tmap-popup {\\n  display: none;\\n  position: absolute;\\n  opacity: 0;\\n  transition: opacity 0.3s ease; }\\n  .tmap-popup.tmap-popup-active {\\n    opacity: 1; }\\n\\n.tmap-tooltip {\\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\\n  min-width: 100px;\\n  min-height: 50px;\\n  max-width: <<tmap option config.sys.popups.width>>;\\n  max-height: <<tmap option config.sys.popups.height>>;\\n  padding: 5px;\\n  resize: both;\\n  overflow: auto;\\n  cursor: auto;\\n  font-family: verdana;\\n  font-size: 14px;\\n  background-color: #f5f4ed;\\n  border: 1px solid #808074;\\n  -moz-border-radius: 3px;\\n  -webkit-border-radius: 3px;\\n  border-radius: 3px; }\\n  .tmap-tooltip[style*=\\\"height\\\"] {\\n    max-height: none !important; }\\n  .tmap-tooltip[style*=\\\"width\\\"] {\\n    max-width: none !important; }\\n\\n.tmap-quick-connect {\\n  font-size: 0.7em; }\\n  .tmap-quick-connect p {\\n    padding-left: 0;\\n    padding-right: 0; }\\n  .tmap-quick-connect .tc-drop-down {\\n    padding: 5px;\\n    width: 250px;\\n    white-space: normal;\\n    line-height: 1em;\\n    position: absolute;\\n    z-index: 1000;\\n    right: 50px;\\n    background: linear-gradient(45deg, whitesmoke 0%, white 50%, whitesmoke 100%); }\\n    .tmap-quick-connect .tc-drop-down:first-child {\\n      padding-top: 0;\\n      margin-top: 0; }\\n    .tmap-quick-connect .tc-drop-down .title {\\n      margin: 1.5em 0 0.5em 0;\\n      font-weight: bold;\\n      color: gray; }\\n    .tmap-quick-connect .tc-drop-down select {\\n      width: 80px;\\n      word-wrap: initial; }\\n    .tmap-quick-connect .tc-drop-down table {\\n      width: 100%;\\n      border: none;\\n      margin: 0.5em 0; }\\n      .tmap-quick-connect .tc-drop-down table td, .tmap-quick-connect .tc-drop-down table th {\\n        padding: 3px 3px 3px 0;\\n        vertical-align: middle;\\n        font-weight: normal;\\n        border: none; }\\n        .tmap-quick-connect .tc-drop-down table td table, .tmap-quick-connect .tc-drop-down table th table {\\n          margin: 0; }\\n    .tmap-quick-connect .tc-drop-down .tmap-quick-connect-search-bar, .tmap-quick-connect .tc-drop-down .tmap-quick-connect-existing-bar {\\n      background: #F1F1F1;\\n      margin-top: 0;\\n      border-bottom: 1px solid #D5D5D5;\\n      border-top: 1px solid #D5D5D5; }\\n    .tmap-quick-connect .tc-drop-down table.tmap-quick-connect-search-bar td, .tmap-quick-connect .tc-drop-down th {\\n      padding: 5px; }\\n    .tmap-quick-connect .tc-drop-down .tmap-quick-connect-existing-bar {\\n      padding: 5px; }\\n    .tmap-quick-connect .tc-drop-down .tmap-connection-table th, .tmap-quick-connect .tc-drop-down .tmap-connection-table td {\\n      text-align: left;\\n      padding: 1px 1px 1px 0; }\\n    .tmap-quick-connect .tc-drop-down .tmap-connection-table button {\\n      width: 20px;\\n      padding: 0px; }\\n    .tmap-quick-connect .tc-drop-down .tmap-scroll-table {\\n      height: 120px;\\n      overflow: auto;\\n      display: block; }\\n    .tmap-quick-connect .tc-drop-down hr {\\n      border: 0;\\n      height: 0;\\n      border-top: 1px solid rgba(0, 0, 0, 0.1);\\n      border-bottom: 1px solid rgba(255, 255, 255, 0.3); }\\n    .tmap-quick-connect .tc-drop-down a {\\n      display: inline;\\n      padding: 0;\\n      color: #5778d8;\\n      background: transparent; }\\n      .tmap-quick-connect .tc-drop-down a:hover {\\n        background: transparent;\\n        color: #5778d8;\\n        text-decoration: underline; }\\n    .tmap-quick-connect .tc-drop-down button {\\n      display: inline-block;\\n      padding: 0px 3px;\\n      text-align: center;\\n      color: #333333;\\n      line-height: 1.0; }\\n      .tmap-quick-connect .tc-drop-down button:hover {\\n        color: #ffffff; }\\n      .tmap-quick-connect .tc-drop-down button svg {\\n        fill: inherit; }\\n        .tmap-quick-connect .tc-drop-down button svg:hover {\\n          fill: #ffffff; }\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/Adapter\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Adapter\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = Adapter;\\n\\n/*** Imports *******************************************************/\\n\\nvar ViewAbstraction   = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\\");\\nvar EdgeType          = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar NodeType          = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/NodeType\\\");\\nvar utils             = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar vis               = require(\\\"$:/plugins/felixhayashi/vis/vis.js\\\");\\nvar getContrastColour = require(\\\"$:/core/modules/macros/contrastcolour.js\\\").run;\\n  \\n/***************************** CODE ********************************/\\n\\n/**\\n * This library acts as an abstraction layer above the tiddlywiki\\n * system. All the provided methods give the api-user the chance\\n * to interact with tiddlywiki as if it was a simple graph database.\\n * \\n * Everything that is related to retrieving or inserting nodes and\\n * edges is handled by the adapter class.\\n * \\n * You don't need to create your own instance of this class.\\n * The adapter service may be accessed from anywhere using\\n * `$tm.apapter`.\\n * \\n * @constructor\\n */\\nfunction Adapter() {\\n  \\n  this.visShapesWithTextInside = utils.getLookupTable([\\n      \\\"ellipse\\\", \\\"circle\\\", \\\"database\\\", \\\"box\\\", \\\"text\\\"\\n  ]);\\n  \\n  // hack to support\\n  // https://github.com/felixhayashi/TW5-TiddlyMap/issues/198\\n  this.isTransTypeEnabled = (typeof $tw.wiki.getTiddlerTranscludes\\n                             === \\\"function\\\");\\n                              \\n};\\n\\n/**\\n * This function will delete the specified edge object from\\n * the system.\\n *\\n * @param {Edge} edge - The edge to be deleted. The edge necessarily\\n *     needs to possess an `id` and a `from` property.\\n * @return {Edge} The deleted edge is returned.\\n */\\nAdapter.prototype.deleteEdge = function(edge) {\\n      \\n  return this._processEdge(edge, \\\"delete\\\");\\n  \\n};\\n  \\n/**\\n * Removes multiple edges from several stores.\\n * \\n * @param {EdgeCollection} edges - The edges to be deleted.\\n */\\nAdapter.prototype.deleteEdges = function(edges) {\\n  \\n  edges = utils.convert(edges, \\\"array\\\");\\n  for(var i = edges.length; i--;) {\\n    this.deleteEdge(edges[i]);\\n  }\\n  \\n};\\n  \\n/**\\n * Persists an edge by storing the vector (from, to, type).\\n * \\n * @param {Edge} edge - The edge to be saved. The edge necessarily\\n *     needs to possess a `to` and a `from` property.\\n * @return {Edge} The newly inserted edge.\\n */  \\nAdapter.prototype.insertEdge = function(edge) {\\n  \\n  return this._processEdge(edge, \\\"insert\\\");\\n  \\n};\\n\\n/**\\n * Private function to handle the insertion or deletion of an edge.\\n * It prepares the process arcoding to the action type and delegates\\n * the task to more specific functions.\\n * \\n * The edge type is optional!!\\n * \\n * @private\\n * @return {Edge} The processed edge.\\n */\\nAdapter.prototype.processEdge = function(edge, action) {\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Edge\\\", action, edge);\\n\\n  if(typeof edge !== \\\"object\\\" || !action || !edge.from) return;\\n  if(action === \\\"insert\\\" && !edge.to) return;\\n  \\n  // get from-node and corresponding tiddler\\n  var fromTRef = $tm.indeces.tById[edge.from];\\n  if(!fromTRef || !utils.tiddlerExists(fromTRef)) return;\\n\\n  var type = new EdgeType(edge.type);\\n  var tObj = utils.getTiddler(fromTRef);\\n  var namespace = type.namespace;\\n  \\n  if(namespace === \\\"tw-list\\\") {\\n    if(!edge.to) return;\\n    return this._processListEdge(tObj, edge, type, action);\\n\\n  } else if(namespace === \\\"tw-field\\\") {\\n    if(!edge.to) return;\\n    return this._processFieldEdge(tObj, edge, type, action);\\n    \\n  } else if(namespace === \\\"tw-body\\\") {\\n    return null; // cannot delete links\\n    \\n  } else { // edge has no special meaning\\n    return this._processTmapEdge(tObj, edge, type, action);\\n    \\n  }\\n\\n  return edge;\\n      \\n};\\n\\n/**\\n * This method handles insertion or deletion of tiddlymap edges that\\n * are stored as json using a tiddlymap structure.\\n * \\n * @param {Tiddler} tiddler - A tiddler reference or object that\\n *     represents the from part of the edge and will be used as store.\\n * @param {Edge} edge - The edge to be saved.\\n *     Required properties:\\n *     * In case of deletion: `id`.\\n *     * In case of insertion: `to`.\\n * @param {EdgeType} type - The type of the edge.\\n * @param {string} [action=delete] - Either \\\"insert\\\" or \\\"delete\\\".\\n * @return {Edge} The processed edge.\\n */\\nAdapter.prototype._processTmapEdge = function(tiddler, edge, type, action) {\\n  \\n  if(action === \\\"delete\\\" && !edge.id) return;\\n  \\n  // load\\n  var connections = utils.parseFieldData(tiddler, \\\"tmap.edges\\\", {});\\n  \\n  // transform\\n  if(action === \\\"insert\\\") {\\n    // assign new id if not present yet\\n    edge.id = edge.id || utils.genUUID();\\n    // add to connections object\\n    connections[edge.id] = { to: edge.to, type: type.id };\\n    // if type is not know, create it\\n    if(!type.exists()) {\\n      type.save();\\n    }\\n  } else { // delete\\n    delete connections[edge.id];\\n  }\\n  \\n  // save\\n  utils.writeFieldData(tiddler, \\\"tmap.edges\\\", connections, $tm.config.sys.jsonIndentation);\\n  \\n  return edge;\\n  \\n};\\n\\n\\n/**\\n * This method handles insertion or deletion of edges that are stored\\n * inside list fields.\\n * \\n * @param {Tiddler} tiddler - A tiddler reference or object that\\n *     represents the from part of the edge and will be used as store.\\n * @param {Edge} edge - The edge to be saved. Required properties: `to`.\\n * @param {EdgeType} type - The type of the edge.\\n * @param {string} [action=delete] - Either \\\"insert\\\" or \\\"delete\\\".\\n * @return {Edge} The processed edge.\\n */\\nAdapter.prototype._processListEdge = function(tiddler, edge, type, action) {\\n      \\n  // get the name without the private marker or the namespace\\n  var name = type.name;\\n  \\n  var tObj = utils.getTiddler(tiddler);\\n  var list = $tw.utils.parseStringArray(tiddler.fields[name]);\\n  // we need to clone the array since tiddlywiki might directly\\n  // returned the auto-parsed field value (as in case of tags, or list)\\n  // and this array would be read only!\\n  list = (list || []).slice()\\n  \\n  // transform\\n  var toTRef = $tm.indeces.tById[edge.to];\\n      \\n  if(action === \\\"insert\\\") {\\n    list.push(toTRef);\\n    if(!type.exists()) {\\n      type.save();\\n    }\\n  } else { // delete\\n    var index = list.indexOf(toTRef);\\n    if(index > -1) {\\n      list.splice(index, 1);\\n    }\\n  }\\n\\n  // save\\n  utils.setField(tObj, name, $tw.utils.stringifyList(list));\\n  \\n  return edge;\\n  \\n};\\n\\n/**\\n * This method handles insertion or deletion of an edge that\\n * is stored inside a field that can only hold one connection.\\n * \\n * @param {Tiddler} tiddler - A tiddler reference or object that\\n *     represents the from part of the edge and will be used as store.\\n * @param {Edge} edge - The edge to be saved. Required properties: `to`.\\n * @param {EdgeType} type - The type of the edge.\\n * @param {string} [action=delete] - Either \\\"insert\\\" or \\\"delete\\\".\\n * @return {Edge} The processed edge.\\n */\\nAdapter.prototype._processFieldEdge = function(tiddler, edge, type, action) {\\n\\n  var toTRef = $tm.indeces.tById[edge.to];\\n  if(toTRef == null) return; // null or undefined\\n  \\n  var val = (action === \\\"insert\\\" ? toTRef : \\\"\\\");\\n  \\n  // only use the name without the private marker or the namespace\\n  utils.setField(tiddler, type.name, val);\\n\\n  if(!type.exists()) {\\n    type.save();\\n  }\\n  \\n  return edge;\\n  \\n};\\n\\n/**\\n * This function will return an adjacency list for the nodes\\n * present in the current system. The list may be restricted by\\n * optional filters.\\n *\\n * @param {string} [groupBy=\\\"to\\\"] - Specifies by which property the\\n *     adjacency list is indexed. May be either \\\"from\\\" or \\\"to\\\".\\n * @param {Hashmap} [opts] - An optional options object.\\n * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\\n *    that restricts which edge-types are included.\\n * @param {Hashmap} [opts.edges] - A set of edges on which basis\\n *     the adjacency list is build. If not provided,\\n *     all edges in the system are considered.\\n * @return {Object<Id, Array<Edge>>} For each key (a node id) an\\n *     array of edges pointing \\\"from\\\" (or \\\"to\\\"; depends on `groupBy`)\\n *     is supplied as value.\\n */\\nAdapter.prototype.getAdjacencyList = function(groupBy, opts) {\\n  \\n  $tm.start(\\\"Creating adjacency list\\\");\\n  \\n  opts = opts || {};\\n  \\n  if(!opts.edges) {\\n    var tRefs = utils.getMatches($tm.selector.allPotentialNodes);\\n    opts.edges = this.getEdgesForSet(tRefs, opts.toWL, opts.typeWL);\\n  }\\n  \\n  var adjList = utils.groupByProperty(opts.edges, groupBy || \\\"to\\\");\\n  \\n  $tm.stop(\\\"Creating adjacency list\\\");\\n  \\n  return adjList;\\n  \\n};\\n\\n/**\\n * This function will return all neighbours of a graph denoted by\\n * a set of tiddlers.\\n * \\n * @todo parts of this code may be outsourced into a function to\\n * prevent repeating code.\\n * \\n * @param {Array<TiddlerReference>} matches - The original set that\\n *     defines the starting point for the neighbourhood discovery\\n * @param {Hashmap} [opts] - An optional options object.\\n * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\\n *    that restricts which edges are travelled to reach a neighbour.\\n * @param {Hashmap} [opts.edges] - An initial set of edges that is\\n *    used in the first step to reach immediate neighbours, if no\\n *    set of edges is specified, all exsisting edges will be considered.\\n * @param {number} [opts.steps] - An integer value that specifies\\n *    the scope of the neighbourhood. A node is considered a neighbour\\n *    if it can be reached within the given number of steps starting\\n *    from original set of tiddlers returned by the node filter.\\n * @param {Hashmap} [opts.addProperties] - a hashmap\\n *     containing properties to be added to each node.\\n *     For example:\\n *     {\\n *       group: \\\"g1\\\",\\n *       color: \\\"red\\\"\\n *     }\\n * @return {Object} An object of the form:\\n *     {\\n *       nodes: { *all neighbouring nodes* },\\n *       edges: { *all edges connected to neighbours* },\\n *     }\\n */\\nAdapter.prototype.getNeighbours = function(matches, opts) {\\n  \\n  $tm.start(\\\"Get neighbours\\\");\\n  \\n  opts = opts || {};\\n    \\n  // index of all tiddlers have already are been visited, either by\\n  // having been included in the original set, or by having been\\n  // recorded as neighbour during the discovery.\\n  var visited = utils.getArrayValuesAsHashmapKeys(matches); \\n  var view = new ViewAbstraction(opts.view);\\n  var protoNode = opts.addProperties;\\n  var allEdgesLeadingToNeighbours = utils.makeHashMap();\\n  var allETy = $tm.indeces.allETy;\\n  var allNeighbours = utils.makeHashMap();\\n  var toWL = opts.toWL;\\n  var typeWL = opts.typeWL;\\n  var tById = $tm.indeces.tById;\\n  var idByT = $tm.indeces.idByT;\\n  var maxSteps = (parseInt(opts.steps) > 0 ? opts.steps : 1);\\n  var direction = (opts.direction\\n                   || (view.exists()\\n                       && view.getConfig(\\\"neighbourhood_directions\\\")));\\n  var isWalkBoth = (!direction || direction === \\\"both\\\");\\n  var isWalkIn = (isWalkBoth || direction === \\\"in\\\");\\n  var isWalkOut = (isWalkBoth || direction === \\\"out\\\");\\n  \\n  // adjacency receives whitelists through opts\\n  var adjList = this.getAdjacencyList(\\\"to\\\", opts);\\n  \\n  var addAsNeighbour = function(edge, role) {\\n    allEdgesLeadingToNeighbours[edge.id] = edge;\\n    var tRef = tById[edge[role]];\\n    if(!visited[tRef]) {\\n      visited[tRef] = true;\\n      var node = this.makeNode(tRef, protoNode);\\n      if(node) { // saveguard against obsolete edges or other problems  \\n        // record node\\n        allNeighbours[node.id] = node;\\n        neighboursOfThisStep.push(tRef);              \\n      }\\n    }\\n  }.bind(this);\\n\\n  // loop if still steps to be taken and we have a non-empty starting set\\n  for(var step = 0; step < maxSteps && matches.length; step++) {\\n        \\n    // neighbours that are discovered in the current step;\\n    // starting off from the current set of matches;\\n    var neighboursOfThisStep = []; \\n    \\n    // loop over all nodes in the original set\\n    for(var i = matches.length; i--;) {\\n      \\n      if(utils.isSystemOrDraft(matches[i])) {\\n        // = this might happen if the user manually created edges\\n        // that link to a system/draft tiddler or if the original\\n        // set contained system/draft tiddlers.\\n        continue;\\n      }\\n              \\n      // get all outgoing edges\\n      // = edges originating from the starting set and point outwards\\n      var outgoing = this.getEdges(matches[i], toWL, typeWL);\\n      for(var id in outgoing) {\\n        var t = allETy[outgoing[id].type];\\n        if(isWalkBoth || isWalkOut && t.toArrow || isWalkIn && t.invertedArrow) {\\n          addAsNeighbour(outgoing[id], \\\"to\\\");\\n        }\\n      }\\n      \\n      // get all incoming edges\\n      // = edges originating from outside pointing to the starting set\\n      var incoming = adjList[idByT[matches[i]]];\\n      if(!incoming) continue;\\n      \\n      for(var j = incoming.length; j--;) {\\n        var t = allETy[incoming[j].type];\\n        if(isWalkBoth || isWalkIn && t.toArrow || isWalkOut && t.invertedArrow) {\\n          addAsNeighbour(incoming[j], \\\"from\\\");\\n        }\\n      }\\n    }\\n    \\n    // the current set of newly discovered neighbours forms the\\n    // starting point for the next discovery\\n    matches = neighboursOfThisStep;\\n    \\n  }\\n  \\n  var neighbourhood = {\\n    nodes: allNeighbours,\\n    edges: allEdgesLeadingToNeighbours\\n  };\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Retrieved neighbourhood\\\", neighbourhood, \\\"steps\\\", step);\\n  \\n  $tm.stop(\\\"Get neighbours\\\");\\n  \\n  return neighbourhood;\\n  \\n};\\n\\n/**\\n * This function will assemble a graph object based on the supplied\\n * node and edge filters. Optionally, a neighbourhood may be\\n * merged into the graph neighbourhood.\\n * \\n * @param {Hashmap} [opts] - An optional options object.\\n * @param {string|ViewAbstraction} [opts.view] - The view in which\\n *     the graph will be displayed.\\n * @param {string|ViewAbstraction} [opts.filter] - If supplied,\\n *     this will act as node filter that defines which nodes\\n *     are to be displayed in the graph; a possible view node filter\\n *     would be ignored.\\n * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\\n *     that restricts which edges are travelled to reach a neighbour.\\n * @param {number} [opts.neighbourhoodScope] - An integer value that\\n *     specifies the scope of the neighbourhood in steps.\\n *     See {@link Adapter#getNeighbours}\\n * @return {Object} An object of the form:\\n *     {\\n *       nodes: { *all nodes in the graph* },\\n *       edges: { *all edges in the graph* },\\n *     }\\n *     Neighbours will be receive the \\\"tmap:neighbour\\\" type. \\n */\\nAdapter.prototype.getGraph = function(opts) {\\n  \\n  $tm.start(\\\"Assembling Graph\\\");\\n  \\n  opts = opts || {};\\n\\n  var view = new ViewAbstraction(opts.view);\\n  var matches = utils.getMatches(opts.filter\\n                                 || (view.exists()\\n                                     && view.getNodeFilter(\\\"compiled\\\")));\\n  var toWL = utils.getArrayValuesAsHashmapKeys(matches);\\n  var typeWL = (opts.edgeTypeWL\\n                || (view.exists() && view.getEdgeTypeFilter(\\\"whitelist\\\")));\\n  var neighScope = parseInt(opts.neighbourhoodScope\\n                            || (view.exists()\\n                                && view.getConfig(\\\"neighbourhood_scope\\\")));\\n  \\n  var graph = {\\n    edges: this.getEdgesForSet(matches, toWL, typeWL),\\n    nodes: this.selectNodesByReferences(matches, {\\n      view: view,\\n      outputType: \\\"hashmap\\\"\\n    })\\n  };\\n  \\n  if(neighScope) {\\n    var neighbours = this.getNeighbours(matches, {\\n      steps: neighScope,\\n      view: view,\\n      typeWL: typeWL,\\n      addProperties: {\\n        group: \\\"tmap:neighbour\\\"\\n      }\\n    });\\n    \\n    // merge neighbours (nodes and edges) into graph\\n    utils.merge(graph, neighbours);\\n    \\n    if(view.exists() && view.isEnabled(\\\"show_inter_neighbour_edges\\\")) {\\n      var nodeTRefs = this.getTiddlersById(neighbours.nodes);\\n      // this time we need a whitelist based on the nodeTRefs\\n      var toWL = utils.getArrayValuesAsHashmapKeys(nodeTRefs)\\n      $tw.utils.extend(graph.edges, this.getEdgesForSet(nodeTRefs, toWL));\\n    }\\n  }\\n  \\n  // this is pure maintainance!\\n  this._removeObsoleteViewData(graph.nodes, view);\\n  \\n  // add styles to nodes\\n  this.attachStylesToNodes(graph.nodes, view);\\n  \\n  $tm.stop(\\\"Assembling Graph\\\");\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Assembled graph:\\\", graph);\\n  \\n  return graph;\\n  \\n};\\n\\n/**\\n * Returns all edges stored in a given tiddler. Any edge stored in a\\n * tiddler is orginally an outgoing edge. Depending on how the user\\n * changes the arrow head (by manipulating the Visjs edge-type style),\\n * the edge may change its orientation and become an incoming edge or\\n * bi-directional. Therefore, the edges retrieved may be incoming,\\n * outgoing or both!\\n * \\n * Returned edges may be of the following type:\\n * \\n * - Edges stored in the tiddler text (=links).\\n * - Edges stored in fields denoted by magic edge-types.\\n * - TiddlyMap edges stored in a json format\\n * \\n * @param {Tiddler} tiddler - A tiddler reference or object from\\n *     which to retrieve the edges.\\n * @param {Hashmap<TiddlerReference, boolean>} [toWL]\\n *     A hashmap on which basis it is decided, whether to include\\n *     an edge that leads to a certain tiddler in the result or not.\\n *     In this case, all edges stored in the tiddler are treated as\\n *     outgoing and the arrow head is ignored. If not specified, \\n *     all edges are included.\\n * @param {Hashmap<string, boolean>} [typeWL]\\n *     A hashmap on which basis it is decided, whether to include\\n *     an edge of a given type in the result or not. If not \\n *     specified, all edges are included.\\n */\\nAdapter.prototype.getEdges = function(tiddler, toWL, typeWL) {\\n\\n  var tObj = utils.getTiddler(tiddler);\\n  if(!tObj || utils.isSystemOrDraft(tObj)) return;\\n  \\n  var edges = utils.makeHashMap();\\n  this._addTmapEdges(edges, tObj, toWL, typeWL);\\n  this._addBodyAndFieldEdges(edges, tObj, toWL, typeWL);\\n\\n  return edges;\\n\\n};\\n\\n/**\\n * Adds body- and field-edges stored in a given tiddler to the\\n * edges list.\\n * \\n * Hashes are used as edge ids based on the from and to parts\\n * of the edge and its type. This has the advantage that\\n * 1. ids are unique\\n * 2. ids only change if the underlying link/tag changes.\\n * \\n * @private\\n * \\n * @param {HashMap<Id, Edge>} edges - The list into which to inject\\n *     the edges retrieved.\\n * @param {$tw.Tiddler} tObj - A tiddler object from which to\\n *     retrieve the edges.\\n * @param {Hashmap<TiddlerReference, boolean>} [toWL]\\n *     A hashmap on which basis it is decided, whether to include\\n *     an edge that leads to a certain tiddler in the result or not.\\n *     In this case, all edges stored in the tiddler are treated as\\n *     outgoing and the arrow head is ignored. If not specified, \\n *     all edges are included.\\n * @param {Hashmap<string, boolean>} [typeWL]\\n *     A hashmap on which basis it is decided, whether to include\\n *     an edge of a given type in the result or not. If not \\n *     specified, all edges are included.\\n */\\nAdapter.prototype._addBodyAndFieldEdges = function(edges, tObj, toWL, typeWL) {\\n\\n  // never assign a default to the typeWL. if it is not assigned it means\\n  // all types!! NEVER: typeWL = typeWL || utils.makeHashMap();\\n    \\n  var fromTObjFields = tObj.fields;\\n  var fromTRef = utils.getTiddlerRef(tObj);\\n  var indeces = $tm.indeces;\\n  var maETyFiNa = indeces.maETyFiNa; // magic edge-type field names\\n  var refsByType = utils.makeHashMap();\\n  \\n  // 1) Prepare\\n  \\n  if(!typeWL || typeWL[\\\"tw-body:link\\\"]) {\\n    refsByType[\\\"tw-body:link\\\"] = $tw.wiki.getTiddlerLinks(fromTRef);\\n  }\\n  \\n  // hack to support\\n  // https://github.com/felixhayashi/TW5-TiddlyMap/issues/198\\n  if(this.isTransTypeEnabled && (!typeWL || typeWL[\\\"tw-body:transclude\\\"])) {\\n    refsByType[\\\"tw-body:transclude\\\"] = $tw.wiki.getTiddlerTranscludes(fromTRef);\\n  }\\n\\n  for(var f in fromTObjFields) {\\n    \\n    var type = maETyFiNa[f];\\n      \\n    if(!type || (typeWL && !typeWL[type.id])) continue;\\n    \\n    if(type.namespace === \\\"tw-field\\\") {\\n      refsByType[type.id] = [ fromTObjFields[f] ];\\n    } else if(type.namespace === \\\"tw-list\\\") {\\n      refsByType[type.id] = $tw.utils.parseStringArray(fromTObjFields[f]);\\n    } else if(type.namespace === \\\"tw-filter\\\") {\\n      var filter = fromTObjFields[f];\\n      refsByType[type.id] = utils.getMatches(filter, toWL);\\n    }\\n  }\\n  \\n  if(!refsByType) return;\\n    \\n  // 2) Add edges to list\\n  \\n  var fromId = tObj.fields[\\\"tmap.id\\\"];\\n  var idByT = indeces.idByT;\\n  var allETy = indeces.allETy;\\n  \\n  for(var typeId in refsByType) {\\n    var toRefs = refsByType[typeId];\\n    \\n    if(!toRefs) continue;\\n    \\n    var type = allETy[typeId];\\n    for(var i = toRefs.length; i--;) {\\n      var toTRef = toRefs[i];\\n      \\n      if(!toTRef\\n         || !$tw.wiki.tiddlerExists(toTRef)\\n         || utils.isSystemOrDraft(toTRef)\\n         || (toWL && !toWL[toTRef])) continue;\\n\\n      var id = type.id + $tw.utils.hashString(fromTRef + toTRef); \\n      var edge = this.makeEdge(fromId, idByT[toTRef], type, id);\\n\\n      if(edge) {\\n        edges[edge.id] = edge;\\n      }\\n    }\\n  }\\n  \\n};\\n\\n/**\\n * Adds tmap-edges stored in a given tiddler to the edges list.\\n * \\n * @private\\n * \\n * @param {HashMap<Id, Edge>} edges - The list into which to inject\\n *     the edges retrieved.\\n * @param {$tw.Tiddler} tObj - A tiddler object from which to\\n *     retrieve the edges.\\n * @param {Hashmap<TiddlerReference, boolean>} [toWL]\\n *     A hashmap on which basis it is decided, whether to include\\n *     an edge that leads to a certain tiddler in the result or not.\\n *     In this case, all edges stored in the tiddler are treated as\\n *     outgoing and the arrow head is ignored. If not specified, \\n *     all edges are included.\\n * @param {Hashmap<string, boolean>} [typeWL]\\n *     A hashmap on which basis it is decided, whether to include\\n *     an edge of a given type in the result or not. If not \\n *     specified, all edges are included.\\n */\\nAdapter.prototype._addTmapEdges = function(edges, tObj, toWL, typeWL) {\\n  \\n  var connections = utils.parseFieldData(tObj, \\\"tmap.edges\\\");\\n  if(!connections) return;\\n  \\n  var tById = $tm.indeces.tById;\\n  var fromId = tObj.fields[\\\"tmap.id\\\"];\\n  \\n  for(var conId in connections) {\\n    var con = connections[conId];\\n    var toTRef = tById[con.to];\\n    if(toTRef && (!toWL || toWL[toTRef]) && (!typeWL || typeWL[con.type])) {\\n      var edge = this.makeEdge(fromId, con.to, con.type, conId);\\n      if(edge) {\\n        edges[conId] = edge;\\n      }\\n    }\\n  }\\n  \\n};\\n  \\n/**\\n * The method will return all outgoing edges for a subset of tiddlers.\\n * \\n * @param {Array<Tiddler>} tiddlers - The set of tiddlers to consider.\\n * @return {Hashmap<Id, Edge>} An edge collection.\\n */\\nAdapter.prototype.getEdgesForSet = function(tiddlers, toWL, typeWL) {\\n\\n  var edges = utils.makeHashMap();\\n  for(var i = tiddlers.length; i--;) {\\n    $tw.utils.extend(edges, this.getEdges(tiddlers[i], toWL, typeWL));\\n  }\\n  \\n  return edges;\\n\\n};\\n\\n/**\\n * \\n */\\nAdapter.prototype.selectEdgesByType = function(type) {\\n\\n  var typeWL = utils.makeHashMap();\\n  typeWL[new EdgeType(type).id] = true; \\n  return this.getEdgesForSet(this.getAllPotentialNodes(), null, typeWL);\\n  \\n};\\n\\nAdapter.prototype.getAllPotentialNodes = function() {\\n  \\n  return utils.getMatches($tm.selector.allPotentialNodes);\\n  \\n};\\n\\n/**\\n * \\n * \\n */\\nAdapter.prototype._processEdgesWithType = function(type, task) {\\n\\n  type = new EdgeType(type);\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Processing edges\\\", type, task);\\n  \\n  // get edges\\n  var edges = this.selectEdgesByType(type);\\n  \\n  if(task.action === \\\"rename\\\") {\\n    \\n    // clone type first to prevent auto-creation\\n    var newType = new EdgeType(task.newName);\\n    newType.load(type);\\n    newType.save();\\n      \\n  }\\n  \\n  for(var id in edges) {\\n    this._processEdge(edges[id], \\\"delete\\\");\\n    if(task.action === \\\"rename\\\") {\\n      edges[id].type = task.newName;\\n      this._processEdge(edges[id], \\\"insert\\\");\\n    }\\n  }\\n  \\n  // finally remove the old type\\n  $tw.wiki.deleteTiddler(type.fullPath);\\n\\n};\\n\\n/**\\n * Returns a set of nodes that corresponds to the given filter.\\n *\\n * @param {TiddlyWikiFilter} filter - The filter to use.\\n * @param {Hashmap} [options] - An optional options object.\\n * @param {Hashmap} [options.!! INHERITED !!] - See {@link Adapter#selectNodesByReferences}.\\n * @return {NodeCollection} A collection of a type specified in the options.\\n */\\nAdapter.prototype.selectNodesByFilter = function(filter, options) {\\n  \\n  var matches = utils.getMatches(filter);\\n  return this.selectNodesByReferences(matches, options);\\n\\n};\\n\\n/**\\n * Returns a set of nodes that corresponds to a set of tiddlers.\\n * \\n * @param {TiddlerCollection} tiddlers - A collection of tiddlers.\\n * @param {Hashmap} [options] - An optional options object.\\n * @param {CollectionTypeString} [options.outputType=\\\"dataset\\\"] - The result type.\\n * @param {View} [options.view] - A viewname used to retrieve positions\\n * @param {Hashmap} [options.addProperties] - a hashmap\\n *     containing properties to be added to each node.\\n *     For example:\\n * \\n *     {\\n *       group: \\\"g1\\\",\\n *       color: \\\"red\\\"\\n *     }\\n * \\n * @return {NodeCollection} A collection of a type specified in the options.\\n */\\nAdapter.prototype.selectNodesByReferences = function(tiddlers, options) {\\n\\n  options = options || {};\\n\\n  var protoNode = options.addProperties;\\n  var result = utils.makeHashMap();\\n  var keys = Object.keys(tiddlers);\\n  \\n  for(var i = keys.length; i--;) {\\n    \\n    var node = this.makeNode(tiddlers[keys[i]], protoNode);\\n    if(node) { result[node.id] = node; }  // ATTENTION: edges may be obsolete\\n        \\n  }\\n    \\n  return utils.convert(result, options.outputType);\\n  \\n};\\n\\n/**\\n * Retrieve nodes based on the a list of ids that corrspond to tiddlers\\n * id fields.\\n * \\n * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids of the tiddlers\\n *     that represent the nodes.\\n * @param {Hashmap} [options.!! INHERITED !!] - See {@link Adapter#selectNodesByReferences}.\\n * @return {NodeCollection} A collection of a type specified in the options.\\n */\\nAdapter.prototype.selectNodesByIds = function(nodeIds, options) {\\n  \\n  var tRefs = this.getTiddlersById(nodeIds);\\n  return this.selectNodesByReferences(tRefs, options);\\n  \\n};\\n\\n/**\\n * Select a single node by id.\\n * \\n * @param {Id} id - A node's id\\n * @param {Hashmap} [options] - An optional options object.\\n * @param {Hashmap} [options.!! PARTLY INHERITED !!]\\n *     Except from the outputType option, all options\\n *     are inherited from {@link Adapter#selectNodesByIds}.\\n * @return {Node|undefined} A node or nothing.\\n */\\nAdapter.prototype.selectNodeById = function(id, options) {\\n  \\n  options = utils.merge(options, { outputType: \\\"hashmap\\\" });\\n  var result = this.selectNodesByIds([ id ], options);\\n  return result[id];\\n  \\n};\\n\\n/**\\n * Sets up an edge object that is ready to be consumed by vis.\\n * \\n * @param {$tw.Tiddler|Id} from - A tiddler **object** or a node id\\n *     representing the from part of the relationship.\\n * @param {Object} connection - The connection object having\\n *     the properties *to*, *id*, *type*.\\n * @param {string|EdgeType} [type] - An optional edge type that\\n *     overrides the type possibly specified by the connection object.\\n * @return {Edge} An edge object.\\n */\\nAdapter.prototype.makeEdge = function(from, to, type, id) {\\n  \\n  if(!from || !to) return;\\n  \\n  if(from instanceof $tw.Tiddler) {\\n    from = from.fields[\\\"tmap.id\\\"];\\n  } else if(typeof from === \\\"object\\\") { // expect node\\n    from = from.id;\\n  } // else use from value as id\\n  \\n  type = $tm.indeces.allETy[type] || new EdgeType(type);\\n  var label = type.getLabel();\\n      \\n  var edge = {\\n    id: (id || utils.genUUID()),\\n    from: from,\\n    to: to,\\n    type: type.id\\n  };\\n    \\n  if(utils.isTrue(type[\\\"show-label\\\"], true)) {\\n    edge.label = label;\\n  }\\n\\n  edge = $tw.utils.extend(edge, type.style);\\n  \\n  return edge;\\n  \\n};\\n  \\nAdapter.prototype.removeNodeType = function(type) {\\n  \\n  // finally remove the old type\\n  var type = new NodeType(type);\\n  $tw.wiki.deleteTiddler(type.fullPath);\\n  \\n};\\n\\n\\nAdapter.prototype.makeNode = function(tiddler, protoNode) {\\n\\n  var tObj = utils.getTiddler(tiddler);\\n    \\n  if(!tObj || utils.isSystemOrDraft(tObj)) return;\\n  \\n  var node = utils.merge({}, protoNode);\\n  \\n  // assignId() will not assign an id if the tiddler already has one\\n  node.id = this.assignId(tObj);\\n   \\n  // add label\\n  var label = tObj.fields[$tm.field.nodeLabel];\\n  node.label = (label && $tm.field.nodeLabel !== \\\"title\\\"\\n                ? $tw.wiki.renderText(\\\"text/plain\\\", \\\"text/vnd-tiddlywiki\\\", label)\\n                : tObj.fields.title);\\n        \\n  return node;\\n  \\n};\\n\\nAdapter.prototype.getInheritedNodeStyles = function(nodes) {\\n  \\n  var src = this.getTiddlersById(nodes);\\n  var protoByTRef = {};\\n  var glNTy = $tm.indeces.glNTy;\\n  \\n  for(var i = glNTy.length; i--;) {\\n    var type = glNTy[i];\\n    \\n    if(type.id === \\\"tmap:neighbour\\\") { // special case\\n      var tById = $tm.indeces.tById;\\n      var inheritors = [];\\n      for(var id in nodes) {\\n        if(nodes[id].group === \\\"tmap:neighbour\\\") {\\n          inheritors.push(tById[id]);\\n        }\\n      }\\n    } else {\\n      var inheritors = type.getInheritors(src);\\n    }\\n    \\n    for(var j = inheritors.length; j--;) {\\n      var tRef = inheritors[j];\\n      var proto = protoByTRef[tRef] = (protoByTRef[tRef] || {});\\n      proto.style = utils.merge(\\n        proto.style || {},\\n        type.style\\n      );\\n      \\n      // ATTENTION: only override proto icons when the type provides\\n      // an icon since otherwise we might erase previously\\n      // inherited icons.\\n      if(type[\\\"fa-icon\\\"]) {\\n        proto[\\\"fa-icon\\\"] = type[\\\"fa-icon\\\"];\\n      } else if(type[\\\"tw-icon\\\"]) {\\n        proto[\\\"tw-icon\\\"] = type[\\\"tw-icon\\\"];\\n      }\\n      \\n    }\\n  }\\n\\n  return protoByTRef;\\n  \\n};\\n\\nAdapter.prototype.attachStylesToEdges = function(edges, view) {\\n  // TODO\\n};\\n\\n\\n/**\\n * Garbage collector for node data!\\n */\\nAdapter.prototype._removeObsoleteViewData = function(nodes, view) {\\n    \\n  view = new ViewAbstraction(view);\\n  if(!view.exists() || !nodes) return;\\n    \\n  var data = view.getNodeData();\\n  \\n  var obsoleteDataItems = 0;\\n  for(var id in data) {\\n    if(nodes[id] === undefined && data[id] != null) {\\n      // we only set this to undefined as deletion would\\n      // slow down V8, however, this necessarily requires\\n      // a safeguard agains recursion: data[id] != null\\n      data[id] = undefined;\\n      obsoleteDataItems++\\n    }\\n  }\\n  \\n  if(obsoleteDataItems) {\\n    $tm.logger(\\\"debug\\\", \\\"[Cleanup]\\\",\\n                \\\"Removed obsolete node data:\\\",\\n                view.getLabel(), obsoleteDataItems);\\n    view.saveNodeData(data);\\n  }\\n  \\n};\\n\\nAdapter.prototype.attachStylesToNodes = function(nodes, view) {\\n  \\n  view = new ViewAbstraction(view);\\n  \\n  var inheritedStyles = this.getInheritedNodeStyles(nodes);\\n\\n  var viewNodeData = view.exists() ? view.getNodeData() : utils.makeHashMap();\\n  var isStaticMode = view.exists() && !view.isEnabled(\\\"physics_mode\\\");\\n\\n  \\n  // shortcuts (for performance and readability)\\n  var nodeIconField = $tm.field.nodeIcon;\\n  var tById = $tm.indeces.tById;\\n  \\n  for(var id in nodes) {\\n    var tRef = tById[id];\\n    var tObj = $tw.wiki.getTiddler(tRef);\\n    var fields = tObj.fields;\\n    var node = nodes[id];\\n    var faIcon = null;\\n    var twIcon = null;\\n        \\n    // == group styles ==\\n    \\n    // will add local and global group styles\\n    if(inheritedStyles[tRef]) {\\n      \\n      if(inheritedStyles[tRef].style) {\\n        utils.merge(node, inheritedStyles[tRef].style);\\n      }\\n      faIcon = inheritedStyles[tRef][\\\"fa-icon\\\"];\\n      twIcon = inheritedStyles[tRef][\\\"tw-icon\\\"];\\n    }\\n        \\n    // == global node styles ==\\n         \\n    // background color\\n    if(fields.color) { node.color = fields.color }\\n        \\n    // global node style from vis editor\\n    if(fields[\\\"tmap.style\\\"]) {\\n      utils.merge(node, utils.parseJSON(fields[\\\"tmap.style\\\"]));\\n    }\\n    \\n    faIcon = fields[\\\"tmap.fa-icon\\\"] || faIcon;\\n    twIcon = fields[\\\"icon\\\"] || twIcon;\\n        \\n    // == local node styles ==\\n    \\n    // local node style and positions\\n    if(viewNodeData[id]) {\\n      utils.merge(node, viewNodeData[id]);\\n      if(isStaticMode) {\\n        // fix x if x-position is set; same for y\\n        node.fixed = {\\n          x: (node.x != null),\\n          y: (node.y != null)\\n        };\\n      }\\n      faIcon = viewNodeData[id][\\\"fa-icon\\\"] || faIcon;\\n      twIcon = viewNodeData[id][\\\"tw-icon\\\"] || twIcon;\\n    }\\n  \\n    // == tweaks ==\\n        \\n    var isColorObject = (node.color !== null\\n                         && typeof node.color === \\\"object\\\");\\n    // color/border-color may be undefined\\n    var color = (isColorObject ? node.color.background : node.color);\\n\\n    node.color = {\\n      background: color,\\n      border: (isColorObject ? node.color.border : undefined)\\n    };\\n    \\n    // ATTENTION: this function needs to be called after color is assigned\\n    this._addNodeIcon(node, faIcon, twIcon);\\n  \\n    // determine font color if not defined via a group- or node-style;\\n    // in case of global and local default styles, the user is responsible\\n    // him- or herself to adjust the font\\n    node.font = node.font || {};\\n    \\n    if(node.shape && !this.visShapesWithTextInside[node.shape]) {\\n      node.font.color = \\\"black\\\"; // force a black color\\n    } else if(!node.font.color && color) {\\n      node.font.color = getContrastColour(color, color, \\\"black\\\", \\\"white\\\");\\n    }\\n    \\n    if(node.shape === \\\"icon\\\" && typeof node.icon === \\\"object\\\") {\\n      node.icon.color = color;\\n    }\\n    \\n  }\\n  \\n  if(view.exists()) {\\n    var node = nodes[view.getConfig(\\\"central-topic\\\")];\\n    if(node) {\\n      utils.merge(node, $tm.indeces.glNTyById[\\\"tmap:central-topic\\\"].style);\\n    }\\n  }\\n  \\n};\\n\\n/**\\n * This function will remove all tiddlers from the wiki that correspond\\n * to a node in the collection. Drafts are also removed. The default\\n * storylist is updated eventually.\\n * call deleteNode which does the following\\n * 1. get id using IdByT\\n * 2. remove id using adapter.deleteEdgesByTo(idByT[tRef])\\n * 3. remove from all indeces\\n *\\n * @see: https://github.com/Jermolene/TiddlyWiki5/issues/1550\\n * \\n * @param {NodeCollection} nodes - A collection of nodes.\\n */\\nAdapter.prototype.deleteNode = function(node) {\\n\\n  if(!node) return;\\n  \\n  var id = (typeof node === \\\"object\\\" ? node.id : node);\\n  var tRef = $tm.indeces.tById[id];\\n  \\n  // delete tiddler and remove it from the river; this will\\n  // automatically remove the global node style and the outgoing edges\\n  \\n  if(tRef) {\\n    // checking for tRef is needed;\\n    // see: https://github.com/Jermolene/TiddlyWiki5/issues/1919\\n    utils.deleteTiddlers([ tRef ]);\\n  }\\n    \\n  // delete local node-data in views containing the node\\n  \\n  var viewRefs = utils.getMatches($tm.selector.allViews);\\n  for(var i = viewRefs.length; i--;) {\\n    var view = new ViewAbstraction(viewRefs[i]);\\n    view.removeNode(id);\\n    if(view.getNodeData(id)) {\\n      view.saveNodeData(id, null);\\n    }\\n  }\\n      \\n  // remove obsolete connected edges\\n  \\n  var neighbours = this.getNeighbours([ tRef ]);\\n  this.deleteEdges(neighbours.edges);\\n  \\n  // -------------------------------------------\\n  // NEVER DELETE AN INDEX THAT ALREADY EXISTED!\\n  // -------------------------------------------\\n  // Some instances may have cached the index and get confused!\\n  // It does not do harm to leave indeces as is since we do not\\n  // iterate over them(!) and when a tiddler has the same title or\\n  // id as a deleted tiddler, which is highly unlikely, then it will\\n  // simply override the index, which is totally fine. The indeces\\n  // are refreshed on every boot anyway so it is not a big deal.\\n  // \\n  // THEREFORE:\\n  //\\n  // DO NOT DO delete $tm.indeces.tById[id];\\n  // DO NOT DO delete $tm.indeces.idByT[tRef];\\n  \\n};\\n\\nAdapter.prototype.deleteNodes = function(nodes) {\\n  \\n  nodes = utils.convert(nodes, \\\"array\\\");\\n  for(var i = nodes.length; i--;) {\\n    this.deleteNode(nodes[i]);\\n  }\\n  \\n};\\n  \\n/**\\n * This function will store the positions into the sprecified view.\\n * \\n * @param {object} positions A hashmap ids as keys and x, y properties as values\\n * @param {ViewAbstraction|Tiddler|string} \\n */\\nAdapter.prototype.storePositions = function(positions, view) {\\n  \\n  view = new ViewAbstraction(view);\\n  if(!view.exists()) return;\\n  \\n  view.saveNodeData(positions);\\n    \\n}\\n\\n/**\\n * This method will assign an id to an *existing* tiddler that does\\n * not already possess and id. Any assigned id will be registered\\n * at the id->tiddler index.\\n * \\n * @todo Optimize this. It is a bottleneck that the tiddler\\n *       is always reloaded from the db.\\n * \\n * @param {Tiddler} tiddler - The tiddler to assign the id to.\\n * @param {boolean} isForce - True if the id should be overridden,\\n *     false otherwise. Only works if the id field is not set to title.\\n * @return {Id} The assigned or retrieved id.\\n */\\nAdapter.prototype.assignId = function(tiddler, isForce) {\\n\\n  // ALWAYS reload from store to avoid setting wrong ids on tiddler\\n  // being in the role of from and to at the same time.  \\n  // Therefore, do not use utils.getTiddler(tiddler)!\\n  var tObj = utils.getTiddler(tiddler, true);\\n\\n  if(!tObj) return;\\n  \\n  var id = tObj.fields[\\\"tmap.id\\\"];\\n  \\n  if(!id || isForce) {\\n    id = utils.genUUID();\\n    utils.setField(tObj, \\\"tmap.id\\\", id);\\n    $tm.logger(\\\"info\\\", \\\"Assigning new id to\\\", tObj.fields.title);\\n  }\\n  \\n  // blindly update the index IN ANY CASE because tiddler may have\\n  // an id but it is not indexed yet (e.g. because of renaming operation)\\n  $tm.indeces.tById[id] = tObj.fields.title;\\n  $tm.indeces.idByT[tObj.fields.title] = id;\\n  \\n  return id;\\n  \\n};\\n\\n/**\\n * Create a new tiddler that gets a non-existant title and is opened\\n * for edit. If a view is registered, the fields of the tiddler match\\n * the current view. If arguments network and position are specified,\\n * the node is also inserted directly into the graph at the given\\n * position.\\n * \\n * @TODO: Description is obsolete!\\n * \\n * @param {object} node A node object to be inserted\\n * @param {object|null} options - An optional options object.\\n *     Options include:\\n *       - editNodeOnCreate: True, if the node should be opened in edit\\n *         mode after it was created, false otherwise. Overwrites the\\n *         global default\\n *       - view: a viewname used to set positions and register the node to\\n */\\nAdapter.prototype.insertNode = function(node, view, options) {\\n  \\n  options = options || {}\\n  node = node || {};\\n    \\n  var fields = {\\n    \\\"tmap.id\\\": null // generated later\\n  };\\n  \\n  // https://github.com/Jermolene/TiddlyWiki5/issues/2025\\n  if(!options.fields || !options.fields.text) {\\n    fields.text = \\\"\\\";\\n  }\\n  \\n  var title = $tw.wiki.generateNewTitle(node.label || utils.getRandomLabel());\\n\\n  // title might has changed after generateNewTitle()\\n  node.label = fields.title = title;\\n  \\n  // add to tiddler store\\n  var tObj = new $tw.Tiddler(\\n    options.fields,\\n    fields,\\n    $tw.wiki.getModificationFields(),\\n    $tw.wiki.getCreationFields()\\n  );\\n   \\n  $tw.wiki.addTiddler(tObj);\\n  \\n  node = this.makeNode(tObj, node);\\n  \\n  var view = new ViewAbstraction(view);\\n  if(view.exists()) {\\n    view.addNode(node);\\n  }\\n          \\n  return node;\\n  \\n};\\n\\n/**** Helper *******************************************************/\\n\\nAdapter.prototype._getFAdigits = function(str) {\\n  \\n  return (str.length === 4\\n          ? str\\n          : str.substr(3, 4))\\n  \\n};\\n\\n/**\\n * Retrieve tiddlers based on the a list of corresponding ids.\\n * \\n * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids.\\n * @return {Array<TiddlerReference>} The resulting tiddlers.\\n */\\nAdapter.prototype.getTiddlersById = function(nodeIds) {\\n\\n  // transform into a hashmap with all values being true\\n  if(Array.isArray(nodeIds)) {\\n    nodeIds = utils.getArrayValuesAsHashmapKeys(nodeIds);\\n  } else if(nodeIds instanceof vis.DataSet) {\\n    nodeIds = utils.getLookupTable(nodeIds, \\\"id\\\"); // use id field as key\\n  }\\n  \\n  var result = [];\\n  var tById = $tm.indeces.tById;\\n  for(var id in nodeIds) {\\n    if(tById[id]) result.push(tById[id]);\\n  }\\n  \\n  return result;\\n  \\n};\\n\\nAdapter.prototype.getId = function(tiddler) {\\n  \\n  return $tm.indeces.idByT[utils.getTiddlerRef(tiddler)];\\n  // works too: return utils.getField(tiddler, \\\"tmap.id\\\");\\n  \\n};\\n\\n/**\\n * \\n */\\nAdapter.prototype._addNodeIcon = function(node, faIcon, twIcon) {\\n  \\n  // Font Awesome style\\n  if(faIcon) {\\n    node.shape = \\\"icon\\\";\\n    node.icon = {\\n      shape: \\\"icon\\\",\\n      face: \\\"FontAwesome\\\",\\n      color: node.color,\\n      code: String.fromCharCode(\\\"0x\\\" + this._getFAdigits(faIcon))\\n    };\\n    //~ console.log(String.fromCharCode(parseInt(charCode, 16)));\\n    return;\\n  }\\n  \\n  // TiddlyWiki stored icons\\n  \\n  if(!twIcon) return;\\n\\n  var imgTObj = utils.getTiddler(twIcon);\\n  if(!imgTObj) return;\\n  \\n  if(imgTObj.fields[\\\"_canonical_uri\\\"]) { // image is a url address\\n    node.image = imgTObj.fields[\\\"_canonical_uri\\\"];\\n    node.shape = \\\"image\\\";\\n    return;\\n  }\\n  \\n  if(imgTObj.fields.text) {\\n    node.image = utils.getDataUri(imgTObj);\\n    node.shape = \\\"image\\\";\\n    return;\\n  }\\n    \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/Adapter\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/CallbackManager\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/CallbackManager\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = CallbackManager;\\n\\n/*** Imports *******************************************************/\\n \\nvar utils = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n\\n/*** Code **********************************************************/\\n      \\n/**\\n * @constructor\\n */\\nfunction CallbackManager() {\\n  \\n  this.callbacks = utils.makeHashMap();\\n\\n};\\n        \\n/**\\n * The callback mechanism allows to dynamically listen to tiddler\\n * changes without hardcoding a change-check for a tiddler name\\n * in the refresh function.\\n * \\n * @param [TiddlerReference] tRef - A tiddler whose change triggers\\n *     the callback.\\n * @param {function} callback - A function that is called when the\\n *     tiddler has changed.\\n * @param {boolean} [deleteOnCall=true] - True if to delete the\\n *     callback once it has been called, false otherwise.\\n */\\nCallbackManager.prototype.add = function(tRef, callback, isDeleteOnCall) {\\n  \\n  $tm.logger(\\\"debug\\\", \\\"A callback was registered for changes of \\\\\\\"\\\" + tRef + \\\"\\\\\\\"\\\");\\n  this.callbacks[tRef] = {\\n    execute : callback,\\n    isDeleteOnCall : (typeof isDeleteOnCall === \\\"boolean\\\" ? isDeleteOnCall : true)\\n  };\\n  \\n};\\n\\n/**\\n * Removes the callback from the list of tiddler callbacks.\\n * \\n * @see CallbackManager#registerCallback\\n */\\nCallbackManager.prototype.remove = function(refOrRefList) {\\n  \\n  if(!refOrRefList) return;\\n  \\n  if(typeof refOrRefList === \\\"string\\\") {\\n    refOrRefList = [ refOrRefList ];\\n  }\\n  \\n  for(var i = refOrRefList.length; i--;) {\\n    var tRef = refOrRefList[i];\\n    if(this.callbacks[tRef]) {\\n      $tm.logger(\\\"debug\\\", \\\"A callback for \\\\\\\"\\\" + tRef + \\\"\\\\\\\" will be deleted\\\");\\n      delete this.callbacks[tRef];\\n    }\\n  }\\n  \\n};\\n\\n/**\\n * this method has to be implemented at the top of the refresh method.\\n * It checks for changed tiddlers that have\\n * registered callbacks. If `deleteOnCall` was specified during\\n * registration of the callback, the callback will be deleted\\n * automatically.\\n * \\n * @see CallbackManager#registerCallback\\n */\\nCallbackManager.prototype.handleChanges = function(changedTiddlers) {\\n  \\n  if(this.callbacks.length == 0) return;\\n  \\n  for(var tRef in changedTiddlers) {\\n    if(!this.callbacks[tRef]) continue;\\n    \\n    if($tw.wiki.getTiddler(tRef)) {\\n      \\n      $tm.logger(\\\"debug\\\", \\\"Executing a callback for: \\\" + tRef);\\n      this.callbacks[tRef].execute(tRef);\\n      \\n      // a continue prevents deleting the callback\\n      if(!this.callbacks.isDeleteOnCall) continue;\\n      \\n    }\\n    \\n    this.remove(tRef);\\n  }\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/CallbackManager\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/DialogManager\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/DialogManager\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = DialogManager;\\n\\n/*** Imports *******************************************************/\\n \\nvar utils           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar CallbackManager = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/CallbackManager\\\");\\n\\n/*** Code **********************************************************/\\n      \\n/**\\n * The DialogManager is responsible for preparing, displaying and\\n * finalizing all the dialogs.\\n * \\n * @param {CallbackManager} callbackManager - A callback manager that\\n *     is informed about changed tiddlers and keeps track of the\\n *     various tiddlers produced during the dialog process.\\n * @param {Object} [context] - An optional *this*-reference to bind the\\n *     callback of each called dialog to. Otherwise, the callback of\\n *     each dialog has to be bound manually to the callback if required.\\n * @constructor\\n */\\nfunction DialogManager(callbackManager, context) {\\n  \\n  // create callback registry\\n  this.callbackManager = callbackManager;\\n  \\n  if(context) {\\n    this.context = context;\\n  }\\n\\n};\\n\\n/**\\n* This function opens a dialog based on a skeleton and some fields and eventually\\n* calls a callback once the dialog is closed. The callback contains an indicator\\n* whether the dialog subject was confirmed or the operation cancelled. In any\\n* case the output tiddler is passed to the callback. Each dialog may write its\\n* changes to this tiddler in order to store the dialog result and make it available\\n* to the callback.\\n* \\n* How does it work?\\n* \\n* The output of the dialog process is stored in a temporary tiddler that is only known\\n* to the current instance of the dialog. This way it is ensured that only the dialog process\\n* that created the temporary tiddler will retrieve the result. Now we are able to\\n* provide unambigous and unique correspondance to dialog callbacks.\\n    \\n* Any dialog output is stored in a unique output-tiddler. Once there is a result,\\n* a new result tiddler is created with indicators how to interpret the output.\\n* The result tiddler can be understood as exit code that is independent of the output.\\n* It is the result tiddler that triggers the dialog callback that was registered before.\\n* the output is then read immediately from the output-tiddler.\\n* \\n* @param {string} templateId - The dialog id which is the basename of\\n*     the template title.\\n* @param {Hashmap} [param] - All properties (except those with special meanings)\\n*     of param will be accessible as variables in the modal\\n* @param {string} [param.subtitle] - \\n* @param {string} [param.cancelButtonLabel] - The label of the cancel button.\\n* @param {string} [param.confirmButtonLabel] - The label of the confirm button.\\n* @param {function} [callback] - A function with the signature\\n*     function(isConfirmed, outputTObj). `outputTObj` contains data\\n*     produced by the dialog (can be undefined even if confirmed!).\\n*     Be careful: the tiddler that outputTObj represents is deleted immediately.\\n* @return {$tw.Tiddler} The dialog tddler object with all its fields.\\n*/\\nDialogManager.prototype.open = function(templateId, param, callback) {\\n  \\n  if(utils.isTrue($tm.config.sys.suppressedDialogs[templateId], false)) {\\n    $tm.logger(\\\"warning\\\", \\\"Suppressed dialog\\\", templateId);\\n    return;\\n  }\\n  \\n  param = param || {}\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Dialog param object\\\", param);\\n\\n  if(typeof callback === \\\"function\\\" && this.context) {\\n    callback = callback.bind(this.context);\\n  }\\n  \\n  // create a temporary tiddler reference for the dialog\\n  var dialogTRef = $tm.path.tempRoot + \\\"/dialog-\\\" + utils.genUUID();\\n  \\n  // get the dialog template\\n  var skeleton = utils.getTiddler($tm.path.dialogs + \\\"/\\\" + templateId);\\n  \\n  // fields used to handle the dialog process\\n  var dialog = {\\n    title: dialogTRef,\\n    buttons: skeleton.fields[\\\"buttons\\\"] || \\\"ok_cancel\\\",\\n    classes: \\\"tmap-modal-content \\\" + skeleton.fields[\\\"classes\\\"],\\n    output: dialogTRef + \\\"/output\\\",\\n    result: dialogTRef + \\\"/result\\\",\\n    temp: dialogTRef + \\\"/temp\\\",\\n    template: skeleton.fields.title,\\n    templateId: templateId,\\n    currentTiddler: dialogTRef + \\\"/output\\\",\\n    text: utils.getText($tm.path.dialogs)\\n  };\\n      \\n  if(param.dialog) {\\n          \\n    if(param.dialog.preselects) {\\n      \\n      // register preselects\\n      $tw.wiki.addTiddler(new $tw.Tiddler(\\n        { title : dialog.output },\\n        utils.flatten(param.dialog.preselects)\\n      ));\\n      \\n      // remove preselects from param object\\n      delete param.dialog.preselects;\\n      \\n    }\\n    \\n    // extend the dialog object with parameters provided by the user\\n    utils.merge(dialog, param.dialog);\\n\\n  }\\n  \\n  // force the footer to be set to the wrapper\\n  // the footer wrapper will determine the footer from the\\n  // buttons field/variable\\n  dialog.footer = utils.getText($tm.path.footers);\\n  \\n  // flatten dialog and param object\\n  dialog = utils.flatten(dialog);\\n  param = utils.flatten(param);\\n  \\n  var fn = function(t) {\\n\\n    this.getElement(\\\"hidden-close-button\\\").click();\\n\\n    var triggerTObj = $tw.wiki.getTiddler(t);\\n    var isConfirmed = triggerTObj.fields.text;\\n    \\n    if(isConfirmed) {\\n      var outputTObj = $tw.wiki.getTiddler(dialog.output);\\n    } else {\\n      var outputTObj = null;\\n      $tm.notify(\\\"operation cancelled\\\");\\n    }\\n    \\n    if(typeof callback === \\\"function\\\") {\\n      callback(isConfirmed, outputTObj);\\n    }\\n    \\n    // close and remove all tiddlers used by the dialog\\n    utils.deleteByPrefix(dialogTRef);\\n    \\n  }.bind(this);\\n  \\n  // add trigger \\n  this.callbackManager.add(dialog.result, fn, true);\\n  \\n\\n  // create dialog\\n  var dialogTiddler = new $tw.Tiddler(skeleton, param, dialog);\\n  $tw.wiki.addTiddler(dialogTiddler);\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Opening dialog\\\", dialogTiddler);\\n  \\n  $tw.rootWidget.dispatchEvent({\\n    type: \\\"tm-modal\\\",\\n    param : dialogTiddler.fields.title,\\n    paramObject: dialogTiddler.fields\\n  });\\n  \\n  this.addKeyBindings();\\n  \\n  return dialogTiddler;\\n  \\n};\\n\\nDialogManager.prototype.getElement = function(name) {\\n  \\n  return utils.getFirstElementByClassName(\\\"tmap-\\\" + name);\\n  \\n};\\n\\n/**\\n * This method will search for form elements that have the class\\n * `tmap-trigger-field` set, which means that TiddlyMap shall\\n * perform a button press when a key combo occurs while the field\\n * has focus. To know which button to press on what key event,\\n * it looks for classes of the form: tmap-triggers-BUTTONNAME-on-KEYCOMBO.\\n */\\nDialogManager.prototype.addKeyBindings = function() {\\n  \\n  var keys = $tm.keycharm({\\n    container: utils.getFirstElementByClassName(\\\"tc-modal\\\")\\n  });\\n  \\n  var re = /tmap-triggers-(.+?)-on-(.+?)(?:\\\\s|$)/\\n  var triggers = document.getElementsByClassName(\\\"tmap-trigger-field\\\");\\n  \\n  for(var i = triggers.length; i--;) {\\n    var classNames = triggers[i].className.split(' ');    \\n    for(var j = classNames.length; j--;) {\\n      var matches = classNames[j].match(re);\\n      if(!matches) { // don't care\\n        continue;\\n      }\\n      var buttonName = matches[1];\\n      var key = matches[2];\\n      var buttonElement = this.getElement(buttonName);\\n      if(!buttonElement) continue;\\n      keys.bind(key, function() { this.click(); }.bind(buttonElement));\\n    }\\n  }\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/DialogManager\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/exception\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/exception\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = {};\\n\\n/*** Code **********************************************************/\\n  \\nvar exception = module.exports;\\n\\nexception.EnvironmentError = function(aspect) {\\n  this.name = \\\"EnvironmentError\\\";\\n  this.message = \\\"Critical parts of the underlying system changed: \\\" + aspect;\\n};\\n\\nexception.DependencyError = function(dep) {\\n  this.name = \\\"DependencyError\\\";\\n  this.message = \\\"TiddlyMap cannot run without: \\\" + dep;\\n};\\n  \\nfor(var ex in exception) {\\n  exception[ex].prototype = Object.create(Error.prototype);\\n  exception[ex].constructor = exception[ex];\\n}\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/exception\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/fixer\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/fixer\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = {};\\n\\n/*** Imports *******************************************************/\\n \\nvar utils =           require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar Adapter =         require(\\\"$:/plugins/felixhayashi/tiddlymap/js/Adapter\\\");\\nvar ViewAbstraction = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\\");\\nvar EdgeType =        require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\n\\n/*** Code **********************************************************/\\n\\nvar moveEdges = function(path, view) {\\n    \\n  var matches = utils.getTiddlersByPrefix(path);\\n  for(var i = 0; i < matches.length; i++) {\\n    \\n    // create edge type\\n    var type = utils.getBasename(matches[i]);\\n    if(type === \\\"__noname__\\\") { type = \\\"tmap:unknown\\\"; }\\n    type = new EdgeType(type);\\n    \\n    if(!type.exists()) type.save();\\n\\n    // move edges\\n    var edges = $tw.wiki.getTiddlerData(matches[i]);\\n    for(var j = 0; j < edges.length; j++) {        \\n      // prefix formerly private edges with view name as namespace\\n      edges[j].type = (view ? view + \\\":\\\" : \\\"\\\") + type.id;\\n      $tm.adapter.insertEdge(edges[j]);\\n    }\\n  \\n    // finally remove the store\\n    $tw.wiki.deleteTiddler(matches[i]);\\n    \\n  }\\n\\n};\\n\\nvar executeUpgrade = function(toVersion, curVersion, upgrade) {\\n  \\n  if(!utils.isLeftVersionGreater(toVersion, curVersion)) return;\\n  // = current data structure version is newer than version we\\n  // want to upgrade to.\\n    \\n  // issue debug message\\n  $tm.logger(\\\"debug\\\",  \\\"Upgrading data structure to \\\" + toVersion);      \\n  // execute fix\\n  var msg = upgrade();\\n  // update meta\\n  utils.setEntry($tm.ref.sysMeta, \\\"dataStructureState\\\", toVersion);\\n  \\n  return msg;\\n  \\n};\\n\\nvar fixer = module.exports;\\n\\n/**\\n * Special fix that is not invoked along with the other fixes but\\n * when creating the index (see caretaker code).\\n * \\n * Changes:\\n * 1. The node id field is moved to tmap.id if **original version**\\n *    is below v0.9.2.\\n */\\nfixer.fixId = function() {\\n  \\n  var meta = $tw.wiki.getTiddlerData($tm.ref.sysMeta, {});\\n  var upgrade = { before: \\\"0.9.0\\\", after: \\\"0.9.2\\\" };\\n  \\n  executeUpgrade(\\\"0.9.2\\\", meta.dataStructureState, function() {\\n    \\n    if(utils.isLeftVersionGreater(\\\"0.9.2\\\", meta.originalVersion)) {\\n      // path of the user conf at least in 0.9.2\\n      var userConf = \\\"$:/plugins/felixhayashi/tiddlymap/config/sys/user\\\";\\n      var nodeIdField = utils.getEntry(userConf, \\\"field.nodeId\\\", \\\"tmap.id\\\");\\n      utils.moveFieldValues(nodeIdField, \\\"tmap.id\\\", true, false);\\n    }\\n\\n  });\\n  \\n};\\n\\nfixer.fix = function() {\\n  \\n  var meta = $tw.wiki.getTiddlerData($tm.ref.sysMeta, {});\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Fixer is started\\\");\\n  $tm.logger(\\\"debug\\\", \\\"Data-structure currently in use: \\\", meta.dataStructureState);\\n  \\n  /**\\n   * Changes:\\n   * 1. Edges are stored in tiddlers instead of type based edge stores\\n   * 2. No more private views\\n   */   \\n  executeUpgrade(\\\"0.7.0\\\", meta.dataStructureState, function() {\\n    \\n    // move edges that were formerly \\\"global\\\"\\n    moveEdges(\\\"$:/plugins/felixhayashi/tiddlymap/graph/edges\\\", null);\\n    \\n    // move edges that were formerly bound to view (\\\"private\\\")\\n    var filter = $tm.selector.allViews;\\n    var viewRefs = utils.getMatches(filter);\\n    for(var i = 0; i < viewRefs.length; i++) {\\n      var view = new ViewAbstraction(viewRefs[i]);\\n      moveEdges(view.getRoot()+\\\"/graph/edges\\\", view);\\n    }\\n\\n  });\\n  \\n  /**\\n   * Changes:\\n   * 1. Changes to the live view filter and refresh trigger field\\n   */\\n  executeUpgrade(\\\"0.7.32\\\", meta.dataStructureState, function() {\\n    \\n    var liveView = new $tm.ViewAbstraction(\\\"Live View\\\");\\n    if(!liveView.exists()) return;\\n    \\n    // Only listen to the current tiddler of the history list\\n    liveView.setNodeFilter(\\\"[field:title{$:/temp/tmap/currentTiddler}]\\\",\\n                           true);\\n    \\n    liveView.setConfig({\\n      \\\"refresh-trigger\\\": null, // delete the field (renamed)\\n      \\\"refresh-triggers\\\": $tw.utils.stringifyList([\\n        \\\"$:/temp/tmap/currentTiddler\\\"\\n      ])\\n    });\\n\\n  });\\n  \\n  /**\\n   * Changes:\\n   * 1. Group styles for matches and neighbours are now modulized\\n   *    and stored as node-types.\\n   * 2. vis user configuration is restored unflattened!\\n   *    The user only interacts through the GUI.\\n   * 3. If the node id field was \\\"id\\\" it is moved to tmap.id\\n   */\\n  executeUpgrade(\\\"0.9.0\\\", meta.dataStructureState, function() {\\n        \\n    var confRef = $tm.ref.visUserConf;\\n    var userConf = utils.unflatten($tw.wiki.getTiddlerData(confRef, {}));\\n    \\n    if(typeof userConf.groups === \\\"object\\\") {\\n                \\n      var type = new $tm.NodeType(\\\"tmap:neighbour\\\");\\n      type.setStyle(userConf.groups[\\\"neighbours\\\"]);\\n      type.save();\\n                      \\n      delete userConf.groups;\\n      $tw.wiki.setTiddlerData(confRef, userConf);\\n                  \\n    }\\n     \\n  });\\n  \\n  /**\\n   * Changes:\\n   * 1. The node id field is moved to tmap.id if **original version**\\n   *    is below v0.9.2.\\n   */\\n  fixer.fixId();\\n   \\n  \\n  /**\\n   * This will ensure that all node types have a prioritization field\\n   * set.\\n   */\\n  executeUpgrade(\\\"0.9.16\\\", meta.dataStructureState, function() {\\n    \\n    var glNTy = $tm.indeces.glNTy;\\n    for(var i = glNTy.length; i--;) {\\n      glNTy[i].save(null, true);\\n    }\\n    \\n  });\\n  \\n  /**\\n   * Fixes the live tab\\n   */\\n  executeUpgrade(\\\"0.10.3\\\", meta.dataStructureState, function() {\\n    \\n    var liveTab = $tm.ref.liveTab;\\n    if(utils.getTiddler(liveTab).hasTag(\\\"$:/tags/SideBar\\\")) {\\n      $tw.wiki.deleteTiddler(liveTab);\\n      utils.setField(liveTab, \\\"tags\\\", \\\"$:/tags/SideBar\\\");\\n    }\\n    \\n  });\\n  \\n  /**\\n   * 1) Fixes the edge type filter. Before, an empty filter was\\n   * treated as default filter, i.e. no links and tags shown.\\n   * Now an empty filter means that we show all edge types.\\n   * \\n   * 2) Adds prefix to hide private edges per default\\n   * \\n   * 3) Corrects view-namespaces (formerly stored with colon).\\n   * \\n   */\\n  executeUpgrade(\\\"0.11.0\\\", meta.dataStructureState, function() {\\n\\n    var views = utils.getMatches($tm.selector.allViews);\\n    \\n    for(var i = views.length; i--;) {\\n      \\n      var view = new ViewAbstraction(views[i]);\\n      var eTyFilter = view.getEdgeTypeFilter(\\\"raw\\\");\\n      var confKey = \\\"edge_type_namespace\\\";\\n      view.setConfig(confKey, view.getConfig(confKey));\\n      \\n      if(eTyFilter) {\\n        \\n        // remove any occurences of the egde type path prefix\\n        var edgeTypePath = $tm.path.edgeTypes;\\n        eTyFilter = utils.replaceAll(eTyFilter, \\\"\\\", [\\n          edgeTypePath,\\n          edgeTypePath + \\\"/\\\",\\n          \\\"[prefix[\\\" + edgeTypePath + \\\"]]\\\",\\n          \\\"[prefix[\\\" + edgeTypePath + \\\"/]]\\\",\\n          [ \\\"[suffix[tw-body:link]]\\\", \\\"[[tw-body:link]]\\\" ],\\n          [ \\\"[suffix[tw-list:tags]]\\\", \\\"[[tw-list:tags]]\\\" ],\\n          [ \\\"[suffix[tw-list:list]]\\\", \\\"[[tw-body:list]]\\\" ],\\n          [ \\\"[suffix[tmap:unknown]]\\\", \\\"[[tmap:unknown]]\\\" ],\\n          [ \\\"[suffix[unknown]]\\\", \\\"[[tmap:unknown]]\\\" ],\\n        ]);\\n    \\n        var f = \\\"-[prefix[_]] \\\" + eTyFilter;\\n        \\n      } else { // no filter present\\n        \\n        var f = $tm.filter.defaultEdgeTypeFilter;\\n        \\n      }\\n      \\n      view.setEdgeTypeFilter(f)\\n    }\\n    \\n  });\\n                \\n};\\n\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/fixer\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeType\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = EdgeType;\\n\\n/*** Imports *******************************************************/\\n\\nvar MapElementType = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/MapElementType\\\");\\nvar utils          = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n  \\n/*** Code **********************************************************/\\n\\n/**\\n * This class is used to abstract edge types. It facilitates inter\\n * alia the parsing of style information, the translation of type\\n * names into actual type data or the persistance of edge type data.\\n * \\n * @todo Make certain properties immutable, especially\\n *     the id attribute and its parts!\\n * \\n * @class\\n * @extends MapElementType\\n * \\n * @param {string|EdgeType} type - Either the edge type id (name)\\n *     or a tiddler reference denoting the type or an\\n *     `EdgeType` object (that is directly bounced back). If the\\n *     id can be translated into a tiddler object that resides in\\n *     the edge type path, then its data is retrieved automatically.\\n */\\nfunction EdgeType(id, data, options) {\\n  \\n  if(id instanceof EdgeType) return id; // bounce back!\\n  \\n  options = options || {};\\n  \\n  this.root = $tm.path.edgeTypes;\\n  \\n  var parts = EdgeType._getIdParts(id, this.root);\\n  if(!parts.name) return new EdgeType(\\\"tmap:unknown\\\");\\n  \\n  this.marker = parts.marker;\\n  this.name = parts.name;\\n  this.namespace = parts.namespace;\\n  this.id = EdgeType._getId(this.marker, this.namespace, this.name);\\n  \\n  // if the id contains no namespace itself and a namespace has\\n  // been provided, moreover, a type without the namespace\\n  // doesn't exist, then we apply the provided namespace and\\n  // recreate the id.\\n  // Attention: the namespace is really a prefix and can have a\\n  // marker, which needs to be considered!\\n  if(!this.namespace && options.namespace) {\\n    \\n    if(!(new EdgeType(this.id)).exists()) {\\n      return new EdgeType(options.namespace + \\\":\\\" + this.name);\\n    }  \\n  }\\n  \\n  // call the parent constructor\\n  MapElementType.call(this, this.id, this.root, EdgeType._fieldMeta, data);\\n    \\n  var ar = this.style && this.style.arrows;\\n  \\n  if(ar) {\\n    this.invertedArrow = this._isArrow(ar, \\\"from\\\");\\n    this.toArrow = this._isArrow(ar, \\\"to\\\") || this._isArrow(ar, \\\"middle\\\");\\n    // determine if bi arrows (either from+to or no arrows)\\n    this.biArrow = (this.invertedArrow === this.toArrow);\\n    if(this.biArrow) this.toArrow = this.invertedArrow = true;\\n  } else {\\n    this.toArrow = true;\\n  }\\n\\n};\\n\\n// !! EXTENSION !!\\nEdgeType.prototype = Object.create(MapElementType.prototype);\\n// !! EXTENSION !!\\n\\nEdgeType._fieldMeta = $tw.utils.extend(\\n  {},\\n  MapElementType._fieldMeta,\\n  {\\n    \\\"label\\\": {},\\n    \\\"show-label\\\": {}\\n  }\\n);\\n\\n/**\\n * An edge-type id consists of the following parts of which the\\n * first two are optional: `[marker][namespace:]name`\\n * \\n * The colon is not considered to be part of the namespace.\\n */\\nEdgeType.edgeTypeRegexStr = \\\"^(_?)([^:_][^:]*):?([^:]*)\\\";\\nEdgeType.edgeTypeRegex = new RegExp(EdgeType.edgeTypeRegexStr);\\n  \\nEdgeType._getIdParts = function(str, rootPath) {\\n\\n  str = utils.getWithoutPrefix(str || \\\"\\\", rootPath + \\\"/\\\");\\n  var match = str.match(EdgeType.edgeTypeRegex) || [];\\n    \\n  return {\\n    marker: match[1] || \\\"\\\",\\n    namespace: (match[3] && match[2]) || \\\"\\\",\\n    name: (match[3] || match[2]) || \\\"\\\"\\n  };\\n  \\n};\\n\\nEdgeType._getId = function(marker, namespace, name) {\\n\\n  return marker + namespace + (namespace ? \\\":\\\" : \\\"\\\") + name;\\n\\n};\\n\\nEdgeType.prototype.getLabel = function() {\\n\\n  return this.label || this.name;\\n\\n};\\n\\nEdgeType.prototype._isArrow = function(arrowObj, pos) {\\n  \\n  var type = arrowObj[pos];\\n  return (pos === \\\"to\\\" && type == null\\n          || type === true\\n          || typeof type === \\\"object\\\" && type.enabled !== false);\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/MapElementType\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/MapElementType\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = MapElementType;\\n\\n/*** Imports *******************************************************/\\n\\nvar utils = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n  \\n/*** Code **********************************************************/\\n\\n/**\\n * @constructor\\n * @abstract\\n */\\nfunction MapElementType(id, root, fieldMeta, data) {\\n\\n  this.id = id;\\n  this.root = root;\\n  this._fieldMeta = fieldMeta;\\n  this.fullPath = this.root + \\\"/\\\" + this.id;\\n  this.isShipped = $tw.wiki.getSubTiddler($tm.path.pluginRoot,\\n                                          this.fullPath)\\n  // finally get the data\\n  this.load(data || this.fullPath);\\n\\n};\\n\\n/**\\n * A list of fields that are used as data identifiers. Only these\\n * listed keys are acknowledged by the load and save functions in\\n * this class.\\n * \\n * This object resembles tw's field modules that are used by\\n * `boot.js` to decide how fields are parsed and stringified again.\\n */\\nMapElementType._fieldMeta = {\\n  \\\"description\\\": {},\\n  \\\"style\\\": {\\n    parse: utils.parseJSON,\\n    stringify: JSON.stringify\\n  },\\n  \\\"modified\\\": {}, // translation handled by TW's core\\n  \\\"created\\\": {} // translation handled by TW's core\\n};\\n\\n/**\\n * Load the type's data. Depending on the constructor arguments,\\n * the data source can be a tiddler, a type store\\n */\\nMapElementType.prototype.load = function(data) {\\n  \\n  if(!data) return;\\n  \\n  if(typeof data === \\\"string\\\") { // assume id or full path\\n    \\n    var isFullPath = utils.startsWith(data, this.root)\\n    var tRef = (isFullPath ? data : this.root + \\\"/\\\" + data);\\n    this.loadFromTiddler(tRef);\\n    \\n  } else if(data instanceof $tw.Tiddler) {\\n    this.loadFromTiddler(data);\\n    \\n  } else if(typeof data === \\\"object\\\") { // = type or a data object\\n    for(var field in this._fieldMeta) {\\n      this[field] = data[field];\\n    }\\n  }\\n  \\n};\\n\\n\\n/**\\n * Retrieve all data from the tiddler provided. If a shadow tiddler\\n * with the same id exists, its data is merged during the load\\n * process.\\n */\\nMapElementType.prototype.loadFromTiddler = function(tiddler) {\\n  \\n  var tObj = utils.getTiddler(tiddler);\\n  if(!tObj) return;\\n  \\n  var shadowTObj = $tw.wiki.getSubTiddler($tm.path.pluginRoot,\\n                                          this.fullPath) || {};\\n  \\n  // copy object to allow manipulation of the data\\n  var rawData = $tw.utils.extend({}, shadowTObj.fields, tObj.fields);\\n  // allow parsers to transform the raw field data\\n  for(var field in this._fieldMeta) {\\n    var parser = this._fieldMeta[field].parse;\\n    var rawVal = rawData[field];\\n    this[field] = (parser ? parser.call(this, rawVal) : rawVal);\\n  }    \\n\\n};\\n\\n/**\\n * Method to determine whether or not this type exists. A type\\n * exists if a tiddler with the type's id can be found below\\n * the type's root path.\\n * \\n * @return {boolean} True if the type exists, false otherwise.\\n */\\nMapElementType.prototype.exists = function() {\\n\\n  return utils.tiddlerExists(this.fullPath);\\n\\n};\\n\\nMapElementType.prototype.setStyle = function(style, isMerge) {\\n\\n  // preprocessing: try to turn string into json\\n  if(typeof style === \\\"string\\\") {\\n    style = utils.parseJSON(style);\\n  }\\n  \\n  // merge or override\\n  if(typeof style === \\\"object\\\") {\\n    if(isMerge) {\\n      utils.merge(this.style, style);\\n    } else {\\n      this.style = style;\\n    }\\n  }\\n    \\n};\\n  \\n/**\\n * Store the type object as tiddler in the wiki. If the `tRef`\\n * property is not provided, the default type path prefix \\n * will be used with the type id appended. Stringifiers provided in\\n * the field meta object (that was passed to the constructor) are\\n * called.\\n * \\n * @param {string} [tRef] - If `tRef` is provided, the type\\n *     data will be written into this tiddler and the id property\\n *     is added as extra field value. Only do this is only for\\n *     dumping purposes!\\n */\\nMapElementType.prototype.save = function(tRef, silently) {\\n\\n  if(!tRef) {\\n    tRef = this.fullPath;\\n  } else if(typeof tRef !== \\\"string\\\") {\\n    return;\\n  }\\n  \\n  // also add an empty text field to guard against\\n  // https://github.com/Jermolene/TiddlyWiki5/issues/2025\\n  var fields = {\\n    title: tRef,\\n    text: \\\"\\\"\\n  };\\n  \\n  if(!utils.startsWith(tRef, this.root)) {\\n    \\n    // = not the standard path for storing this type!\\n    // in this case we add the id to the output.\\n    fields.id = this.id;\\n    \\n  }\\n\\n  if(silently !== true) {\\n    // add modification date to the output;\\n    this.modified = new Date();\\n  }\\n  \\n  if(!this.exists()) { // newly created\\n    // add a creation field as well\\n    this.created = this.modified;\\n  }\\n\\n  // allow parsers to transform the raw field data\\n  for(var field in this._fieldMeta) {\\n    var stringify = this._fieldMeta[field].stringify;\\n    fields[field] = (stringify\\n                     ? stringify.call(this, this[field])\\n                     : this[field]);\\n  }\\n  \\n  $tw.wiki.addTiddler(new $tw.Tiddler(fields));\\n    \\n\\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/MapElementType\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/NodeType\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/NodeType\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = NodeType;\\n\\n/*** Imports *******************************************************/\\n\\nvar MapElementType = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/MapElementType\\\");\\nvar utils          = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n  \\n/*** Code **********************************************************/\\n\\n/**\\n * Used to define the type of a node.\\n *\\n * @class\\n * @extends MapElementType\\n *\\n */\\nfunction NodeType(id, data) {\\n\\n  if(id instanceof NodeType) {\\n    return id; // bounce back!\\n  }\\n \\n  id = (typeof id === \\\"string\\\"\\n        ? utils.getWithoutPrefix(id, $tm.path.nodeTypes + \\\"/\\\")\\n        : \\\"tmap:unknown\\\");\\n \\n  // call the parent constructor\\n  MapElementType.call(\\n    this,\\n    id,\\n    $tm.path.nodeTypes,\\n    NodeType._fieldMeta,\\n    data\\n  );\\n\\n};\\n\\n// !! EXTENSION !!\\nNodeType.prototype = Object.create(MapElementType.prototype);\\n// !! EXTENSION !!\\n\\nNodeType._fieldMeta = $tw.utils.extend({}, MapElementType._fieldMeta, {\\n  \\\"view\\\": {},\\n  \\\"priority\\\": {\\n    parse: function(raw) {\\n      return (isNaN(raw) ? 1 : parseInt(raw));\\n    },\\n    stringify: function(num) {\\n      return utils.isInteger(num) ? num.toString() : \\\"1\\\";\\n    }\\n  },\\n  \\\"scope\\\": {\\n    stringify: utils.getWithoutNewLines\\n  },\\n  \\\"fa-icon\\\": {},\\n  \\\"tw-icon\\\": {}\\n});\\n\\n/**\\n * Get all tiddlers that inherit this type.\\n * \\n * @param {Array<TiddlerReference>} [src=$tw.wiki.allTitles()] - A list\\n *     of tiddlers that is searched for inheritors.\\n * @return {Array<TiddlerReference>} The inheritors.\\n */\\nNodeType.prototype.getInheritors = function(src) {\\n   \\n  var s = this.scope;\\n  return (s ? utils.getMatches(s, src || $tw.wiki.allTitles()) : []);\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/NodeType\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/Popup\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Popup\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = Popup;\\n\\n/*** Imports *******************************************************/\\n\\nvar utils = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n  \\n/**** Code *********************************************************/\\n\\n/**\\n * Installs a hidden popup below `parentDomNode` that may be shown\\n * and or hidden.\\n * \\n * @constructor\\n * \\n * @param {DOMElement} [parentDomNode] - The popup container. The\\n *    popup will create itself in this container.\\n * @param {Hashmap} [options] - An options object.\\n * @param {string} [options.className] - A classname to be added to\\n *    the popup div.\\n * @param {int} [options.delay] - The default delay for the popup\\n *    show and hide.\\n */\\nfunction Popup(parentDomNode, options) {\\n  \\n  options = options || {};\\n    \\n  this._parentDomNode = parentDomNode;\\n  this._domNode = document.createElement(\\\"div\\\");\\n  this._domNode.style.display = \\\"none\\\";\\n  this._domNode.className = \\\"tmap-popup\\\";\\n  \\n  this._parentDomNode.appendChild(this._domNode);\\n  $tw.utils.addClass(this._domNode, options.className);\\n  \\n  this._isEnabled = true;\\n  this._isPreventShowOrHide = false;\\n  this._isHideOnClick = !!options.hideOnClick;\\n  this._timeoutShow = null;\\n  this._timeoutHide = null;\\n  this._signature = null;\\n  this._isDisplayNoneAfterAnimation = true;\\n    \\n  // delays\\n  var val = parseInt(options.leavingDelay);\\n  this._hideDelayLeavingPopup = utils.isInteger(val) ? val : 200;\\n  \\n  var val = parseInt(options.hideDelay);\\n  this._hideDelay = utils.isInteger(val) ? val : 200;\\n  \\n  var val = parseInt(options.showDelay);\\n  this._showDelay = utils.isInteger(val) ? val : 200;\\n\\n  // force early binding of functions to this context\\n  utils.bind(this, [\\n    \\\"_show\\\",\\n    \\\"_hide\\\",\\n    \\\"_handleEnter\\\",\\n    \\\"_handleLeave\\\",\\n    \\\"_handleAnimationEnd\\\",\\n    \\\"_handleClick\\\"\\n  ]);\\n\\n  // specify handlers\\n  this._listeners = {\\n    \\\"mouseenter\\\": this._handleEnter,\\n    \\\"mouseleave\\\": this._handleLeave,\\n    \\\"click\\\": [ this._handleClick, true ]\\n  };\\n  \\n  var fn = this._handleAnimationEnd;\\n  this._listeners[$tw.utils.convertEventName(\\\"animationEnd\\\")] = fn;\\n  this._listeners[$tw.utils.convertEventName(\\\"transitionEnd\\\")] = fn;\\n\\n  // add handlers\\n  utils.setDomListeners(\\\"add\\\", this._domNode, this._listeners, false);\\n  \\n};\\n\\n/**\\n * When the mouse is inside the popup, the popup will manage closing\\n * itself and ignore all closing attempts from outside.\\n */\\nPopup.prototype._handleEnter = function(ev) {\\n  \\n  //~ console.log(\\\"_handleEnter\\\");\\n    \\n  this._isPreventShowOrHide = true;\\n  \\n};\\n\\n/**\\n * Handler triggered when leaving the popup div.\\n */\\nPopup.prototype._handleLeave = function(ev) {\\n  \\n  //~ console.log(\\\"_handleLeave\\\");\\n  \\n  this._isPreventShowOrHide = false;\\n  \\n  // we need some delay because resizing may cause the mouse to\\n  // exit the popup for some miliseconds\\n  \\n  this.hide(this._hideDelayLeavingPopup);\\n  \\n};\\n\\nPopup.prototype._handleClick = function(ev) {\\n  \\n  //~ console.log(\\\"_handleLeave\\\");\\n  \\n  if(this._isHideOnClick) {\\n    this._hide(true);\\n  }\\n  \\n};\\n\\n/**\\n * Handler triggered when leaving the popup div.\\n */\\nPopup.prototype._handleAnimationEnd = function() {\\n  \\n  if(this._isDisplayNoneAfterAnimation) {\\n    //~ console.log(\\\"display: none\\\");\\n    this._domNode.style.display = \\\"none\\\";\\n  }\\n  \\n};\\n\\n/**\\n * Immediately hides the popup.\\n */\\nPopup.prototype._hide = function(isForce) {\\n  \\n  //~ console.log(\\\"_hide\\\");\\n  \\n  if(!isForce && this._isPreventShowOrHide) return;\\n    \\n  //~ console.log(\\\"_hide SUCCESS\\\");\\n  \\n  this._signature = null;\\n  this._isDisplayNoneAfterAnimation = true;\\n  this._isPreventShowOrHide = false;\\n  \\n  $tw.utils.removeClass(this._domNode, \\\"tmap-popup-active\\\");\\n      \\n};\\n\\n/**\\n * Makes the text visible as popup and registers it with the\\n * given signature.\\n * \\n * The popup is spawned on the side that has the most space.\\n * \\n * @param {*} signature - The signature that has been \\n *     passed to {@link show}.\\n */\\nPopup.prototype._show = function(signature, text) {\\n  \\n  //~ console.log(\\\"_show\\\");\\n  \\n  if(this._isPreventShowOrHide || $tm.mouse.ctrlKey || !this._isEnabled) {\\n    return;\\n  }\\n  \\n  this._domNode.style.display = \\\"none\\\";\\n  $tw.utils.removeClass(this._domNode, \\\"tmap-popup-active\\\");\\n  \\n  // remove any positioning or modification done before\\n  this._domNode.removeAttribute(\\\"style\\\");\\n\\n  // remove any previous content\\n  utils.removeDOMChildNodes(this._domNode);\\n  var div = this._domNode.appendChild(document.createElement(\\\"div\\\"));\\n  \\n  if(typeof text === \\\"function\\\") {\\n    text(signature, div);\\n  } else {\\n    div.innerHTML = text;\\n  }\\n  \\n  if(!div.childNodes.length) return;\\n  \\n  var parRect = this._parentDomNode.getBoundingClientRect();\\n  var x = $tm.mouse.clientX;\\n  var y = $tm.mouse.clientY;\\n\\n  //~ console.log(\\\"_show SUCCESS\\\");\\n  \\n  this._signature = signature;\\n  \\n  // ATTENTION: display needs to be true before we can get the bounds!\\n    \\n  // make sure that display is block so the animation is executed\\n  // and we can retrieve the size of the div.\\n  this._domNode.style.display = \\\"block\\\";\\n\\n  var popRect = this._domNode.getBoundingClientRect();\\n    \\n  var availSpaceRight = parRect.right - (x + popRect.width);\\n  var availSpaceLeft = (x - popRect.width) - parRect.left;\\n  var spawnRight = availSpaceRight > availSpaceLeft;\\n  \\n  var availSpaceBottom = parRect.bottom - (y + popRect.height);\\n  var availSpaceTop = (y - popRect.height) - parRect.top;\\n  var spawnBottom = availSpaceBottom > availSpaceTop;\\n  \\n  var shiftLeft = spawnRight ? -15 : popRect.width + 15;\\n  var shiftTop = spawnBottom ? -15 : popRect.height + 15;\\n  \\n  this._domNode.style.left = (x - parRect.left - shiftLeft) + \\\"px\\\";\\n  this._domNode.style.top = (y - parRect.top - shiftTop) + \\\"px\\\";\\n  \\n  // …and make sure that it stays block after the animation is done…\\n  this._isDisplayNoneAfterAnimation = false;\\n  // …and add the class that triggers the animation…\\n  $tw.utils.addClass(this._domNode, \\\"tmap-popup-active\\\");\\n  \\n};\\n\\n/**\\n * Makes the text visible as popup after a given delay and\\n * registers the popup under the specified signature.\\n * \\n * @param {*} signature - If {@param text} is provided as param and\\n *     is a function, then this will be passed later as argument to\\n *     text. It therefore acts as means to identify the popup later\\n *     on or pass data that survives the delay.\\n * @param {string|Function(*, DOMElement)} text - If text\\n *     is a string, it will be shown in the popup, otherwise,\\n *     if text is a function, it will be executed and it is\\n *     expected to populate the popup div passed as second parameter;\\n *     the first parameter will be the signature object.\\n * @param{delay} delay - Delays the hide operation.\\n */\\nPopup.prototype.show = function(signature, text, delay) {\\n  \\n  //~ console.log(\\\"show\\\", delay);\\n  \\n  this._clearTimeouts();\\n  \\n  delay = (utils.isInteger(delay) ? delay : this._showDelay);\\n    \\n  // start a new timeout\\n  this._timeoutShow = window.setTimeout(this._show, delay, signature, text);\\n  \\n};\\n\\n/**\\n * Hide the popup.\\n * \\n * @param {int} delay - Delays the hide operation.\\n */\\nPopup.prototype.hide = function(delay, isForce) {\\n  \\n  //~ console.log(\\\"hide\\\", delay);\\n    \\n  this._clearTimeouts();\\n    \\n  delay = (utils.isInteger(delay) ? delay : this._hideDelay);\\n  \\n  if(isForce || delay === 0) { // @TODO is this really correct?\\n    this._hide(isForce);\\n  } else {\\n    this._timeoutHide = window.setTimeout(this._hide, delay, isForce);\\n  }\\n      \\n};\\n\\n/**\\n * Completely enable or disable the popup\\n */\\nPopup.prototype.setEnabled = function(isEnabled) {\\n  this._isEnabled = isEnabled;\\n};\\n\\nPopup.prototype.isShown = function() {\\n  return this._domNode.style.display === \\\"block\\\";\\n};\\n  \\nPopup.prototype._clearTimeouts = function() {\\n  \\n  //~ console.log(\\\"_clearTimeouts\\\", this._timeoutShow, this._timeoutHide);\\n  \\n  window.clearTimeout(this._timeoutShow);\\n  window.clearTimeout(this._timeoutHide);\\n  \\n  this._timeoutShow = undefined;\\n  this._timeoutHide = undefined;\\n      \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/Popup\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/URL\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/URL\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = Url;\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * <<<\\n * Lightweight URL manipulation with JavaScript. This library is \\n * independent of any other libraries and has pretty simple interface\\n * and lightweight code-base. Some ideas of query string parsing \\n * had been taken from Jan Wolter.\\\"\\n * \\n * @see http://unixpapa.com/js/querystring.html\\n * @license MIT\\n * @author Mykhailo Stadnyk <mikhus@gmail.com>\\n * <<< https://github.com/Mikhus/jsurl\\n * \\n * @class\\n * @param {string} url\\n */\\nfunction Url( url) {\\n  this.paths = function( paths) {\\n    var prefix = '', i = 0, s;\\n\\n    if (paths && paths.length && paths + '' !== paths) {\\n      if (this.isAbsolute()) {\\n        prefix = '/';\\n      }\\n\\n      for (s = paths.length; i < s; i++) {\\n        paths[i] = encode(paths[i]);\\n      }\\n\\n      this.path = prefix + paths.join('/');\\n    }\\n\\n    paths = (this.path.charAt(0) === '/' ?\\n      this.path.slice(1) : this.path).split('/');\\n\\n    for (i = 0, s = paths.length; i < s; i++) {\\n      paths[i] = decode(paths[i]);\\n    }\\n\\n    return paths;\\n  };\\n\\n  this.encode = encode;\\n  this.decode = decode;\\n\\n  this.isAbsolute = function() {\\n    return this.protocol || this.path.charAt(0) === '/';\\n  };\\n\\n  this.toString = function() {\\n    return (\\n      (this.protocol && (this.protocol + '://')) +\\n      (this.user && (\\n        encode(this.user) + (this.pass && (':' + encode(this.pass))\\n      ) + '@')) +\\n      (this.host && this.host) +\\n      (this.port && (':' + this.port)) +\\n      (this.path && this.path) +\\n      (this.query.toString() && ('?' + this.query)) +\\n      (this.hash && ('#' + encode(this.hash)))\\n    );\\n  };\\n\\n  parse( this, url);\\n};\\n\\nvar\\n    // mapping between what we want and <a> element properties\\n    map = {\\n      protocol : 'protocol',\\n      host     : 'hostname',\\n      port     : 'port',\\n      path     : 'pathname',\\n      query    : 'search',\\n      hash     : 'hash'\\n    },\\n\\n    defaultPorts = {\\n      \\\"ftp\\\"    : 21,\\n      \\\"gopher\\\" : 70,\\n      \\\"http\\\"   : 80,\\n      \\\"https\\\"  : 443,\\n      \\\"ws\\\"     : 80,\\n      \\\"wss\\\"    : 443\\n    },\\n\\n    parse = function( self, url) {\\n      var\\n        d      = document,\\n        link   = d.createElement( 'a'),\\n        url    = url || d.location.href,\\n        auth   = url.match( /\\\\/\\\\/(.*?)(?::(.*?))?@/) || [],\\n        i\\n      ;\\n\\n      link.href = url;\\n\\n      for (i in map) {\\n        self[i] = link[map[i]] || '';\\n      }\\n\\n      // fix-up some parts\\n      self.protocol = self.protocol.replace( /:$/, '');\\n      self.query    = self.query.replace( /^\\\\?/, '');\\n      self.hash     = decode(self.hash.replace( /^#/, ''));\\n      self.user     = decode(auth[1] || '');\\n      self.pass     = decode(auth[2] || '');\\n      self.port     = (\\n        defaultPorts[self.protocol] == self.port || self.port == 0\\n      ) ? '' : self.port; // IE fix, Android browser fix\\n\\n      if (!self.protocol && !/^([a-z]+:)?\\\\/\\\\//.test( url)) {\\n        // is IE and path is relative\\n        var\\n          base     = new Url( d.location.href.match(/(.*\\\\/)/)[0]),\\n          basePath = base.path.split( '/'),\\n          selfPath = self.path.split( '/'),\\n          props = ['protocol','user','pass','host','port'],\\n          s = props.length\\n        ;\\n\\n        basePath.pop();\\n\\n        for (i = 0; i < s; i++) {\\n          self[props[i]] = base[props[i]];\\n        }\\n\\n        while (selfPath[0] == '..') { // skip all \\\"../\\n          basePath.pop();\\n          selfPath.shift();\\n        }\\n\\n        self.path =\\n          (url.charAt(0) != '/' ? basePath.join( '/') : '') +\\n          '/' + selfPath.join( '/')\\n        ;\\n      }\\n\\n      else {\\n        // fix absolute URL's path in IE\\n        self.path = self.path.replace( /^\\\\/?/, '/');\\n      }\\n\\n      self.paths((self.path.charAt(0) == '/' ?\\n        self.path.slice(1) : self.path).split('/')\\n      );\\n\\n      parseQs( self);\\n    },\\n\\n    encode = function(s) {\\n      return encodeURIComponent(s).replace(/'/g, '%27');\\n    },\\n\\n    decode = function(s) {\\n      s = s.replace( /\\\\+/g, ' ');\\n\\n      s = s.replace(/%([ef][0-9a-f])%([89ab][0-9a-f])%([89ab][0-9a-f])/gi,\\n        function( code, hex1, hex2, hex3) {\\n          var\\n            n1 = parseInt( hex1, 16) - 0xE0,\\n            n2 = parseInt( hex2, 16) - 0x80\\n          ;\\n\\n          if (n1 == 0 && n2 < 32) {\\n            return code;\\n          }\\n\\n          var\\n            n3 = parseInt( hex3, 16) - 0x80,\\n            n = (n1 << 12) + (n2 << 6) + n3\\n          ;\\n\\n          if (n > 0xFFFF) {\\n            return code;\\n          }\\n\\n          return String.fromCharCode( n);\\n        }\\n      );\\n\\n      s = s.replace( /%([cd][0-9a-f])%([89ab][0-9a-f])/gi,\\n        function( code, hex1, hex2) {\\n          var n1 = parseInt(hex1, 16) - 0xC0;\\n  \\n          if (n1 < 2) {\\n            return code;\\n          }\\n  \\n          var n2 = parseInt(hex2, 16) - 0x80;\\n  \\n          return String.fromCharCode( (n1 << 6) + n2);\\n        }\\n      );\\n\\n      s = s.replace( /%([0-7][0-9a-f])/gi,\\n        function( code, hex) {\\n          return String.fromCharCode( parseInt(hex, 16));\\n        }\\n      );\\n\\n      return s;\\n    },\\n\\n    parseQs = function( self) {\\n      var qs = self.query;\\n\\n      self.query = new (function( qs) {\\n        var re = /([^=&]+)(=([^&]*))?/g, match;\\n\\n        while ((match = re.exec( qs))) {\\n          var\\n            key = decodeURIComponent(match[1].replace(/\\\\+/g, ' ')),\\n            value = match[3] ? decode(match[3]) : ''\\n          ;\\n\\n          if (this[key] != null) {\\n            if (!(this[key] instanceof Array)) {\\n              this[key] = [this[key]];\\n            }\\n\\n            this[key].push( value);\\n          }\\n\\n          else {\\n            this[key] = value;\\n          }\\n        }\\n\\n        this.clear = function() {\\n          for (var key in this) {\\n            if (!(this[key] instanceof Function)) {\\n              delete this[key];\\n            }\\n          }\\n        };\\n\\n        this.count = function() {\\n          var count = 0, key;\\n          for (key in this) {\\n            if (!(this[key] instanceof Function)) {\\n              count++;\\n            }\\n          }\\n          return count;\\n        };\\n\\n        this.isEmpty = function() {\\n          return this.count() === 0;  \\n        };\\n\\n        this.toString = function() {\\n          var s = '', e = encode, i, ii;\\n\\n          for (i in this) {\\n            if (this[i] instanceof Function) {\\n              continue;\\n            }\\n\\n            if (this[i] instanceof Array) {\\n              var len = this[i].length;\\n\\n              if (len) {\\n                for (ii = 0; ii < len; ii++) {\\n                  s += s ? '&' : '';\\n                  s += e( i) + '=' + e( this[i][ii]);\\n                }\\n              }\\n\\n              else {\\n                // parameter is an empty array, so treat as\\n                // an empty argument\\n                s += (s ? '&' : '') + e( i) + '=';\\n              }\\n            }\\n\\n            else {\\n              s += s ? '&' : '';\\n              s += e( i) + '=' + e( this[i]);\\n            }\\n          }\\n\\n          return s;\\n        };\\n      })( qs);\\n    }\\n  ;\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/URL\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/utils\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/utils\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = {};\\n\\n/*** Imports *******************************************************/\\n \\nvar vis       = require(\\\"$:/plugins/felixhayashi/vis/vis.js\\\");\\nvar exception = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/exception\\\");\\nvar URL       = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/URL\\\");\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * A utilities class that contains universally used helper functions\\n * to abbreviate code and make my life easier.\\n * \\n * ATTENTION: This module must not require any other tiddlymap file\\n * in order to avoid cyclic dependencies. For the same reason,\\n * it must also not access the `$tm.*` object.\\n * \\n * Exceptions to this restriction:\\n *   - The utils module may access all `$tm.*` properties\\n *     defined in startup.environment.\\n *   - The utils module may require vendor libs or tiddlymap libs\\n *     that only require vendor libs themselves.\\n * \\n * @see Dom utilities {@link https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/*}\\n * @namespace utils\\n */\\nvar utils = module.exports;\\n\\n/**\\n * Pendant to tw native {@code addTiddlers()}.\\n * \\n * Also removes tiddlers from the river.\\n * \\n * @param {TiddlerCollection} tiddlers - A collection of tiddlers\\n * to be removed.\\n */\\nutils.deleteTiddlers = function(tiddlers) {\\n  \\n  var keys = Object.keys(tiddlers);\\n  var storyList = $tw.wiki.getTiddlerList(\\\"$:/StoryList\\\");\\n  \\n  for(var i = keys.length; i--;) {\\n    var tRef = utils.getTiddlerRef(tiddlers[keys[i]]);\\n    if(!$tw.wiki.tiddlerExists(tiddlers[keys[i]])) {\\n      // this check is important!\\n      // see https://github.com/Jermolene/TiddlyWiki5/issues/1919\\n      continue;\\n    }\\n    \\n    var index = storyList.indexOf(tRef);\\n    if(index !== -1) { // tiddler is displayed in river\\n      storyList.splice(index, 1);\\n      utils.setField(\\\"$:/StoryList\\\", \\\"list\\\", storyList);\\n    }\\n    \\n    // finally delete the tiddler;\\n    \\n    \\n    $tw.wiki.deleteTiddler(tRef);\\n\\n  }\\n  \\n};\\n\\nutils.moveFieldValues = function(oldName,\\n                                 newName,\\n                                 isRemoveOldField,\\n                                 isIncludeSystemTiddlers,\\n                                 tiddlers) {\\n                                   \\n  if(oldName === newName) return;\\n        \\n  var allTiddlers = tiddlers || $tw.wiki.allTitles();\\n  for(var i = allTiddlers.length; i--;) {\\n    var tObj = utils.getTiddler(allTiddlers[i]);\\n    if(tObj.isDraft()\\n       || !tObj.fields[oldName]\\n       || (!isIncludeSystemTiddlers\\n           && $tw.wiki.isSystemTiddler(allTiddlers[i]))) {\\n             continue;\\n    }\\n    \\n    var fields = {};\\n    fields[newName] = tObj.fields[oldName];\\n    if(isRemoveOldField) {\\n      fields[oldName] = undefined;\\n    }\\n    $tw.wiki.addTiddler(new $tw.Tiddler(tObj, fields));\\n    \\n  }\\n  \\n};\\n\\n/**\\n * @param {Tiddler} tiddler\\n * @param {string} aliasField - A tiddler field that contains an\\n *     alternative title (e.g. \\\"caption\\\").\\n * @return {string|undefined} If the `aliasField` exists and is not\\n *     empty, the value of the `aliasField` otherwise the tiddler's\\n *     title or undefined if the tiddler doesn't exist.\\n */\\nutils.getLabel = function(tiddler, aliasField) {\\n  var tObj = utils.getTiddler(tiddler);\\n  return (tObj && tObj.fields[aliasField]\\n          ? tObj.fields[aliasField]\\n          : tObj.fields.title);\\n};\\n\\n/**\\n * Uppercase the first letter of a string.\\n */\\nutils.ucFirst = function(string) {\\n  return string && string[0].toUpperCase() + string.slice(1);\\n};\\n\\n/**\\n * Transforms a collection of a certain type into a collection of\\n * another type.\\n * \\n * **Attention**: When trying to convert an array into a object, the\\n * array will be simply bounced back. Let's hope no one added enumerable\\n * properties to Array.prototype :)\\n * \\n * @param {Collection} col - The collection to convert.\\n * @param {CollectionTypeString} [outputType=\\\"dataset\\\"] - The output type.\\n * @return {Collection} A **new** collection of type `outputType`.\\n */\\nutils.convert = function(col, outputType) {\\n  \\n  if(typeof col !== \\\"object\\\") return;\\n  \\n  switch(outputType) {\\n    \\n    case \\\"array\\\":\\n      return utils.getValues(col);\\n    case \\\"hashmap\\\": // fall through alias\\n    case \\\"object\\\":\\n      if(col instanceof vis.DataSet) { // a dataset\\n        return col.get({ returnType: \\\"Object\\\" }); // careful has proto\\n      } else { // object (array is an object itself)\\n        return col; // bounce back\\n      }\\n      \\n    case \\\"dataset\\\":\\n    default:\\n      if(col instanceof vis.DataSet) {\\n        return col; // bounce back\\n      }\\n      if(!Array.isArray(col)) {\\n        col = utils.getValues(col);\\n      }\\n            \\n      return new vis.DataSet(col);\\n\\n  }\\n  \\n};\\n\\n/**\\n * Extract all the values from a collection. If `col` is an object,\\n * only properties are considered that are its own and iterable.\\n * \\n * @param {Collection} col\\n * @return {Array} An array\\n */\\nutils.getValues = function(col) {\\n  \\n  if(Array.isArray(col)) {\\n    return col; // bounce back.\\n  } else if(col instanceof vis.DataSet) { // a dataset\\n    return col.get({ returnType: \\\"Array\\\" });\\n  }\\n  \\n  var result = [];\\n  var keys = Object.keys(col);\\n  for(var i = keys.length; i--;) {\\n    result.push(col[keys[i]]);\\n  }\\n  \\n  return result;\\n  \\n};\\n\\n\\nutils.getDataUri = function(tiddler, type, isForceBase64) {\\n  \\n  var imgTObj = utils.getTiddler(tiddler);\\n  var type = type || imgTObj.fields.type || \\\"image/svg+xml\\\";\\n  var body = imgTObj.fields.text;\\n  var encoding = $tw.config.contentTypeInfo[type].encoding;\\n  \\n  if(type === \\\"image/svg+xml\\\") {\\n    \\n    // see http://stackoverflow.com/questions/10768451/inline-svg-in-css\\n    body = body.replace(/\\\\r?\\\\n|\\\\r/g, \\\" \\\");\\n    \\n    if(!utils.hasSubString(\\\"xmlns\\\", body)) {\\n      // @tiddlywiki it is bad to remove the xmlns attribute!\\n      \\n      body = body.replace(/<svg/, '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"');\\n    }\\n    \\n  }\\n\\n  if(isForceBase64 && encoding !== \\\"base64\\\") {\\n    encoding = \\\"base64\\\";\\n    body = window.btoa(body);\\n  }\\n  \\n  return \\\"data:\\\" + type + \\\";\\\" + encoding + \\\",\\\" + body;\\n  \\n};\\n\\n/**\\n * @deprecated Use $tw.utils.hop instead\\n * \\n * I use this method on all objects that I didn't create myself.\\n * \\n * Why this? Well,\\n * \\n * 1. How do I know if the object was created via {} or\\n *    utils.makeHashMap()? If the latter is the case,\\n *    `hasOwnProperty()` doesn't exist.\\n * 2. When the object is used as hashtable, hasOwnProperty\\n *    could be overridden.\\n *    \\n * @see http://www.2ality.com/2012/01/objects-as-maps.html\\n * \\n * Hope ECMA6 is out soon with dedicated datastructures.\\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\\n * \\n * @param {Object} obj - The object.\\n * @param {*} key - The key.\\n * @result {boolean} True if key is the own property of obj.\\n */ \\nutils.hasOwnProp = function(obj, key) {\\n  return Object.prototype.hasOwnProperty.call(obj, key);\\n}\\n\\n/**\\n * Factory function to return a prototypeless object that is used as\\n * map. It only has the property hasOwnProperty in order to to be\\n * exchangeble with other framworks that depend on this method like \\n * e.g. visjs.\\n */\\nutils.makeHashMap = function() {\\n  \\n  var map = Object.create(null);\\n  Object.defineProperty(map, \\\"hasOwnProperty\\\", {\\n    enumerable: false,\\n    configurable: false,\\n    writable: false,\\n    value: Object.prototype.hasOwnProperty.bind(map)\\n  });\\n  \\n  return map;\\n  \\n};\\n\\n/**\\n * This function facilitates to check whether a list of tiddlers\\n * matches a certain filter. If the tiddler does not exist, it is not\\n * returned as match. If no list is specified, all tiddlers in\\n * the wiki are considered.\\n * \\n * @Todo: skip drafts! Or not?\\n * \\n * @param {TiddlyWikiFilter} filter - The filter to use.\\n * @param {TiddlerCollection} [tiddlers] - A set of tiddlers used as\\n *     source. If not defined, all tiddlers and system tiddlers are\\n *     selected. Shadows are *not* included.\\n * @return {Array.<TiddlerReference>}\\n */\\nutils.getMatches = function(filter, tiddlers) {\\n      \\n  // use wiki as default source\\n  var source = undefined;\\n  \\n  if(typeof filter === \\\"string\\\") {\\n    filter = $tw.wiki.compileFilter(filter);\\n  }\\n  \\n  // if a source is provided, create an iterator callback\\n  if(tiddlers != null && typeof tiddlers === \\\"object\\\") {\\n  \\n    // shortcuts for performance\\n    var wiki = $tw.wiki;\\n  \\n    if(!Array.isArray(tiddlers)) {\\n      tiddlers = Object.keys(tiddlers);\\n    }\\n    \\n    source = function(callback) {\\n      for(var i = tiddlers.length; i--;) {\\n        var tObj = wiki.getTiddler(tiddlers[i]);\\n        callback(tObj, tiddlers[i]);\\n      }\\n    };\\n    \\n  }\\n\\n  return filter.call($tw.wiki, source);\\n        \\n};\\n\\n// @todo move this to environment\\nvar eTyFiltAutoPrefix = \\\"[all[]] \\\";\\n\\nutils.getEdgeTypeMatches = function(filter, titles) {\\n      \\n  if(!titles) {\\n    var prefix = $tm.path.edgeTypes + \\\"/\\\";\\n    titles = utils.getTiddlersByPrefix(prefix, {\\n      iterator: \\\"eachTiddlerPlusShadows\\\",\\n      removePrefix: true\\n    })\\n  }\\n  \\n  if(titles != null && !Array.isArray(titles)) {\\n    titles = Object.keys(titles);\\n  }\\n  \\n  return utils.getMatches(eTyFiltAutoPrefix + (filter || \\\"\\\"), titles);\\n  \\n};\\n\\nutils.isEdgeTypeMatch = function(title, filter) {\\n    \\n  return utils.isMatch(title, eTyFiltAutoPrefix + (filter || \\\"\\\"));\\n  \\n};\\n\\n/**\\n * Tries to match a single tiddler object against a filter.\\n * Returns a boolean value.\\n * \\n * @param {Tiddler} tiddler - The object to apply the filter to.\\n * @param {TiddlyWikiFilter} filter - The filter to use.\\n * @return {boolean} True if the tiddler matches the filter, false otherwise.\\n */\\nutils.isMatch = function(tiddler, filter) {\\n  \\n  var tRef = utils.getTiddlerRef(tiddler);\\n  var matches = utils.getMatches(filter, [ tRef ]);\\n  \\n  return tRef === matches[0];\\n  \\n};\\n\\n/**\\n * Polyfill until `isInteger` has become official. If the target\\n * value is an integer, return true, otherwise return false.\\n * If the value is NaN or infinite, return false.\\n * \\n * @param {*} value - The value to be tested for being an integer.\\n * @return {boolean} True if the value is an integer, false otherwise.\\n */\\nutils.isInteger = Number.isInteger || function(value) {\\n  return typeof value === \\\"number\\\" && \\n         isFinite(value) && \\n         Math.floor(value) === value;\\n};\\n\\n/**\\n * When we do not know the string, we need to escape it.\\n * @deprecated use tw's escapeRegExp instead\\n */\\nutils.escapeRegex = function(str) {\\n  \\n  return str.replace(/[-$^?.+*[\\\\]\\\\\\\\(){}|]/g, \\\"\\\\\\\\$&\\\");\\n  \\n};\\n\\nutils.replaceAll = function(str, defaultReplacement, subStrings) {\\n  \\n  defaultReplacement = defaultReplacement || \\\"\\\";\\n  \\n  for(var i = subStrings.length; i--;) {\\n    \\n    var subString = subStrings[i];\\n    var replacement = defaultReplacement;\\n    \\n    if(Array.isArray(subString)) {\\n      replacement = subString[1];\\n      subString = subString[0];\\n    }\\n    \\n    str = str.replace(subString, replacement);\\n  }\\n  \\n  return str;\\n  \\n};\\n\\n/**\\n * Sadly, setting fields with tw means that we lose the type information\\n * since field values are persisted as strings and the type is not\\n * included.\\n * \\n * To ensure that flags are always interpreted correctly, the following\\n * function exists.\\n * \\n * We regard the following values as `true` (order matters):\\n * \\n * # Any string that can be translated into a number unequal `0`\\n * # `\\\"true\\\"`\\n * # Any number unequal `0`\\n * # Boolean `true`\\n * \\n * The following as false (order matters):\\n * \\n * # Any string that can be translated into number `0`\\n * # Every string unequal `\\\"true\\\"`\\n * # The number `0`\\n * # Boolean `false`\\n * \\n */\\nutils.isTrue = function(confVal, defVal) {\\n  \\n  if(confVal == null) {\\n    return !!defVal;\\n  } else if(typeof confVal === \\\"string\\\") {\\n    var n = parseInt(confVal);\\n    return (isNaN(n) ? (confVal === \\\"true\\\") : (n !== 0));\\n  } else if(typeof confVal === \\\"boolean\\\") {\\n    return confVal;\\n  } else if(typeof confVal === \\\"number\\\") {\\n    return (n !== 0);\\n  }\\n  \\n  return false;\\n  \\n};\\n\\n/**\\n * Gets a tiddler reference from a tRef or tObj\\n * \\n * @param {Tiddler} tiddler - A tiddler reference or object.\\n * @return {TiddlerReference|undefined} A tiddler reference (title)\\n */\\nutils.getTiddlerRef = function(tiddler) {\\n  \\n  if(tiddler instanceof $tw.Tiddler) {\\n    return tiddler.fields.title;\\n  } else if(typeof tiddler === \\\"string\\\") {\\n    return tiddler;\\n  }\\n  \\n};\\n\\n/**\\n * \\n */\\nutils.getTiddlerNode = function(tiddler) {\\n  \\n  var tRef = utils.getTiddlerRef(tiddler);\\n  return {\\n    type: \\\"tiddler\\\",\\n    attributes: { tiddler: { type: \\\"string\\\", value: tRef } },\\n    children: []\\n  };\\n\\n};\\n\\n/**\\n * \\n */\\nutils.getTranscludeNode = function(tiddler, isBlock) {\\n  \\n  var tRef = utils.getTiddlerRef(tiddler);\\n  return {\\n    type: \\\"transclude\\\",\\n    attributes: { tiddler: { type: \\\"string\\\", value: tRef } },\\n    children: [],\\n    isBlock: !!isBlock\\n  };\\n\\n};\\n\\n/**\\n * \\n */\\nutils.getElementNode = function(type, text, className) {\\n  \\n  var node = {\\n    type: \\\"element\\\",\\n    tag: type,\\n    attributes: { class: { type: \\\"string\\\", value: className }},\\n    children: []\\n  };\\n  \\n  if(text) { node.children.push({type: \\\"text\\\", text: text }); }\\n  \\n  return node;\\n\\n};\\n\\n/**\\n * \\n */\\nutils.registerTransclude = function(widget, name, tiddler, domNode) {\\n  \\n  // if an instance exists, remove it\\n  utils.removeArrayElement(widget.children, widget[name]);\\n  \\n  var node = utils.getTiddlerNode(tiddler);\\n  node.children.push(utils.getTranscludeNode(null, true));\\n  widget[name] = widget.makeChildWidget(node);\\n  widget.children.push(widget[name]);\\n  \\n  return widget[name];\\n  \\n};\\n\\n/**\\n * Similar to {@code wiki.getTiddler()} but also accepts a tObj as\\n * argument, thus, making it unnecessary to always differentiate or remember\\n * if we are dealing with an object or a reference.\\n * \\n * @see https://github.com/Jermolene/TiddlyWiki5/blob/master/boot/boot.js#L866\\n * @param {Tiddler} tiddler - A tiddler reference or object.\\n * @param {boolean} isReload - If set to true the tiddler freshly reloaded\\n *     from the db and any potentially passed tiddler object is ignored.\\n * @return {Tiddler} A tiddler object.\\n */\\nutils.getTiddler = function(tiddler, isReload) {\\n  \\n  if(tiddler instanceof $tw.Tiddler) {\\n    if(!isReload) {\\n      return tiddler;\\n    }\\n    tiddler = tiddler.fields.title;\\n  }\\n  \\n  return $tw.wiki.getTiddler(tiddler);\\n  \\n};\\n\\n/**\\n * Returns the basename of a path. A path is a string with slashes.\\n * \\n * @param {string} path - The path\\n * @return {string} The basename\\n */\\nutils.getBasename = function(path) {\\n  \\n  return path.substring(path.lastIndexOf('/') + 1);\\n  \\n};\\n\\n/**\\n * This function uses the tw-notification mechanism to display a\\n * temporary message.\\n * \\n * @see https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/dom/notifier.js\\n * @param {string} message - A short message to display.\\n */\\nutils.notify = function(message) {\\n  \\n  var tRef = \\\"$:/temp/tiddlymap/notify\\\";\\n  $tw.wiki.addTiddler(new $tw.Tiddler({\\n    title : tRef,\\n    text : message\\n  }));\\n  $tw.notifier.display(tRef);\\n  \\n};\\n\\n/**\\n * Checks if tiddlers (including shadow tiddlers) exist.\\n * \\n * @param {Tiddler} tiddler\\n * @return {boolean} True if the tiddler exists, false otherwise\\n */\\nutils.tiddlerExists = function(tiddler) {\\n  \\n  var tRef = utils.getTiddlerRef(tiddler);\\n  return tRef && ($tw.wiki.tiddlerExists(tRef) || $tw.wiki.isShadowTiddler(tRef));\\n  \\n};\\n\\n/**\\n * The function allows to detect whether a widget is displayed\\n * in preview or not.\\n */\\nutils.isPreviewed = function(widget) {\\n  \\n  if(widget) {\\n    if(widget.getVariable(\\\"tv-tiddler-preview\\\")) {\\n      return true;\\n    } else { // fallback for < v5.1.9\\n      var cls = \\\"tc-tiddler-preview-preview\\\";\\n      return !!utils.getAncestorWithClass(widget.parentDomNode, cls);\\n    }\\n  }\\n  \\n  return false;\\n  \\n};\\n\\n/**\\n * If an ancestor that possesses a specified class exists the the\\n * element will be returned, otherwise undefined is returned.\\n */\\nutils.getAncestorWithClass = function(el, cls) {\\n\\n  if(typeof el !== \\\"object\\\" || typeof cls !== \\\"string\\\") return;\\n\\n  while(el.parentNode) {\\n    el = el.parentNode;\\n    if($tw.utils.hasClass(el, cls)) { return el; }\\n  }\\n  \\n}\\n\\n/**\\n * Returns a new object that contains only properties that start with\\n * a certain prefix. The prefix is optionally removed from the result.\\n * \\n * @param {Object} obj\\n * @param {string} prefix - The start sequence\\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\\n *     from the resulting property name, false otherwise.\\n * @result {object}\\n */\\nutils.getPropertiesByPrefix = function(obj, prefix, removePrefix) {\\n  \\n    var r = utils.makeHashMap();\\n    for(var p in obj) {\\n      if(utils.startsWith(p, prefix)) {\\n        r[(removePrefix ? p.substr(prefix.length) : p)] = obj[p];\\n      }\\n    }\\n  \\n  return r;\\n  \\n};\\n\\n/**\\n * Function to remove the prefix of a string\\n */\\nutils.getWithoutPrefix = function(str, prefix) {\\n\\n  return utils.startsWith(str, prefix)\\n         ? str.substr(prefix.length)\\n         : str;\\n\\n};\\n\\n/**\\n * \\n */\\nutils.hasKeyWithPrefix = function(obj, prefix) {\\n  \\n  for(var p in obj) {\\n    if(utils.startsWith(p, prefix)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n  \\n}\\n\\n\\n\\n/**\\n * Helper to increase the code semantics.\\n * \\n * @param {string} str - The string to work with.\\n * @param {string} prefix - The sequence to test.\\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\\n */\\nutils.startsWith = function(str, prefix) {\\n\\n  return (str.substring(0, prefix.length) === prefix);\\n  \\n};\\n\\n/**\\n * Function to find out whether an object has any enumerable properties\\n * or, in case of an array, elements.\\n * \\n * @param {Object} obj\\n * @return {boolean} True if at least one enumerable property exists,\\n *     false otherwise.\\n */\\nutils.hasElements = function(obj) {\\n  \\n  return (Object.keys(obj).length > 0);\\n  \\n};\\n\\n/**\\n * \\n */\\nutils.groupByProperty = function(col, prop) {\\n  \\n  col = utils.getIterableCollection(col);\\n  \\n  var result = utils.makeHashMap();\\n  var keys = Object.keys(col);\\n  for(var i in keys) {\\n    var item = col[keys[i]];\\n    var val = item[prop];\\n    if(val == null) { // null or undefined\\n      throw \\\"Cannot group by property \\\" + prop;\\n    } else {\\n      if(!Array.isArray(result[val])) {\\n        result[val] = [];\\n      }\\n      result[val].push(item);\\n    }\\n  }\\n  \\n  return result;\\n  \\n};\\n\\n/**\\n * Searches the dom for elements that possess a certain class\\n * and removes this class from each element.\\n * \\n * @param {Array<string>} classNames - The class names to remove.\\n */\\nutils.findAndRemoveClassNames = function(classNames) {\\n  \\n  for(var i = classNames.length; i--;) {\\n    var elements = document.getElementsByClassName(classNames[i]);\\n    for(var j = elements.length; j--;) {\\n      $tw.utils.removeClass(elements[j], classNames[i]);\\n    }\\n  }\\n\\n};\\n\\n/**\\n * Parse json from field or return default value on error.\\n * \\n * @param {Tiddler} tiddler - The tiddler containing the json.\\n * @param {string} field - The field with the json data.\\n * @param {Object} [data] - An optional default value.\\n * @return {*} Either the parsed data or the default data.\\n */\\nutils.parseFieldData = function(tiddler, field, data) {\\n  \\n  var tObj = utils.getTiddler(tiddler);\\n  if(!tObj) return data;\\n  \\n  if(!field) field = \\\"text\\\";\\n  \\n  return utils.parseJSON(tObj.fields[field], data);\\n  \\n};\\n\\n/**\\n * Loads the image from web and passes it to the callback as\\n * object url.\\n */\\nutils.getImgFromWeb = function(imgUri, callback) {\\n  \\n  if(!imgUri || typeof callback !== \\\"function\\\") return;\\n  \\n  var xhr = new XMLHttpRequest();\\n  xhr.open(\\\"GET\\\", imgUri, true);\\n  xhr.responseType = \\\"blob\\\";\\n  xhr.onerror = function(e) { console.log(e); };\\n  xhr.onload = function(e) {\\n    if(this.readyState === 4 && this.status === 200) {\\n      var blob = this.response;\\n      callback(window.URL.createObjectURL(blob));\\n    }\\n  };\\n  \\n  try { xhr.send();  } catch(e) { console.log(e); }\\n  \\n};\\n\\n/**\\n * Try to turn the string into a javascript object. If the\\n * transformation fails, return the optionally provided `data` object.\\n * \\n * @param {string} str - The string to parse.\\n * @param {*} data - The default value if the operation fails.\\n * @return {*} Either the object resulting from the parsing operation\\n *     or `undefined` or `data` if the operation failed.\\n */\\nutils.parseJSON = function(str, data) {\\n\\n  try {\\n    return JSON.parse(str);\\n  } catch(Error) {\\n    return data;\\n  }\\n  \\n};\\n\\n/**\\n * Serialize json data and store it in a tiddler's field.\\n * \\n * @param {Tiddler} tiddler - The tiddler to store the json in.\\n * @param {string} field - The field that will store the json.\\n * @param {Object} data - The json data.\\n * @param {int} [indentation = 0] - the indentation\\n */\\nutils.writeFieldData = function(tiddler, field, data, indentation) {\\n\\n  if(typeof data !== \\\"object\\\") {\\n    return;\\n  }\\n  \\n  indentation = parseInt(indentation), (indentation > 0 ? indentation : 0);\\n  \\n  utils.setField(tiddler, field, JSON.stringify(data, null, indentation));\\n  \\n};\\n\\n/**\\n * Turns the filter expression in a nicely formatted (but unusable)\\n * text, making it easier to edit long filter expressions.\\n * \\n * @param {string} expr - A valid filter expression.\\n * @result {string} A formatted (unusable) filter expression.\\n */\\nutils.getPrettyFilter = function(expr) {\\n    \\n  // remove outer spaces and separate operands\\n  expr = expr.trim().replace(\\\"][\\\", \\\"] [\\\");\\n  \\n  // regex to identify operands \\n  var re = /[\\\\+\\\\-]?\\\\[.+?[\\\\]\\\\}\\\\>]\\\\]/g;\\n  \\n  // get operands\\n  var operands = expr.match(re);\\n  \\n  // replace operands with dummies and trim again to avoid trailing spaces\\n  expr = expr.replace(re, \\\" [] \\\").trim();\\n  \\n  // turn it into an array\\n  var stringsPlusDummies = expr.split(/\\\\s+/);\\n\\n  var operandIndex = 0;\\n  var parts = [];\\n  for(var i = 0; i < stringsPlusDummies.length; i++) {\\n    parts[i] = (stringsPlusDummies[i] === \\\"[]\\\"\\n              ? operands[operandIndex++]\\n              : stringsPlusDummies[i]);\\n  }\\n    \\n  return parts.join(\\\"\\\\n\\\");\\n\\n};\\n\\n/**\\n * Set a tiddler field to a given value.\\n * \\n * Setting the title field to another value will clone the tiddler.\\n * In this case, better use @link{utils.clone} as this is\\n * semantically stronger.\\n * \\n * This method is guarded against\\n * https://github.com/Jermolene/TiddlyWiki5/issues/2025\\n * \\n * @return {$tw.Tiddler|undefined} The tiddler object containing\\n *     the field with the assigned value.\\n */\\nutils.setField = function(tiddler, field, value) {\\n\\n  if(!tiddler || !field) return;\\n\\n  var tRef = utils.getTiddlerRef(tiddler);\\n  var fields = { title: tRef };\\n  fields[field] = value;\\n  \\n  // do not use any tObj provided, it may result in a lost update!\\n  var tObj = $tw.wiki.getTiddler(tRef, true);\\n  \\n  if(field !== \\\"text\\\" && tObj && !tObj.fields.text) {\\n    fields.text = \\\"\\\";\\n  }\\n  \\n  var tObj = new $tw.Tiddler(tObj, fields);\\n  $tw.wiki.addTiddler(tObj);\\n  \\n  return tObj;\\n\\n};\\n\\n/**\\n * Clone a tiddler and give it another title.\\n * This means the tiddlers are equal except from their titles.\\n */\\nutils.clone = function(src, dest) {\\n\\n  utils.setField(src, \\\"title\\\", dest);\\n\\n};\\n\\n/**\\n * Set the value of a data tiddler entry (index) to a given value\\n */\\nutils.setEntry = function(tiddler, prop, value) {\\n\\n  $tw.wiki.setText(utils.getTiddlerRef(tiddler), null, prop, value);\\n\\n};\\n\\n/**\\n * Get the value of a data tiddler entry (index)\\n */\\nutils.getEntry = function(tiddler, prop, defValue) {\\n\\n  var data = $tw.wiki.getTiddlerData(utils.getTiddlerRef(tiddler), {});\\n  return (data[prop] == null ? defValue : data[prop]);\\n  \\n};\\n\\n//~ utils.getNestedProperty = function(obj, propPath) {\\n//~ \\n  //~ propPath = propPath.split(\\\".\\\");\\n  //~ for(var i = propPath.length; i--;) {\\n    //~ if(obj !== null && typeof obj === \\\"object\\\") {\\n      //~ obj = obj[propPath[i]];\\n  //~ }\\n  //~ \\n//~ };\\n\\n/**\\n * Compare versions.\\n * @return {boolean} Unlike `$tw.utils.checkVersions`, this function\\n * only returns true if the left argument is greater than the right\\n * argument.\\n */\\nutils.isLeftVersionGreater = function(v1, v2) {\\n\\n  return v1 !== v2 && $tw.utils.checkVersions(v1, v2);\\n  \\n};\\n\\n\\n\\n\\n/**\\n * Get a tiddler's field value. If the field does not exist or\\n * its value is an empty string, return the default or an empty\\n * string.\\n */\\nutils.getField = function(tiddler, field, defValue) {\\n    \\n  var tObj = utils.getTiddler(tiddler);\\n  return (!tObj\\n          ? defValue || \\\"\\\"\\n          : tObj.fields[field] || defValue || \\\"\\\");\\n  \\n};\\n\\nutils.getText = function(tiddler, defValue) {\\n  \\n  return utils.getField(tiddler, \\\"text\\\", defValue);\\n  \\n};\\n\\nutils.setText = function(tiddler, value) {\\n\\n  utils.setField(tiddler, \\\"text\\\", value);\\n  \\n};\\n\\n/**\\n * Works like get `getElementById()` but is based on a class name.\\n * It will return the first element inside an optional parent (root)\\n * that has a class of this name.\\n * \\n * @param {string} cls - The class name to search for.\\n * @param {DOMElement} [root=document] - The context to search in.\\n * @param {boolean} [isRequired=true] - If true, an exception will be\\n *     thrown if no element can be retrieved. This is important\\n *     when depending on third party modules and class names change!\\n * @throws {utils.exception.EnvironmentError} - May be thrown if\\n *    `isRequired` is set to true.\\n * @return {DOMElement} Either a dom element or null is returned.\\n */\\nutils.getFirstElementByClassName = function(cls, root, isRequired) {\\n      \\n  var el = (root || document).getElementsByClassName(cls)[0];\\n  if(!el && (typeof isRequired === \\\"boolean\\\" ? isRequired : true)) {\\n    var text = \\\"Missing element with class \\\" + cls + \\\" inside \\\" + root;\\n    throw new utils.exception.EnvironmentError(text);\\n  }\\n  \\n  return el;\\n  \\n};\\n    \\n/**\\n * Checks whether a tiddler is a draft or not.\\n * \\n * @param {Tiddler} tiddler - The tiddler to check on.\\n */\\nutils.isDraft = function(tiddler) {\\n\\n  var tObj = utils.getTiddler(tiddler);\\n  return (tObj && tObj.isDraft());\\n\\n};\\n\\nutils.getRandomInt = function(min, max) {\\n  \\n  return Math.floor(Math.random() * (max - min) + min);\\n  \\n};\\n\\nutils.pickRandom = function(arr) {\\n  \\n  return arr[utils.getRandomInt(0, arr.length-1)];\\n  \\n};\\n\\nutils.getRandomLabel = function(options) {\\n  \\n  options = options || {};\\n  \\n  var adjective = [\\n    \\\"exciting\\\", \\\"notable\\\", \\\"epic\\\", \\\"new\\\", \\\"fancy\\\",\\n    \\\"great\\\", \\\"cool\\\", \\\"fresh\\\", \\\"funky\\\", \\\"clever\\\"\\n  ];\\n  \\n  var noun = [\\n    \\\"concept\\\", \\\"idea\\\", \\\"thought\\\", \\\"topic\\\", \\\"subject\\\"\\n  ];\\n  \\n  return \\\"My\\\" \\n         + \\\" \\\" + utils.pickRandom(adjective) + \\\" \\\"\\n         + (options.object || utils.pickRandom(noun))\\n         + (options.plural ? \\\"s\\\" : \\\"\\\");\\n  \\n};\\n\\n/**\\n * Merges `src` into `dest` which means that the merge transforms\\n * the `dest` object itself. If src and dest both have the same\\n * property path, src does only replace the primitive data type\\n * at the end of the path.\\n * \\n * @todo Should null really be skipped or treated as value?\\n * \\n * @param {Object} dest - The destination object.\\n * @param {...Object} src - At least one object to merge into `dest`.\\n * @return {Object} The original `dest` object.\\n */\\nutils.merge = (function() {\\n  \\n  var _merge = function(dest, src) {\\n    \\n    if(typeof dest !== \\\"object\\\") { dest = {}; }\\n    \\n    for(var p in src) {\\n      if(src.hasOwnProperty(p)) {\\n        if(src[p] != null) { // skip null or undefined\\n          dest[p] = (typeof src[p] === \\\"object\\\"\\n                     ? _merge(dest[p], src[p])\\n                     : src[p]); // primitive type, stop recursion\\n        }\\n      }\\n    }\\n      \\n    return dest;\\n  };\\n\\n  return function(dest /*[,src], src*/) {\\n    \\n    // start the merging; i = 1 since first argument is the destination\\n    for(var i = 1, l = arguments.length; i < l; i++) {\\n      var src = arguments[i];\\n      if(src != null && typeof src === \\\"object\\\") {\\n        dest = _merge(dest, src);\\n      }\\n    }\\n    \\n    return dest;\\n\\n  };\\n\\n})();\\n\\n/**\\n * This function will draw a raster on the network canvas that will\\n * adjust to the network's current scaling factor and viewport offset.\\n * \\n * @param {CanvasRenderingContext2D} context - The canvas's context\\n *     passed by vis.\\n * @param {number} scaleFactor - The current scale factor of the network.\\n * @param {Object} viewPosition - Object with x and y that represent the\\n *     current central focus point of the view.\\n * @param {number} rasterSize - The size of the squares that are drawn.\\n * @param {string} color - A string parsed as CSS color value.\\n */\\nutils.drawRaster = function(context, scaleFactor, viewPosition, rasterSize, color) {\\n  \\n  var rasterSize = parseInt(rasterSize) || 10;\\n  var canvas = context.canvas;\\n  var width = canvas.width / scaleFactor;\\n  var height = canvas.width / scaleFactor;\\n  var offsetLeft = viewPosition.x - (width / 2);\\n  var offsetTop = viewPosition.y - (height / 2);\\n      \\n  // draw vertical lines\\n  for(var x = offsetLeft; x < width; x += rasterSize) {\\n    context.moveTo(x, offsetTop);\\n    context.lineTo(x, height);\\n  }\\n      \\n  // draw horizontal lines\\n  for(var y = offsetTop; y < height; y += rasterSize) {\\n    context.moveTo(offsetLeft, y);\\n    context.lineTo(width, y);\\n  }\\n\\n  context.strokeStyle = color || \\\"#D9D9D9\\\";\\n  context.stroke();\\n\\n};\\n\\n/**\\n * Get a tiddler's text or otherwise return a default text.\\n */\\nutils.isSystemOrDraft = function(tiddler) {\\n\\n  if($tw.wiki.isSystemTiddler(utils.getTiddlerRef(tiddler))) {\\n    return true;\\n  }\\n\\n  var tObj = utils.getTiddler(tiddler);\\n  return tObj && tObj.isDraft();\\n  \\n};\\n\\n/**\\n * Function to merge an array of tiddlers into a single tiddler.\\n * \\n * @param {Array<TiddlerReference|TiddlerObject>} tiddlers - The\\n *     tiddlers to merge.\\n * @param {string} [title=null] - The title where the result is\\n *     written to. If not specified, the first array item is used\\n *     as output title.\\n */\\nutils.getMergedTiddlers = function(tiddlers, title) {\\n  \\n  if(!Array.isArray(tiddlers)) return;\\n  \\n  // turn all array elements into tiddler objects\\n  for(var i = tiddlers.length; i--;) {\\n    tiddlers[i] = utils.getTiddler(tiddlers[i]);\\n  }\\n  \\n  if(!tiddlers.length) return;\\n  \\n  tiddlers.push(\\n    { title: (title || tiddlers[0].fields.title) },\\n    $tw.wiki.getModificationFields(),\\n    $tw.wiki.getCreationFields()\\n  );\\n  \\n  // add context for `apply()` function\\n  tiddlers.unshift(null);\\n\\n  return new (Function.prototype.bind.apply($tw.Tiddler, tiddlers));\\n  \\n};\\n\\n/**\\n * Depth first search\\n */\\nutils.getChildWidgetByProperty = function(widget, prop, val) {\\n  \\n  var children = widget.children;\\n  for(var i = children.length; i--;) {\\n    var child = children[i];\\n    if(child[prop] === val) {\\n      return child;\\n    } else {\\n      child = utils.getChildWidgetByProperty(child, prop, val);\\n      if(child) {\\n        return child;\\n      }\\n    }\\n  }\\n    \\n};\\n\\n/**\\n * Adds or removes listeners from the target in capture or\\n * non-capture (bubbling) mode.\\n * \\n * @param {string} task - Either \\\"add\\\" or \\\"remove\\\". Make sure to\\n *     always call add and remove with *excatly* the same listeners\\n *     Note: if you use bind, you change the function object.\\n * @param {Element} target - The element to attach or remove the\\n *     listener to or from.\\n * @param {Object<string, (Function|Array)>} listeners - The key is\\n *     the event name and the value is either a handler function\\n *     or an array where the first index is the handler function and\\n *     the second is a boolean that specifies whether to use capture\\n *     or not.\\n * @param {boolean} [isCapt=false] - Whether to run the handler in\\n *     bubbling or capturing phase.\\n */\\nutils.setDomListeners = function(task, target, listeners, isCapt) {\\n  \\n  isCapt = (typeof isCapt === \\\"boolean\\\" ? isCapt : false);\\n  task = task + \\\"EventListener\\\";\\n  \\n  for(var event in listeners) {\\n    \\n    var l = listeners[event];\\n    \\n    if(typeof l === \\\"function\\\") {\\n      target[task](event, l, isCapt);\\n    } else { // expect Array\\n      target[task](event, l[0], (typeof l[1] === \\\"boolean\\\" ? l[1] : isCapt));\\n    }\\n        \\n  }\\n  \\n};\\n\\n/**\\n * If the array contains the element, the element is removed from\\n * the array in-place and the removed element.\\n */\\nutils.removeArrayElement = function(arr, el) {\\n  \\n  var index = arr.indexOf(el);\\n  if(index > -1) {\\n    return arr.splice(index, 1)[0];\\n  }\\n  \\n};\\n\\n/**\\n * Removes all child nodes of a DOM element. This includes element\\n * and non-element objects.\\n */\\nutils.removeDOMChildNodes = function(el) {\\n  \\n  for(var i = el.childNodes.length; i--;) {\\n    el.removeChild(el.childNodes[i]);\\n  }\\n  \\n};\\n\\n/**\\n * Register listeners to widget using a hashmap.\\n * \\n * @param {Hashmap<Key, Function>} listeners - The listeners to attach.\\n * @param {Widget} widget - the widget to attach the listeners to.\\n * @param {Object} context - The context to bind the listeners to.\\n */\\nutils.addTWlisteners = function(listeners, widget, context) {\\n  for(var id in listeners) {\\n    widget.addEventListener(id, listeners[id].bind(context));\\n  }\\n};\\n\\n/**\\n * Force early binding of functions to this context.\\n * \\n * @param {Array<string>|string} fnNames - The prototype function names\\n *     to bind to this context.\\n */\\nutils.bind = function(context, fnNames) {\\n  \\n  if(typeof fnNames === \\\"string\\\") {\\n    \\n    fnNames = [ fnNames ];\\n    \\n  } else {\\n    \\n    for(var i = fnNames.length; i--;) {\\n      var fn = context[fnNames[i]];\\n      if(typeof fn === \\\"function\\\") {\\n        context[fnNames[i]] = fn.bind(context);\\n      }\\n    }\\n    \\n  }\\n  \\n};\\n\\n/**\\n * Renames all tiddler titles that are prefixed with `oldPrefix`\\n * into titles that are prefixed with `newPrefix` by replacing\\n * `oldPrefix` with `newPrefix`.\\n * \\n * The force option somewhat ensures atomicity.\\n * \\n * @param {string} oldPrefix - Moves all tiddlers with this prefix.\\n * @param {string} newPrefix - All tiddlers moved tiddlers will\\n *     receive this new prefix.\\n * @param {boolean} [isForce=false] - If a new title would override\\n *     an existing title, and `force` is not set, then nothing will\\n *     happen and undefined is returned by the function.\\n * @param {boolean} [isDelete=true] - True, if the tiddlers with the\\n *     old prefix should be deleted or false, if they should be kept.\\n * @returns {Object<string, string>} - A hashmap that maps the old\\n *     and the new path.\\n */\\nutils.mv = function(oldPrefix, newPrefix, isForce, isDelete) {\\n\\n  if(oldPrefix === newPrefix || !oldPrefix || !newPrefix) return;\\n  \\n  isForce = (typeof isForce === \\\"boolean\\\" ? isForce : false);\\n  isDelete = (typeof isDelete === \\\"boolean\\\" ? isDelete : true);\\n  \\n  // prepare\\n  var targets = utils.getTiddlersByPrefix(oldPrefix);\\n  var fromToMapper = utils.makeHashMap();\\n  for(var i = targets.length; i--;) {    \\n    var oldTRef = targets[i];\\n    var newTRef = oldTRef.replace(oldPrefix, newPrefix);\\n    if($tw.wiki.tiddlerExists(newTRef) && !isForce) {\\n      return; // undefined\\n    }\\n    fromToMapper[oldTRef] = newTRef;\\n  }\\n  \\n  for(var oldTRef in fromToMapper) { \\n    utils.setField(oldTRef, \\\"title\\\", fromToMapper[oldTRef]);\\n    if(isDelete) $tw.wiki.deleteTiddler(oldTRef);\\n  }\\n  \\n  return fromToMapper;\\n  \\n};\\n\\n/**\\n * Clones all tiddler titles that are prefixed with `oldPrefix`\\n * into titles that are instead prefixed with `newPrefix`.\\n * \\n * The force option somewhat ensures atomicity.\\n * \\n * @param {string} oldPrefix - Moves all tiddlers with this prefix.\\n * @param {string} newPrefix - All tiddlers moved tiddlers will\\n *     receive this new prefix.\\n * @param {boolean} [isForce=false] - If a new title would override\\n *     an existing title, and `force` is not set, then nothing will\\n *     happen and undefined is returned by the function.\\n * @returns {Object<string, string>} - A hashmap that maps the old\\n *     and the new path.\\n */\\nutils.cp = function(oldPrefix, newPrefix, isForce) {\\n  \\n  return utils.mv(oldPrefix, newPrefix, isForce, false);\\n  \\n};\\n\\n/**\\n * Checks if a value exists in an array. A strict search is used\\n * which means that also the type of the needle in the haystack\\n * is checked.\\n * \\n * @param {*} needle - The searched value.\\n * @param {Array} - The array.\\n * @return Returns true if needle is found in the array, false otherwise. \\n */\\nutils.inArray = function(needle, haystack) {\\n  \\n  return (haystack.indexOf(needle) !== -1);\\n  \\n};\\n\\n/**\\n * Checks if a string exists in a string.\\n */\\nutils.hasSubString = function(str, sub) {\\n  \\n  return (str.indexOf(sub) !== -1);\\n  \\n};\\n\\n/**\\n * Joins all elements of an array into a string where all elements\\n * are wrapped between `left` and `right`.\\n * \\n * @param {Array} arr - The array to perform the join on.\\n * @param {string} left - The wrapping string for the left side.\\n * @param {string} right - The wrapping string for the right side.\\n * @param {string} [separator] - The separator between a wrapped element\\n *     and the next one. Defaults to space.\\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\\n */\\nutils.joinAndWrap = function(arr, left, right, separator) {\\n      \\n  if(!separator) separator = \\\" \\\";\\n  return left + arr.join(right + separator + left) + right;\\n  \\n};\\n\\n/**\\n * Function that searches an array for an object with a property\\n * having a certain value. \\n * \\n * Attention: Not the item itself but the item's key is returned.\\n * \\n * @param {Collection} col - The collection to search in.\\n * @param {string} key - The property name to look for.\\n * @param {*} [val] - An optional value that the object's property must have\\n *     in order to match.\\n * @param {number} [limit] - An optional result limit (>0) to stop the search.\\n * @return {Array<Id>} An array containing the indeces of matching items.\\n */\\nutils.keysOfItemsWithProperty = function(col, key, val, limit) {\\n  \\n  col = utils.getIterableCollection(col);\\n  \\n  var keys = Object.keys(col);\\n  var result = [];\\n  var limit = (typeof limit === \\\"number\\\" ? limit : keys.length);\\n  for(var i = 0, l = keys.length; i < l; i++) {\\n    var index = keys[i];\\n    if(typeof col[index] === \\\"object\\\" && col[index][key]) {\\n      if(!val || col[index][key] === val) {\\n        result.push(index);\\n        if(result.length === limit) {\\n          break;\\n        }\\n      }\\n    }\\n  }\\n  \\n  return result;\\n  \\n};\\n\\n/**\\n * \\n * \\n */\\nutils.keyOfItemWithProperty = function(col, key, val) {\\n  var keys = utils.keysOfItemsWithProperty(col, key, val, 1)\\n  return (keys.length ? keys[0] : undefined);\\n};\\n\\n/**\\n * Delete all tiddlers with a given prefix.\\n * \\n * @param {string} prefix - The prefix\\n */\\nutils.deleteByPrefix = function(prefix, tiddlers) {\\n  \\n  if(!prefix) return;\\n  \\n  tiddlers = tiddlers || $tw.wiki.allTitles();\\n  \\n  var deletedTiddlers = [];\\n  for(var i = tiddlers.length; i--;) {\\n    if(utils.startsWith(tiddlers[i], prefix)) {\\n      $tw.wiki.deleteTiddler(tiddlers[i]);\\n      deletedTiddlers.push(deletedTiddlers[i]);\\n    }\\n  }\\n  \\n  return deletedTiddlers;\\n  \\n};\\n\\n/**\\n * This function will return a collection object whose data can be\\n * via `Object.keys(col)` in a loop.\\n * \\n * @param {Collection} col - A collection\\n * @return {Hashmap} The iterable object.\\n */\\nutils.getIterableCollection = function(col) {\\n  \\n  return (col instanceof vis.DataSet ? col.get() : col);\\n\\n};\\n\\n/**\\n * In a collection where all elements have a **distinct** property\\n * `lookupKey`, use the value of each element's `lookupKey` as key\\n * to identify the object. If no property `lookupKey` is specified,\\n * the collection's values are used as keys and `true` is used as value,\\n * however, if the used keys are not strings, an error is thrown.\\n * \\n * @param {Collection} col - The collection for which to create a lookup table.\\n * @param {string} [lookupKey] - The property name to use as index in\\n *     the lookup table. If not specified, the collection values are tried\\n *     to be used as indeces.\\n * @return {Hashmap} The lookup table.\\n */\\nutils.getLookupTable = function(col, lookupKey) {\\n  \\n  col = utils.getIterableCollection(col);\\n  \\n  var lookupTable = utils.makeHashMap();\\n  \\n  var keys = Object.keys(col);\\n  for(var i = 0, l = keys.length; i < l; i++) {\\n    \\n    var key = keys[i];\\n    \\n    // value to be used as the lookup table's index\\n    var idx = (lookupKey ? col[key][lookupKey] : col[key]);\\n    \\n    var type = typeof idx;\\n    if((type === \\\"string\\\" && idx !== \\\"\\\") || type === \\\"number\\\") {\\n      if(!lookupTable[idx]) { // doesn't exist yet!\\n        lookupTable[idx] = (lookupKey ? col[key] : true);\\n        continue;\\n      }\\n    }\\n\\n    // in any other case\\n    throw \\\"TiddlyMap: Cannot use \\\\\\\"\\\" + ltIndex + \\\"\\\\\\\" as lookup table index\\\";\\n    \\n  }\\n  \\n  return lookupTable;\\n    \\n};\\n  \\n/**\\n * Remove any newline from a string\\n */\\nutils.getWithoutNewLines = function(str) {\\n  if(typeof str === \\\"string\\\") {\\n    return str.replace(/[\\\\n\\\\r]/g, \\\" \\\");\\n  }\\n};\\n  \\n/**\\n * Wrapper for {@link utils.getLookupTable}\\n */\\nutils.getArrayValuesAsHashmapKeys = function(arr) {\\n  \\n  return utils.getLookupTable(arr);\\n  \\n};\\n\\n/**\\n * Returns all tiddlers that possess a property with a certain value.\\n * \\n * @param {string} fieldName - The property name to look for.\\n * @param {string} [value] - If provided, the field's value must\\n *     equal this value in order to match.\\n * @param {Hashmap} [options] - Further options.\\n * @param {TiddlerCollection} [options.tiddlers=$tw.wiki.allTitles()] - A collection\\n *     of tiddlers to perform the search on.\\n * @param {boolean} [options.isIncludeDrafts=false] - True if drafts of the found\\n *     tiddlers are also included in the result set.\\n * @param {number} [options.limit] - A positive number delimiting the maximum\\n *     number of results.\\n *     tiddlers are also included in the result set.\\n * @return {Hashmap.<TiddlerReference, Tiddler>} Result\\n */\\nutils.getTiddlersWithField = function(fieldName, value, options) {\\n  \\n  if(!options || typeof options !== \\\"object\\\") options = {};\\n      \\n  var tiddlers = options.tiddlers || $tw.wiki.allTitles();\\n  var limit = options.limit || 0;\\n  var isIncludeDrafts = (options.isIncludeDrafts === true);\\n  var result = utils.makeHashMap();\\n  var keys = Object.keys(tiddlers);\\n  var hasOwnProp = $tw.utils.hop;\\n  for(var i = keys.length; i--;) {\\n    var tObj = utils.getTiddler(tiddlers[keys[i]]);\\n    var fields = tObj.fields;\\n    if(hasOwnProp(fields, fieldName)\\n       && (!hasOwnProp(fields, \\\"draft.of\\\") || isIncludeDrafts)) {\\n      if(!value || fields[fieldName] === value ) {\\n        result[fields.title] = tObj;\\n        if(--limit === 0) break;\\n      }\\n    }\\n  }\\n      \\n  return result;\\n  \\n};\\n\\nutils.getTiddlerWithField = function(name, value) {\\n  \\n  var result = utils.getTiddlersWithField(name, value, { limit: 1 });\\n  return Object.keys(result)[0];\\n  \\n};\\n\\n/**\\n * Iterates over all tiddlers in a given way and returns tiddlers\\n * whose title matches the prefix string.\\n * \\n * @param {string} prefix - The prefix to match\\n * @param {Hashmap} [options] - An options object.\\n * @param {string} [options.iterator=\\\"each\\\"] - A tw store iterator\\n *    function, e.g. \\\"eachShadow\\\" or \\\"ShadowPlusTiddlers\\\".\\n * @param {boolean} [options.removePrefix= false] - Whether to remove\\n *     the prefix or to leave it.\\n * @return {Array<string>} The matches with or without the prefix.\\n */\\nutils.getTiddlersByPrefix = function(prefix, options) {\\n  \\n  options = options || {};\\n\\n  var removePrefix = (options.removePrefix === true);                \\n  var result = [];\\n  $tw.wiki[options.iterator || \\\"each\\\"](function(tObj, tRef) {\\n    if(utils.startsWith(tRef, prefix)) {\\n      result.push(removePrefix\\n                  ? utils.getWithoutPrefix(tRef, prefix)\\n                  : tRef);\\n    }\\n  });\\n      \\n  return result;\\n  \\n};\\n\\n/**\\n * Advanced addTiddler method.\\n * \\n * It adds timestamps and only adds the tiddler if it doesn't exist\\n * yet or the force option is used.\\n * \\n * This method is guarded against\\n * https://github.com/Jermolene/TiddlyWiki5/issues/2025\\n */\\nutils.addTiddler = function(tiddler, isForce) {\\n  \\n  var tObj = utils.getTiddler(tiddler);\\n  if(!isForce && tObj) return tObj;\\n  \\n  tObj = new $tw.Tiddler({\\n                           title: tiddler,\\n                           text: \\\"\\\"\\n                         },\\n                         $tw.wiki.getModificationFields(),\\n                         $tw.wiki.getCreationFields());\\n  \\n  $tw.wiki.addTiddler(tObj);\\n  \\n  return tObj;\\n  \\n};\\n\\nutils.getSnapshotTitle = function(viewLabel, type) {\\n    \\n  return \\\"Snapshot – \\\"\\n         + viewLabel\\n         + \\\" (\\\" + new Date().toDateString() + \\\")\\\"\\n         + \\\".\\\" + (type || \\\"png\\\");\\n  \\n};\\n  \\n/**\\n * Contains all TiddlyMap exceptions\\n */\\nutils.exception = exception;\\n\\n/**\\n * URL parsing\\n */\\nutils.URL = URL;\\n\\n/************************* 3rd-party code **************************/\\n\\n/**\\n * Modified TW-Code from Navigator widget\\n * https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/widgets/navigator.js\\n */\\nutils.makeDraftTiddler = function(targetTitle) {\\n  \\n  // See if there is already a draft tiddler for this tiddler\\n  var draftTitle = $tw.wiki.findDraft(targetTitle);\\n  if(draftTitle) {\\n    return $tw.wiki.getTiddler(draftTitle);\\n  }\\n  // Get the current value of the tiddler we're editing\\n  var tiddler = $tw.wiki.getTiddler(targetTitle);\\n  // Save the initial value of the draft tiddler\\n  draftTitle = utils.generateDraftTitle(targetTitle);\\n  var draftTiddler = new $tw.Tiddler(\\n      tiddler,\\n      {\\n        title: draftTitle,\\n        \\\"draft.title\\\": targetTitle,\\n        \\\"draft.of\\\": targetTitle\\n      },\\n      $tw.wiki.getModificationFields()\\n  );\\n  $tw.wiki.addTiddler(draftTiddler);\\n  return draftTiddler;\\n  \\n};\\n\\n/**\\n * Modified TW-Code from Navigator widget\\n * https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/widgets/navigator.js\\n */\\nutils.generateDraftTitle = function(title) {\\n  \\n  var c = 0,\\n    draftTitle;\\n  do {\\n    draftTitle = \\\"Draft \\\" + (c ? (c + 1) + \\\" \\\" : \\\"\\\") + \\\"of '\\\" + title + \\\"'\\\";\\n    c++;\\n  } while($tw.wiki.tiddlerExists(draftTitle));\\n  return draftTitle;\\n  \\n};\\n\\nutils.touch = function(tRef) {\\n  \\n  utils.setField(tRef, \\\"modified\\\", new Date());\\n  \\n};\\n\\n/**\\n * TW-Code\\n * @deprecated delete this in 2016 and use $tw.utils.getFullScreenApis instead\\n */\\nutils.getFullScreenApis = function() {\\n  \\n  var d = document,\\n    db = d.body,\\n    result = {\\n    \\\"_requestFullscreen\\\": db.webkitRequestFullscreen !== undefined ? \\\"webkitRequestFullscreen\\\" :\\n              db.mozRequestFullScreen !== undefined ? \\\"mozRequestFullScreen\\\" :\\n              db.msRequestFullscreen !== undefined ? \\\"msRequestFullscreen\\\" :\\n              db.requestFullscreen !== undefined ? \\\"requestFullscreen\\\" : \\\"\\\",\\n    \\\"_exitFullscreen\\\": d.webkitExitFullscreen !== undefined ? \\\"webkitExitFullscreen\\\" :\\n              d.mozCancelFullScreen !== undefined ? \\\"mozCancelFullScreen\\\" :\\n              d.msExitFullscreen !== undefined ? \\\"msExitFullscreen\\\" :\\n              d.exitFullscreen !== undefined ? \\\"exitFullscreen\\\" : \\\"\\\",\\n    \\\"_fullscreenElement\\\": d.webkitFullscreenElement !== undefined ? \\\"webkitFullscreenElement\\\" :\\n              d.mozFullScreenElement !== undefined ? \\\"mozFullScreenElement\\\" :\\n              d.msFullscreenElement !== undefined ? \\\"msFullscreenElement\\\" :\\n              d.fullscreenElement !== undefined ? \\\"fullscreenElement\\\" : \\\"\\\",\\n    \\\"_fullscreenChange\\\": d.webkitFullscreenElement !== undefined ? \\\"webkitfullscreenchange\\\" :\\n              d.mozFullScreenElement !== undefined ? \\\"mozfullscreenchange\\\" :\\n              d.msFullscreenElement !== undefined ? \\\"MSFullscreenChange\\\" :\\n              d.fullscreenElement !== undefined ? \\\"fullscreenchange\\\" : \\\"\\\"\\n  };\\n  if(!result._requestFullscreen || !result._exitFullscreen || !result._fullscreenElement) {\\n    return null;\\n  } else {\\n    return result;\\n  }\\n  \\n};\\n\\n/**\\n * \\n * Slightly modified by me to allow an optional prefix.\\n * \\n * For the original code:\\n * \\n * Copyright (c) 2014, Hugh Kennedy, All rights reserved.\\n * Code published under the BSD 3-Clause License\\n * \\n * @see oringal repo https://github.com/hughsk/flat\\n * @see snapshot https://github.com/felixhayashi/flat\\n * @see http://opensource.org/licenses/BSD-3-Clause\\n */\\nutils.flatten = function(target, opts) {\\n  \\n  opts = opts || {}\\n\\n  var delimiter = opts.delimiter || '.'\\n  var prefix = opts.prefix || ''\\n  var output = {}\\n\\n  function step(object, prev) {\\n    Object.keys(object).forEach(function(key) {\\n      var value = object[key]\\n      var isarray = opts.safe && Array.isArray(value)\\n      var type = Object.prototype.toString.call(value)\\n      var isobject = (\\n        type === \\\"[object Object]\\\" ||\\n        type === \\\"[object Array]\\\"\\n      )\\n\\n      var newKey = prev\\n        ? prev + delimiter + key\\n        : prefix + key\\n\\n      if (!isarray && isobject) {\\n        return step(value, newKey)\\n      }\\n\\n      output[newKey] = value\\n    })\\n  }\\n\\n  step(target)\\n\\n  return output;\\n  \\n};\\n\\n\\n/**\\n * Copyright (c) 2014, Hugh Kennedy, All rights reserved.\\n * Code published under the BSD 3-Clause License\\n * \\n * @see oringal repo https://github.com/hughsk/flat\\n * @see snapshot https://github.com/felixhayashi/flat\\n * @see http://opensource.org/licenses/BSD-3-Clause\\n */\\nutils.unflatten = function(target, opts) {\\n  \\n  opts = opts || {}\\n\\n  var delimiter = opts.delimiter || '.'\\n  var result = {}\\n\\n  if (Object.prototype.toString.call(target) !== '[object Object]') {\\n    return target\\n  }\\n\\n  // safely ensure that the key is\\n  // an integer.\\n  function getkey(key) {\\n    var parsedKey = Number(key)\\n\\n    return (\\n      isNaN(parsedKey) ||\\n      key.indexOf('.') !== -1\\n    ) ? key\\n      : parsedKey\\n  }\\n\\n  Object.keys(target).forEach(function(key) {\\n    var split = key.split(delimiter)\\n    var key1 = getkey(split.shift())\\n    var key2 = getkey(split[0])\\n    var recipient = result\\n\\n    while (key2 !== undefined) {\\n      if (recipient[key1] === undefined) {\\n        recipient[key1] = (\\n          typeof key2 === 'number' &&\\n          !opts.object ? [] : {}\\n        )\\n      }\\n\\n      recipient = recipient[key1]\\n      if (split.length > 0) {\\n        key1 = getkey(split.shift())\\n        key2 = getkey(split[0])\\n      }\\n    }\\n\\n    // unflatten again for 'messy objects'\\n    recipient[key1] = utils.unflatten(target[key], opts)\\n  })\\n\\n  return result;\\n\\n};\\n\\n\\n/**\\n * An adopted version of pmario's version to create\\n * uuids of type RFC4122, version 4 ID.\\n * \\n * Shortened version:\\n * pmario (1.0 - 2011.05.22):\\n * http://chat-plugins.tiddlyspace.com/#UUIDPlugin\\n * \\n * Original version:\\n * Math.uuid.js (v1.4)\\n * http://www.broofa.com\\n * mailto:robert@broofa.com\\n * \\n * Copyright (c) 2010 Robert Kieffer\\n * Dual licensed under the MIT and GPL licenses.\\n * \\n * ---\\n * @see https://github.com/almende/vis/issues/432\\n*/\\nutils.genUUID = (function() {\\n  \\n  // Private array of chars to use\\n  var CHARS = '0123456789abcdefghijklmnopqrstuvwxyz'.split(''); \\n\\n  return function () {\\n    var chars = CHARS, uuid = new Array(36);\\n\\n    var rnd=0, r;\\n    for (var i = 0; i < 36; i++) {\\n      if (i==8 || i==13 ||  i==18 || i==23) {\\n        uuid[i] = '-';\\n      } else if (i==14) {\\n        uuid[i] = '4';\\n      } else {\\n        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\\n        r = rnd & 0xf;\\n        rnd = rnd >> 4;\\n        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\\n      }\\n    } \\n    \\n    return uuid.join('');\\n  };\\n\\n})();\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/utils\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = ViewAbstraction;\\n\\n/*** Imports *******************************************************/\\n\\nvar EdgeType = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar utils    = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n  \\n/*** Code **********************************************************/\\n\\n/**\\n * This class abstracts the various pieces that together make up the\\n * view such as map, edge filter, node filter, config etc.\\n * If {@code isCreate} is not specified, the viewAbstraction will only\\n * represent the view and not create it or any missing part of it.\\n * \\n * @param {string|ViewAbstraction|Tiddler} view - The view\\n * @param {boolean} [isCreate] - True if the view should be created and override\\n *     any existing view, false otherwise.\\n * @constructor\\n */\\nfunction ViewAbstraction(view, options) {\\n  \\n  options = options || {};\\n\\n  // register shortcuts and aliases\\n  this._edgeTypePath = $tm.path.edgeTypes;\\n\\n  if(view instanceof ViewAbstraction) {\\n    // bounce back the object we received\\n    return view;\\n  }\\n\\n  // start building paths\\n  this._registerPaths(view, options.isCreate);\\n        \\n  if(options.isCreate) {\\n    \\n    this._createView(options);\\n    \\n  } else if(!this.exists()) { // no valid config path\\n    \\n    // if the view doesn't exist, then we return a dummy object\\n    // whose sole purpose is to tell the world that this\\n    // view doesn't exist.\\n    return { exists: function() {  return false; } };\\n    \\n  }\\n    \\n  // force complete rebuild\\n  this.rebuildCache();\\n  \\n};\\n\\n/**\\n * If a ViewAbstraction instance has been modified and changes\\n * have been persisted, then the next refresh cycle would trigger\\n * a rebuild of the cache since tiddlers related to this view\\n * changed. To avoid this, all functions that modify the state\\n * of this view related to cached properties need to set a flag\\n * in this variable. This flag prevents a rebuild in the next\\n * refresh cycle.\\n *\\n * NOTE: This is done for mere performance reasons, if some\\n * function is implemented without setting this flag to true\\n * at the end, it doesn't real cause trouble.\\n * \\n */\\nViewAbstraction.prototype._noNeedToRebuildCache = false;\\n\\n/**\\n * \\n */\\nViewAbstraction.prototype._registerPaths = function(view, isCreate) {\\n  \\n  // attention: To ensure that the refresh mechanism detects changes,\\n  // comp is only allowed to have direct child properties\\n  this.comp = this.comp || utils.makeHashMap(); \\n  this.comp.config = this._getConfigPath(view, isCreate);\\n  \\n  // the view's store (=local store) for node properties\\n  this.comp.map = this.comp.config + \\\"/map\\\";\\n  \\n  // filter stores\\n  this.comp.nodeFilter = this.comp.config + \\\"/filter/nodes\\\";\\n  this.comp.edgeTypeFilter = this.comp.config + \\\"/filter/edges\\\";\\n  \\n};\\n\\n/**\\n * Will try to translate the constructor param into the config path.\\n * \\n * @private\\n * @param {*} view - The constructor param to abstract or create the view.\\n * @param {boolean} isCreate - If true and the supplied view did not\\n *     result in a proper path, we will create one.\\n * @result {string|undefined} The path or undefined if translation failed.\\n */\\nViewAbstraction.prototype._getConfigPath = function(view, isCreate) {\\n\\n  if(view instanceof $tw.Tiddler) { // is a tiddler object\\n    return view.fields.title;\\n  }\\n  \\n  if(typeof view === \\\"string\\\") {\\n      \\n    // remove prefix and slash\\n    view = utils.getWithoutPrefix(view, $tm.path.views + \\\"/\\\");\\n\\n    if(view && !utils.hasSubString(view, \\\"/\\\")) {\\n      // a valid label must not contain any slashes\\n      return $tm.path.views + \\\"/\\\" + view; // add prefix (again)\\n    }\\n  }\\n  \\n  if(isCreate) {\\n    var t = $tm.path.views + \\\"/\\\" + utils.getRandomLabel({ plural: true });\\n    return $tw.wiki.generateNewTitle(t);\\n  }\\n  \\n};\\n\\n/**\\n * A hashmap of all paths (tiddler titles) that make up this view.\\n * \\n * @return {Hashmap} The paths.\\n */\\nViewAbstraction.prototype.getPaths = function() {\\n  \\n  return this.comp;\\n  \\n};\\n\\n/**\\n * Will create the config tiddler which means that the view will\\n * start to exist.\\n * \\n * @private\\n */\\nViewAbstraction.prototype._createView = function(options) {\\n  \\n  // destroy any former view that existed in this path\\n  if(this.exists()) {\\n    \\n    if(!options.isForce) return;\\n    \\n    this.destroy();\\n  }\\n  \\n  var protoView = new ViewAbstraction(options.protoView);\\n  if(protoView.exists()) {\\n    var results = utils.cp(protoView.getRoot(), this.comp.config, true);\\n  }\\n    \\n  // create new view\\n  var fields = {};\\n  fields.title = this.comp.config;\\n  \\n  if(!options.isHidden) {\\n    fields[$tm.field.viewMarker] = true;\\n  }\\n  \\n  // an id is actually not used for view in TM, I just reserve it…\\n  fields.id = utils.genUUID();\\n  \\n  $tw.wiki.addTiddler(new $tw.Tiddler(\\n    utils.getTiddler(this.comp.config), // in case we cloned the view\\n    fields\\n  ));\\n  \\n  this.setEdgeTypeFilter($tm.filter.defaultEdgeTypeFilter);\\n    \\n};\\n\\nViewAbstraction.prototype.isLocked = function() {\\n  \\n  return $tw.wiki.isShadowTiddler(this.comp.config);\\n  \\n};\\n\\n/**\\n * \\n * @see ViewAbstraction#rebuildCache\\n * \\n * @return {boolean} True if the instance has updated itself\\n */\\nViewAbstraction.prototype.update = function(updates) {\\n  \\n  var changedTiddlers = updates.changedTiddlers;\\n  \\n  if(updates[$tm.path.edgeTypes]\\n     || utils.hasKeyWithPrefix(changedTiddlers, this.comp.config)) {\\n    \\n    this.rebuildCache();\\n    \\n    return true;\\n    \\n  }\\n  \\n};\\n\\n/**\\n * This method will rebuild the cache.\\n */\\nViewAbstraction.prototype.rebuildCache = function(isForce) {\\n  \\n  if(!isForce && this._noNeedToRebuildCache) {\\n    this._noNeedToRebuildCache = false;\\n    return;\\n  }\\n  \\n  this.config = this.getConfig(null, true);\\n  this.nodeData = this.getNodeData(null, true);\\n  this.nodeFilter = this.getNodeFilter(null, true);\\n  this.edgeTypeFilter = this.getEdgeTypeFilter(null, true);\\n  \\n};\\n\\n/**\\n * clones the tiddler denoted via tRef and uses it as placeholder\\n * for this view when a widget using this view is displayed in\\n * static mode\\n */\\nViewAbstraction.prototype.addPlaceholder = function(tRef) {\\n  \\n  utils.cp(tRef, this.getRoot() + \\\"/snapshot\\\", true);\\n  \\n}\\n\\n/**\\n * A view exists if the constructor parameter was successfully\\n * translated into a {@link TiddlerReference} that corresponds to\\n * an existing view tiddler in the store.\\n * \\n * @return {boolean} True if it exists, false otherwise.\\n */\\nViewAbstraction.prototype.exists = function() {\\n  return utils.tiddlerExists(this.comp.config);\\n};\\n\\n/**\\n * The path to the config tiddler that represents the view.\\n * \\n * @return {TiddlerReference} The view path.\\n */\\nViewAbstraction.prototype.getRoot = function() {\\n  return this.comp.config;\\n};\\n\\n/**\\n * Returns this view's creation date.\\n * \\n * @param {boolean} [asString] True if the returned value should be\\n *     a string in any case.\\n * @return {string|object|undefined} The creation date in the specified\\n *     output format.\\n */\\nViewAbstraction.prototype.getCreationDate = function(asString) {\\n    \\n  var val = $tw.wiki.getTiddler(this.comp.config).fields[\\\"created\\\"];\\n  if(asString) { \\n    // note: th will be translated as well!\\n    return (val instanceof Date\\n            ? $tw.utils.formatDateString(val, \\\"DDth MMM YYYY\\\")\\n            : \\\"\\\");\\n  }\\n  \\n  return val;\\n  \\n};\\n\\n/**\\n * The label of the view (which is basically the roots basename).\\n * \\n * @return {string} The label (name) of the view.\\n */\\nViewAbstraction.prototype.getLabel = function() {\\n    \\n  return utils.getBasename(this.comp.config);\\n  \\n};\\n\\n/**\\n * Method to remove all tiddlers prefixed with the views root. This\\n * will make the view non-existent.\\n * \\n * ATTENTION: Do not use the object anymore after you called\\n * this function!\\n */\\nViewAbstraction.prototype.destroy = function() {\\n  \\n  // delete the view and all tiddlers stored in its path (map, edge-filter etc.)\\n  var filter = \\\"[prefix[\\\" + this.getRoot() + \\\"]]\\\";\\n  utils.deleteTiddlers(utils.getMatches(filter));\\n    \\n};\\n\\n/**\\n * \\n */\\nViewAbstraction.prototype.getOccurrences = function() {\\n  \\n  var filter = \\\"[regexp:text[<\\\\\\\\$(tiddlymap|tmap).*?view=.\\\"\\n               + this.getLabel()\\n               + \\\"..*?>]]\\\";\\n  return utils.getMatches(filter);\\n  \\n};\\n\\nViewAbstraction.prototype.rename = function(newLabel) {\\n\\n  if(typeof newLabel !== \\\"string\\\") return false;\\n    \\n  if(utils.inArray(\\\"/\\\", newLabel)) {\\n    $tm.notify(\\\"A view name must not contain any \\\\\\\"/\\\\\\\"\\\");\\n    return false;\\n  }\\n  \\n  // keep a reference to the old label before we change it\\n  var oldLabel = this.getLabel();\\n  \\n  // start the renaming\\n  var newRoot = $tm.path.views + \\\"/\\\" + newLabel;\\n  var oldRoot = this.getRoot();\\n  var results = utils.mv(oldRoot, newRoot, true);\\n  \\n  // update references\\n  \\n  if($tm.config.sys.defaultView === oldLabel) {\\n     utils.setEntry($tm.ref.sysUserConf,\\n                    \\\"defaultView\\\",\\n                    newLabel);\\n  }\\n  \\n  if($tm.config.sys.liveTab.fallbackView === oldLabel) {\\n     utils.setEntry($tm.ref.sysUserConf,\\n                    \\\"liveTab.fallbackView\\\",\\n                    newLabel);\\n  }\\n  \\n  $tw.wiki.each(function(tObj, tRef) {\\n    \\n    if(tObj.fields[\\\"tmap.open-view\\\"] === oldLabel) {\\n      \\n      // update global node data fields referencing this view\\n      utils.setField(tRef, \\\"tmap.open-view\\\", newLabel);\\n      \\n    } else if(utils.startsWith(tRef, $tm.path.views)) {\\n      \\n      // update all local node data referencing this view\\n      var view = new ViewAbstraction(tRef);\\n      if(!view.exists()) return;\\n      \\n      var nodes = view.getNodeData();\\n      for(var id in nodes) {\\n        if(nodes[id][\\\"open-view\\\"] === oldLabel) {\\n          nodes[id][\\\"open-view\\\"] = newLabel;\\n        }\\n      }\\n      view.saveNodeData(nodes);\\n      \\n    }\\n    \\n  });\\n  \\n  this._registerPaths(newLabel);\\n  this.rebuildCache();\\n    \\n};\\n\\n/**\\n * All configurations that are toggled via checkboxes to have a value\\n * either `true` or `false` can be accessed via this method.\\n * \\n * @param {string} name - The configs name without the `_config` prefix.\\n * @return {boolean} True if the configuration is enabled, false otherwise.\\n */\\nViewAbstraction.prototype.isEnabled = function(name) {\\n  \\n  return utils.isTrue(this.getConfig(name), false);\\n  \\n};\\n\\n/**\\n * Returns a configuration value relating to the given name. If no name\\n * is given, an object with all configurations is returned.\\n * \\n * @param {string} [name] - Instead of all configurations being returned,\\n *     only the configuration named name is returned. The initial \\\"config.\\\"\\n *     may be omitted.\\n * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\\n * @result {string|Object} If `type` is not specified an object containing\\n *     all configurations is returned, otherwise a single value will be returned.\\n */\\nViewAbstraction.prototype.getConfig = function(name, isRebuild, defValue) {\\n  \\n  if(!isRebuild && this.config) {\\n    \\n    var config = this.config;\\n    \\n  } else {\\n    \\n    var fields = $tw.wiki.getTiddler(this.comp.config).fields;\\n    var config = utils.getPropertiesByPrefix(fields, \\\"config.\\\");\\n    \\n  }\\n  \\n  // TODO use regex to add \\\"config.\\\"\\n  return (name\\n          ? config[(utils.startsWith(name, \\\"config.\\\") ? name : \\\"config.\\\" + name)]\\n          : config);\\n  \\n};\\n\\n/**\\n * If the active layout is set to *hierarchical*, this function will\\n * return all edges that define the hierarchical order of this view.\\n * If the layout is not set to *hierarchical*, an empty array is\\n * returned.\\n * \\n * @return {Array<string>} A list of edge labels of edges that define\\n *     the hierarchy.\\n */\\nViewAbstraction.prototype.getHierarchyEdgeTypes = function() {\\n  \\n  if(this.getConfig(\\\"layout.active\\\") !== \\\"hierarchical\\\") return [];\\n  \\n  var orderByEdges = utils.getPropertiesByPrefix(this.getConfig(), \\\"config.layout.hierarchical.order-by-\\\", true);\\n  \\n  var labels = utils.makeHashMap();\\n  for(var id in orderByEdges) {\\n    if(orderByEdges[id] === \\\"true\\\") {\\n      var tObj = utils.getTiddler($tm.indeces.tById[id]);\\n      if(tObj) {\\n        labels[utils.getBasename(tObj.fields.title)] = true;\\n      }\\n    }\\n  }\\n        \\n  return labels;\\n  \\n};\\n\\n/**\\n * \\n */\\nViewAbstraction.prototype.setConfig = function() {\\n  \\n  var args = arguments;\\n  \\n  if(args[0] == null) return; // null or undefined\\n  \\n  if(args.length === 1 && typeof args[0] === \\\"object\\\") {\\n    \\n    for(var prop in args[0]) {\\n      this.setConfig(prop, args[0][prop]);\\n    }\\n    \\n  } else if(args.length === 2 && typeof args[0] === \\\"string\\\") {\\n    \\n    var prop = utils.getWithoutPrefix(args[0], \\\"config.\\\");\\n    var val = args[1];\\n    \\n    if(val === undefined) return;\\n    \\n    if(val === null) {\\n      \\n      $tm.logger(\\\"debug\\\", \\\"Removing config\\\", prop);\\n      delete this.config[\\\"config.\\\"+prop]; // todo set this to null\\n      \\n    } else {\\n      \\n      if(prop === \\\"edge_type_namespace\\\") {\\n        var match = val.match(/[^:]+/);\\n        val = (match ? match[0] : \\\"\\\");\\n      }\\n      \\n    }\\n    \\n    $tm.logger(\\\"log\\\", \\\"Setting config\\\", prop, val);\\n    this.config[\\\"config.\\\"+prop] = val;\\n\\n    \\n  } else { // not allowed\\n    \\n    return;\\n    \\n  }\\n  \\n  // save\\n  $tw.wiki.addTiddler(new $tw.Tiddler(\\n    $tw.wiki.getTiddler(this.comp.config),\\n    this.config\\n  ));\\n\\n  this._noNeedToRebuildCache = true;\\n  \\n};\\n\\n/**\\n * Whether the node is already explicitly contained in the filter,\\n * i.e. whether it is explicitly referenced by its title.\\n */\\nViewAbstraction.prototype.isExplicitNode = function(node) {\\n  \\n  // @Todo: this way of testing is not 100% save as a node might\\n  // have been added to the filter explicitly AND via a group filter.\\n  var regex = $tw.utils.escapeRegExp(this._getAddNodeFilterPart(node));\\n  return this.getNodeFilter(\\\"raw\\\").match(regex);\\n             \\n};\\n\\nViewAbstraction.prototype.isLiveView = function() {\\n  \\n  return (this.getLabel() === $tm.misc.liveViewLabel);\\n  \\n};\\n\\nViewAbstraction.prototype._getAddNodeFilterPart = function(node) {\\n  \\n  if(!node) { throw \\\"Supplied param is not a node!\\\"; }\\n  \\n  var id = (typeof node === \\\"object\\\" ? node.id : node);\\n  return \\\"[field:tmap.id[\\\" + id + \\\"]]\\\";\\n  \\n};\\n\\n/**\\n * Sets and rebuilds the node filter according to the expression provided.\\n * \\n * @param {string} expr - A tiddlywiki filter expression.\\n */\\nViewAbstraction.prototype.setNodeFilter = function(expr, force) {\\n        \\n  expr = expr.replace(/[\\\\n\\\\r]/g, \\\" \\\");\\n  \\n  if(this.getNodeFilter(\\\"raw\\\") === expr) {\\n    // already up to date;\\n    // This check is critical to prevent recursion!\\n    return;\\n  }\\n  \\n  if(this.isLiveView() && !force) {\\n    var text = \\\"You must not change the live view's node filter!\\\";\\n    $tm.notify(text);\\n    return;\\n  }\\n      \\n  utils.setField(this.comp.nodeFilter, \\\"filter\\\", expr);\\n  \\n  $tm.logger(\\\"debug\\\",\\\"Node filter set to\\\", expr);\\n\\n  // rebuild filter now and prevent another rebuild at refresh\\n  this.nodeFilter = this.getNodeFilter(null, true);\\n  \\n  this._noNeedToRebuildCache = true;\\n  \\n};\\n\\nViewAbstraction.prototype.setEdgeTypeFilter = function(expr) {\\n    \\n  expr = expr.replace(/[\\\\n\\\\r]/g, \\\" \\\");\\n  \\n  if(this.getEdgeTypeFilter(\\\"raw\\\") === expr) { // already up to date\\n    // This check is critical to prevent recursion!\\n    return;\\n  }\\n  \\n  utils.setField(this.comp.edgeTypeFilter, \\\"filter\\\", expr);\\n  \\n  $tm.logger(\\\"debug\\\",\\\"Edge filter set to\\\", expr);\\n\\n  // rebuild filter now \\n  this.edgeTypeFilter = this.getEdgeTypeFilter(null, true);\\n  \\n  // and prevent another unecessary rebuild at refresh\\n  this._noNeedToRebuildCache = true;\\n  \\n}; \\n\\n/**\\n * Method to append a filter part to the current filter (*or*-style).\\n * \\n * @param {string} A tiddlywiki filter expression.\\n */\\nViewAbstraction.prototype.addNode = function(node) {\\n   \\n  if(this.isExplicitNode(node)) return false;\\n  \\n  var part = this._getAddNodeFilterPart(node);\\n  this.setNodeFilter(this.getNodeFilter(\\\"raw\\\") + \\\" \\\" + part);\\n\\n  this.saveNodePosition(node);\\n  \\n};\\n\\n/**\\n * Removes a node from the the view filter that has been\\n * explicitly added before.\\n * \\n * ATTENTION: Never remove the node data (i.e. style and positions)\\n * from the node-data store. This will be done by a garbage\\n * collector. See Adapter.prototype._removeObsoleteViewData\\n */\\nViewAbstraction.prototype.removeNode = function(node) {\\n    \\n  if(!this.isExplicitNode(node)) return false;\\n  \\n  var part = this._getAddNodeFilterPart(node);\\n  var f = this.getNodeFilter(\\\"raw\\\").replace(part, \\\"\\\");\\n                   \\n  this.setNodeFilter(f);\\n  return true;\\n  \\n};\\n\\n/**\\n * Method will return a tiddlywiki edge-type filter that is used to\\n * decide which edge types are displayed by the graph.\\n * \\n * @param {(\\\"raw\\\"|\\\"pretty\\\"|\\\"matches\\\"|\\\"whitelist\\\")} [type]\\n *     Use this param to control the output type.\\n * @param {boolean} [isRebuild] - True if to rebuild the cache,\\n *     false otherwise.\\n * @result {*}\\n *     Depends on the type param:\\n *     - raw: the original filter string\\n *     - pretty: the prettyfied filter string for usage in textareas\\n *     - matches: {Array<string>} all matches\\n *     - whitelist: A lookup table where all matches are true\\n */\\nViewAbstraction.prototype.getEdgeTypeFilter = function(type, isRebuild) {\\n  \\n  if(!isRebuild && this.edgeTypeFilter) {\\n    \\n    var f = this.edgeTypeFilter;\\n    \\n  } else {\\n    \\n    var f = utils.makeHashMap();\\n    var allETy = $tm.indeces.allETy;\\n    var src = Object.keys(allETy);    \\n    var tObj = $tw.wiki.getTiddler(this.comp.edgeTypeFilter);\\n    \\n    f.raw = (tObj && tObj.fields.filter || \\\"\\\");\\n    f.pretty = utils.getPrettyFilter(f.raw);\\n    f.matches = utils.getEdgeTypeMatches(f.raw, allETy);\\n    f.whitelist = utils.getLookupTable(f.matches);\\n    \\n  }\\n    \\n  return (type ? f[type] : f);\\n  \\n};\\n\\nViewAbstraction.prototype.isEdgeTypeVisible = function(type) {\\n  \\n  var options = {\\n    namespace: this.getConfig(\\\"edge_type_namespace\\\")\\n  };\\n  \\n  var type = new EdgeType(type, null, options);\\n            \\n  return utils.isEdgeTypeMatch(type.id, this.edgeTypeFilter.raw);\\n  \\n};\\n\\n/**\\n * Method will return a tiddlywiki node filter that is used to\\n * decide which nodes are displayed by the graph.\\n * \\n * @param {(\\\"raw\\\"|\\\"pretty\\\"|\\\"compiled\\\")} [type]\\n *     Use this param to control the output type.\\n * @param {boolean} [isRebuild] - True if to rebuild the cache,\\n *     false otherwise.\\n * @result {*}\\n *     Depends on the type param:\\n *     - raw: the original filter string\\n *     - pretty: the prettyfied filter string for usage in textareas\\n *     - compiled: {Array<string>} all matches\\n */\\nViewAbstraction.prototype.getNodeFilter = function(type, isRebuild) {\\n\\n  if(!isRebuild && this.nodeFilter) {\\n    \\n    var f = this.nodeFilter;\\n    \\n  } else {\\n    \\n    var f = utils.makeHashMap();\\n    var tObj = $tw.wiki.getTiddler(this.comp.nodeFilter);\\n    \\n    f.raw = (tObj && tObj.fields.filter) || \\\"\\\";\\n    f.pretty = utils.getPrettyFilter(f.raw);\\n    f.compiled = $tw.wiki.compileFilter(f.raw);\\n    \\n  }\\n\\n  return (type ? f[type] : f);\\n\\n};\\n\\n/**\\n * This method will return the node data stored in the view.\\n * \\n * @todo When to delete obsolete data?\\n * \\n * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\\n * @result {Hashmap<Id, Object>} A Hashmap with node data.\\n *     Note: If the view doesn't exist, the hashmap will be empty.\\n */\\nViewAbstraction.prototype.getNodeData = function(id, isRebuild) {\\n  \\n  var data = (!isRebuild && this.nodeData\\n              ? this.nodeData\\n              : utils.parseFieldData(this.comp.map, \\\"text\\\", {}));\\n              \\n  return (id ? data[id] : data);\\n  \\n};\\n\\nViewAbstraction.prototype.equals = function(view) {\\n  \\n  if(view === this) return true;\\n  \\n  var view = new ViewAbstraction(view);\\n  return (view.exists() && this.getRoot() === view.getRoot());\\n  \\n};\\n\\n/**\\n * This function will merge the given data in the view's node store.\\n * \\n * If two arguments are provided, the first parameter is assumed\\n * to be a node id and the second to be the data object. The data\\n * will extend the existing data. If data is not an object, it is\\n * assumed to be a delete directive and consequently the node data\\n * in the store will be deleted.\\n * \\n * Otherwise, if a single object parameter is provided, it is regarded\\n * as a node collection and the whole object is used to extend the store.\\n * \\n * @TODO I need to delete data of nodes that are not in view anymore\\n */\\nViewAbstraction.prototype.saveNodeData = function() {\\n\\n  var args = arguments;\\n  var data = this.getNodeData();\\n  \\n  if(args.length === 2) {\\n    \\n    if(typeof args[1] === \\\"object\\\") {\\n      if(args[1] === null) {\\n        // remember – in js null is an object :D\\n        // we use null as a signal for deletion of the item\\n        data[args[0]] = undefined;\\n      } else {\\n        data[args[0]] = $tw.utils.extend(data[args[0]] || {}, args[1]);\\n      }\\n    }\\n    \\n  } else if(args.length === 1 && typeof args[0] === \\\"object\\\") {\\n    \\n    $tm.logger(\\\"log\\\", \\\"Storing data in\\\", this.comp.map);\\n    \\n    $tw.utils.extend(data, args[0]);\\n        \\n  } else {\\n    return;\\n  }\\n  \\n  utils.writeFieldData(this.comp.map, \\\"text\\\", data, $tm.config.sys.jsonIndentation);\\n  \\n  // cache new values and prevent rebuild at refresh\\n  this.nodeData = data;\\n  \\n  this._noNeedToRebuildCache = true;\\n \\n};\\n\\nViewAbstraction.prototype.saveNodePosition = function(node) {\\n    \\n  if(node.id && node.x && node.y) {\\n    this.saveNodeData(node.id, { x: node.x, y: node.y });\\n  }\\n  \\n};\\n\\nViewAbstraction.prototype.setCentralTopic = function(id) {\\n    \\n  this.setConfig(\\\"central-topic\\\", id);\\n  \\n};\\n\\nViewAbstraction.prototype.saveNodeStyle = function(id, style) {\\n  \\n  // remove any previos style from store;\\n  // @TODO: optimize this only null in style var needs to be removed\\n  var data = this.getNodeData()[id];\\n  if(data) {\\n    // delete all previous properties, except positions\\n    for(var p in data) {\\n      if(p !== \\\"x\\\" && p !== \\\"y\\\") data[p] = undefined;\\n    }\\n  }\\n  \\n  // save new style\\n  this.saveNodeData(id, style);\\n \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/config/vis\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/config/vis\\ntype: application/javascript\\nmodule-type: library\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nmodule.exports = {\\n  \\n  locale: \\\"en_EN\\\",\\n  clickToUse: false,\\n  autoResize: false,\\n  height: \\\"100%\\\",\\n  width: \\\"100%\\\",\\n  configure: {\\n    enabled: false\\n  },\\n  interaction: {\\n    dragNodes:true,\\n    dragView: true,\\n    hideEdgesOnDrag: false,\\n    hideNodesOnDrag: false,\\n    hover: true,\\n    navigationButtons: true,\\n    multiselect: true,\\n    selectable: true,\\n    selectConnectedEdges: true,\\n    tooltipDelay: 600,\\n    zoomView: false,\\n    keyboard: {\\n      enabled: false,\\n      speed: {\\n        x: 10,\\n        y: 10,\\n        zoom: 0.02\\n      },\\n      bindToWindow: false\\n    }\\n  },\\n  manipulation: {\\n    initiallyActive: true\\n  },\\n  nodes: {\\n    shape: \\\"box\\\",\\n    shadow: {\\n      enabled: false\\n    },\\n    color: {\\n      border: \\\"#2B7CE9\\\",\\n      background: \\\"#97C2FC\\\"\\n    }\\n  },\\n  edges: {\\n    smooth: {\\n      enabled: true\\n    },\\n    color: {\\n      color: \\\"#848484\\\",\\n      inherit: false\\n    },\\n    arrows: {\\n      to: {\\n        enabled: true\\n      }\\n    }\\n  },\\n  physics: {\\n    forceAtlas2Based: {\\n      // <- more repulsion between nodes - 0 - more attraction between nodes ->\\n      gravitationalConstant: -300, // default: -50\\n      // edge length\\n      springLength: 0, // default: 100\\n      // <- less stiff edges - 0 - stiffer edges ->\\n      springConstant: 0.2, // default: 0.08\\n      // pulls the entire network back to the center.\\n      centralGravity: 0.015, // default: 0.01\\n      // kinetic energy reduction\\n      damping: 0.4\\n    },\\n    solver: \\\"forceAtlas2Based\\\",\\n    stabilization: {\\n      enabled: true,\\n      iterations: 1000,\\n      updateInterval: 10,\\n      onlyDynamicEdges: false,\\n      fit: false\\n    }\\n  }\\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/config/vis\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"library\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/macro/tmap\": {\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/macro/tmap\\ntype: application/javascript\\nmodule-type: macro\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nexports.name = \\\"tmap\\\";\\nexports.params = getParamSlots(5);\\nexports.run = run;\\n\\n/*** Imports *******************************************************/\\n\\nvar EdgeType        = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar utils           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar ViewAbstraction = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\\");\\n  \\n/*** Code **********************************************************/\\n\\n/**\\n * @this MacroCallWidget\\n * @return {string} the result of the operation or an empty string.\\n * @private\\n */\\nfunction run() {\\n  \\n  this.substVarRefs = this.substituteVariableReferences;\\n  \\n  var fn = command[arguments[0]];\\n  var result = null;\\n  \\n  if(typeof fn === \\\"function\\\") {\\n    var args = Array.prototype.slice.call(arguments,1);\\n    var result = fn.apply(this, args);\\n  }\\n  \\n  return (typeof result === \\\"string\\\" ? result : \\\"\\\");\\n  \\n};\\n\\n/** \\n * unfortunately tw forces us to specify params in advance so I\\n * will reserve some argument slots here.\\n * @private\\n */\\nfunction getParamSlots(maxArgs) {\\n  \\n  var arr = [];\\n  \\n  for(var i = 0; i < maxArgs; i++) {\\n    arr.push({ name : (\\\"arg\\\" + i) });\\n  };\\n  \\n  return arr;\\n  \\n};\\n\\n/**\\n * In connection with tiddlymap, this macro allows us to access\\n * system information from within tiddlers as well as to execute\\n * some util functions.\\n * \\n * Every command will be called with `this` pointing to the current\\n * MacroCallWidget instance!\\n * \\n * @private\\n */ \\nvar command = utils.makeHashMap();\\n\\n/**\\n * Returns the basename of the string\\n * \\n * @see {@link utils.basename}\\n */\\ncommand.basename = function(path) {\\n  \\n  var str = path || this.getVariable(\\\"currentTiddler\\\");\\n  return utils.getBasename(str);\\n                           \\n};\\n\\n/**\\n * TW messes with svg urls so we always use base64 encoding when\\n * a data uri is requested as macro call\\n */\\ncommand.datauri = function(tiddler, type) {\\n  \\n  return utils.getDataUri(tiddler, type, true);\\n  \\n};\\n\\n\\ncommand.testJSON = function(fieldName) {\\n  \\n  var tObj = $tw.wiki.getTiddler(this.getVariable(\\\"currentTiddler\\\"));\\n  \\n  try {\\n    JSON.parse(tObj.fields[fieldName]);\\n    return \\\"valid\\\";\\n  } catch(SyntaxError) {\\n    return \\\"malformed\\\";\\n  }\\n                           \\n};\\n\\ncommand.splitAndSelect = function(separator, index) {\\n  \\n  var str = this.getVariable(\\\"currentTiddler\\\");\\n  var result = str.split(separator)[index];\\n  \\n  return (result != null ? result : str);\\n                           \\n};\\n\\ncommand.concat = function() {\\n  \\n  var str = \\\"\\\";\\n  for(var i = 1, l = arguments.length; i < l; i++) {\\n    str += arguments[i];\\n  }\\n  return str;\\n                       \\n};\\n\\ncommand.uuid = function() {\\n  \\n  return utils.genUUID();\\n                       \\n};\\n\\ncommand.regRepl = function() {\\n  \\n  var oldStr = this.substVarRefs(arguments[0]);\\n  var regStr = arguments[1];\\n  var newStr = this.substVarRefs(arguments[2]);\\n  var regFlags = this.substVarRefs(arguments[4]);\\n  \\n  return oldStr.replace(new RegExp(regStr, regFlags), newStr);\\n                       \\n};\\n\\ncommand.halfOfString = function() {\\n\\n  var str = this.substVarRefs(arguments[0]);\\n  if(!str) return \\\"\\\";\\n  \\n  return str.substr(0, Math.ceil(str.length / 2));\\n                       \\n};\\n\\ncommand.isETyVisible = function(viewNS, eTyFilter, id) {\\n  \\n  id = command.getETyId.call(this, viewNS, id);\\n  return \\\"\\\" + utils.isEdgeTypeMatch(id, eTyFilter);\\n\\n};\\n\\ncommand.getETyId = function(viewNS, id) {\\n  \\n  id = id || this.getVariable(\\\"currentTiddler\\\");\\n  return (new EdgeType(id, null, { namespace: viewNS })).id;\\n\\n};\\n\\ncommand.scale = function() {\\n  \\n  var str = \\\"\\\";\\n  for(var i = 1, l = parseInt(arguments[0]); i < l; i++) {\\n    str += \\\"[[\\\" + i + \\\"]]\\\";\\n  }\\n  return str;\\n                       \\n};\\n\\ncommand.mergeFields = function() {\\n  \\n  var tObj = utils.getTiddler(arguments[0]);\\n  var prefix = arguments[1];\\n  var separator = arguments[2] || \\\" \\\";\\n\\n  if(!tObj) return;\\n\\n  var fields = utils.getPropertiesByPrefix(tObj.fields, prefix);\\n  var str = \\\"\\\";\\n  for(var name in fields) {\\n    if(typeof fields[name] === \\\"string\\\") {\\n      str += fields[name] + separator;\\n    }\\n  }\\n  return str;\\n                       \\n};\\n\\ncommand.option = function(path, unit) {\\n  \\n  var prop = $tm;\\n  var propertyPath = path.split(\\\".\\\");\\n\\n  for(var i = 0; i < propertyPath.length; i++) {\\n    if(typeof prop == \\\"object\\\" && prop[propertyPath[i]]) {\\n      prop = prop[propertyPath[i]];\\n    }        \\n  }\\n  \\n  // TODO: ugly, use regex\\n  if(unit && typeof prop === \\\"string\\\"\\n     && utils.hasSubString(unit)\\n     && (prop.lastIndexOf(unit) + unit.length) === prop.length) {\\n    prop = prop + unit;\\n  }\\n    \\n  return prop;\\n                       \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/macro/tmap\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"macro\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/startup/caretaker\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/startup/caretaker\\ntype: application/javascript\\nmodule-type: startup\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\n// Export name and synchronous status\\nexports.name = \\\"tmap.caretaker\\\";\\nexports.platforms = [ \\\"browser\\\" ];\\nexports.after = [ \\\"startup\\\", \\\"tmap.environment\\\" ];\\nexports.before = [ \\\"rootwidget\\\" ];\\nexports.synchronous = true;\\nexports.startup = startup;\\n\\n/*** Imports *******************************************************/\\n\\nvar visConfig       = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/config/vis\\\");\\nvar utils           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar fixer           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/fixer\\\");\\nvar Adapter         = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/Adapter\\\");\\nvar DialogManager   = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/DialogManager\\\");\\nvar CallbackManager = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/CallbackManager\\\");\\nvar ViewAbstraction = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\\");\\nvar EdgeType        = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar NodeType        = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/NodeType\\\");\\nvar vis             = require(\\\"$:/plugins/felixhayashi/vis/vis.js\\\");\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * This module is responsible for registering a global namespace\\n * under $tw and loading (and refreshing) the configuration.\\n * \\n * Attention: Careful with the order of the function calls in this\\n * functions body!\\n * \\n */\\nfunction startup() {\\n  \\n  // register utils\\n  $tm.utils = utils;\\n  \\n  // make classes publicly available\\n  $tm.keycharm = vis.keycharm;\\n  $tm.NodeType = NodeType;\\n  $tm.EdgeType = EdgeType;\\n  $tm.ViewAbstraction = ViewAbstraction;\\n  \\n  // register url\\n  $tm.url = new $tm.utils.URL(window.location.href);\\n  \\n  // build and integrate global options   \\n  updateGlobals();\\n  \\n  // register meta file (if not done yet)\\n  createMetaFile();\\n\\n  // cleanup previous session\\n  cleanup();\\n  \\n  // create indeces\\n  attachIndeces($tm);\\n  \\n  $tm.updateTree = updateTree;\\n  \\n  // set defaults\\n  setDefaults();\\n        \\n  // attach the adapter object to the tiddlymap namespace\\n  $tm.adapter = new Adapter();\\n        \\n  // Run the fixer to update older wikis\\n  fixer.fix();\\n    \\n  // create global callback and dialog managers \\n  $tm.callbackManager = new CallbackManager();\\n  $tm.dialogManager = new DialogManager($tm.callbackManager);\\n  \\n  // all graphs need to register here. @see routineWalk()\\n  $tm.registry = [];\\n  window.setInterval(routineCheck, 5000);\\n        \\n  // AT THE VERY END: register change listener with the callback manager\\n  registerChangeListener($tm.callbackManager);\\n  \\n  // register DOM listeners\\n  registerMousemoveListener();\\n  registerClickListener();\\n  \\n  // check for fullscreen directives\\n  maybePrepareForFullscreenStart($tm.url);\\n  \\n  // issue notification\\n  $tm.logger(\\\"warn\\\", \\\"TiddlyMap's caretaker successfully started\\\");\\n  \\n};\\n\\n/**\\n * This function will append the global options to the tree. In case\\n * this function is called again, only the option leafs are rebuild\\n * so a process may safely store a reference to a branch of the option\\n * tree as the reference doesn't change.\\n *\\n * ATTENTION: For the path options, no trailing or double slashes!\\n * This is NOT unix where paths are normalized (// is not rewritten to /).\\n * \\n * @see \\n *   - [TW5] Is there a designated place for TW plugins to store stuff in the dom? \\n *     https://groups.google.com/forum/#!topic/tiddlywikidev/MZZ37XiVcvY\\n * @param {object} parent The root where to insert the options into\\n */  \\nvar attachOptions = function(parent) {\\n                    \\n  var p = parent;\\n    \\n  // default configurations mixed with user config\\n  if(!p.config) p.config = utils.makeHashMap();\\n\\n  // Never modify the imported config objects; instead, merge them\\n  // into a new object  \\n\\n  // attention! it is a tw-data-tiddler!\\n  p.config.sys = utils.merge(\\n    p.config.sys,\\n    utils.unflatten($tw.wiki.getTiddlerData(p.ref.sysUserConf))\\n  );\\n  \\n  // CAREFUL: Never merge directly into the default vis config object\\n  p.config.vis = utils.merge(\\n    {}, visConfig, utils.parseFieldData(p.ref.visUserConf)\\n  );\\n\\n  // a shortcut for fields property\\n  if(!p.field) p.field = utils.makeHashMap();\\n  $tw.utils.extend(p.field, p.config.sys.field);\\n        \\n};\\n\\n/**\\n * This function will cache/index some tiddler properties as javascript\\n * objects for faster access.\\n */\\nvar attachIndeces = function(parent) {\\n  \\n  $tm.start(\\\"Attaching Indeces\\\");\\n  \\n  if(!parent.indeces) {\\n    parent.indeces = {};\\n    \\n    var r = $tm.path.pluginRoot;\\n    parent.indeces.tmapTiddlers = $tw.wiki.getPluginInfo(r).tiddlers;\\n  }\\n  \\n  var allTiddlers = $tw.wiki.allTitles();\\n    \\n  updateTiddlerVsIdIndeces(parent.indeces, allTiddlers);\\n  updateNodeTypesIndeces(parent.indeces);\\n  updateEdgeTypesIndeces(parent.indeces);\\n  \\n  $tm.stop(\\\"Attaching Indeces\\\");\\n  \\n};\\n\\n/**\\n * TiddlyMap uses ids to reference tiddlers. This function creates\\n * a table that maps ids to tRefs and vice versa.\\n * \\n * Two indeces are added to the indeces chain:\\n * 1. tById – tiddler references by id\\n * 2. idByT – ids by tiddler references\\n * \\n * @param {Object} [parent] - The global indeces object indeces.\\n *     If not stated, $tm.indeces is used.\\n * @param {Array<TiddlerReference>} [allTiddlers] - The tiddlers to\\n *     use as basis for this index. If not stated, all tiddlers in\\n *     the wiki are used.\\n */\\nvar updateTiddlerVsIdIndeces = function(parent, allTiddlers) {\\n  \\n  parent = parent || $tm.indeces;\\n  allTiddlers = allTiddlers || $tw.wiki.allTitles();\\n  \\n  // usually the fixer is not to be called at this point but\\n  // since the fixer relies on the adapter and the adapter\\n  // relies on indeces but the indeces must not be build before\\n  // the fixer had a chance to move ids, we have to call the fixer\\n  // function at this place :(\\n  // @TODO: remove this fixer code in 2016/2017 when it is highly\\n  // unlikely that people are still using an older version  \\n  fixer.fixId()\\n\\n  var tById = parent.tById = {}; // tiddlerById\\n  var idByT = parent.idByT = {}; // idByTiddler\\n  \\n  $tw.wiki.each(function(tObj, tRef) {\\n  \\n    if(utils.isSystemOrDraft(tObj)) return;\\n    \\n    var id = tObj.fields[\\\"tmap.id\\\"];\\n    if(!id) {\\n      id = utils.genUUID();\\n      utils.setField(tObj, \\\"tmap.id\\\", id);\\n    }\\n    \\n    tById[id] = tRef; // tiddlerById\\n    idByT[tRef] = id; // idByTiddler\\n    \\n  });\\n  \\n};\\n\\n/**\\n * For faster access to node-type styles, we store all node-type\\n * objects as indeces in a table.\\n * \\n * Types without a filter are not indexed since they are either\\n * special types that TiddlyMap manually assignes (e.g. tmap:neighbour,\\n * or tmap:selected).\\n * \\n * Indeces added to the indeces chain:\\n * 1. glNTy – all global node types\\n * \\n * @param {Object} [parent] - The global indeces object indeces.\\n *     If not stated, $tm.indeces is used.\\n * @param {Array<TiddlerReference>} [allTiddlers] - The tiddlers to\\n *     use as basis for this index. If not stated, all tiddlers in\\n *     the wiki are used.\\n */\\nvar updateNodeTypesIndeces = function(parent) {\\n\\n  parent = parent || $tm.indeces;\\n  \\n  var typePath = $tm.path.nodeTypes;\\n  var glNTy = parent.glNTy = [];\\n  var glNTyById = parent.glNTyById = utils.makeHashMap();\\n    \\n  $tw.wiki.eachTiddlerPlusShadows(function(tObj, tRef) {\\n    if(utils.startsWith(tRef, typePath)) {\\n      var type = new NodeType(tRef);\\n      glNTyById[type.id] = type;\\n      glNTy.push(type);\\n    }\\n  });\\n  \\n  glNTy.sort(function(a, b) {\\n    return a.priority - b.priority;\\n  });\\n\\n};\\n\\nvar updateEdgeTypesIndeces = function(parent) {\\n\\n  parent = parent || $tm.indeces;\\n\\n  var typePath = $tm.path.edgeTypes;\\n  var allETy = parent.allETy = utils.makeHashMap();\\n  // magic edge-type field name\\n  var maETyFiNa = parent.maETyFiNa = utils.makeHashMap();\\n  var magicETyNamespaces = utils.getLookupTable($tm.misc.magicETyNamespaces);\\n  \\n  $tw.wiki.eachTiddlerPlusShadows(function(tObj, tRef) {\\n    \\n    if(utils.startsWith(tRef, typePath)) {\\n      \\n      var et = new EdgeType(tRef);\\n      allETy[et.id] = et;\\n      \\n      if(magicETyNamespaces[et.namespace]) {\\n        maETyFiNa[et.name] = et;\\n      }      \\n    }\\n    \\n  });\\n\\n};\\n\\nvar updateAdjacencyList = function(tRefs) {\\n\\n};\\n\\n/**\\n * This function attaches all the top level functions to the\\n * tiddlymap namespace.\\n * \\n * This will add the\\n * 1. global logger method,\\n * 2. the notify method\\n * 3. the stopwatch methods `start` and `stop`.\\n * \\n * @param {Hashmap} parent - The parent object to attach the options to.\\n */\\nvar attachFunctions = function(parent) {\\n  \\n  var fn = parent;\\n  var nirvana = function() { /* /dev/null */ }; \\n\\n  if(utils.isTrue($tm.config.sys.debug, false) && console) {\\n  \\n    /**\\n     * A logging mechanism that uses the first argument as type and\\n     * passes all consequent arguments as console arguments. The\\n     * reason for this functions existence is to be able to switch\\n     * off the logging without redirecting every single console function\\n     * such as log, debug, warn etc. Plus, we have more control over\\n     * the logging.\\n     * \\n     * @see http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9\\n     * @see http://stackoverflow.com/questions/9521921/why-does-console-log-apply-throw-an-illegal-invocation-error\\n     *\\n     * @param {string} type - The type of the message (debug, info, warning…)\\n     *     which is exactly the same as in `console[type]`.\\n     * @param {...*} message - An infinite number of arguments to be printed\\n     *     (just like console).\\n     */\\n    fn.logger = function(/* type, [messages,] messages */) {\\n      if(arguments.length < 2) return;\\n      var args = Array.prototype.slice.call(arguments);\\n      var arg1 = args.shift(args);\\n      var type = (console.hasOwnProperty(arg1) ? arg1 : \\\"debug\\\");\\n      console[type].apply(console, args);\\n    };\\n    \\n    fn.start = function(timerName) {\\n      console.time(\\\"[timer] \\\" + timerName);\\n    };\\n    \\n    fn.stop = function(timerName) {\\n      console.timeEnd(\\\"[timer] \\\" + timerName);\\n    };\\n    \\n  } else {\\n    \\n    fn.logger = fn.start = fn.stop = nirvana;\\n    \\n  }\\n\\n  fn.notify = (utils.isTrue($tm.config.sys.notifications)\\n               ? utils.notify\\n               : nirvana);\\n  \\n};\\n\\n/**\\n * This periodic check is needed to trigger a cleanup if a graph is\\n * removed since a graph itself cannot react to its destruction.\\n * This includes removing listeners that were not attached to the\\n * local container or calling the vis destructor.\\n * \\n * @todo Specify which functions are required for widgets that register\\n * themselves in the registry.\\n */\\nvar routineCheck = function() {\\n  \\n  for(var i = $tm.registry.length; i--;) {\\n    var widget = $tm.registry[i];\\n    \\n    if(!widget.destruct || !widget.isZombieWidget) return; // no duck!\\n    \\n    if(widget.isZombieWidget()) { // removed!\\n      $tm.logger(\\\"warn\\\", \\\"a widget will be removed\\\");\\n      $tm.registry.splice(i, 1);\\n      widget.destruct();\\n    }\\n  }\\n  \\n};\\n\\n/**\\n * A more advanced change system.\\n * \\n * @todo The MapConfigWidget does register itself in the registry to\\n * have its destructor called. Is this ok?\\n */\\nvar dispatchUpdates = function(updates) {\\n  \\n  var registry = $tm.registry;\\n  for(var i = registry.length; i--;) {\\n    var widget = registry[i];\\n    \\n    if(!widget.destruct || !widget.isZombieWidget) return; // no duck!\\n    \\n    if(widget.update && !widget.isZombieWidget()) {\\n      widget.update(updates);\\n    }\\n  }\\n  \\n};\\n\\nvar checkForDublicates = function(tObj) {\\n\\n  var id = tObj.fields[\\\"tmap.id\\\"];\\n  \\n  if(!id) return;\\n  \\n  var opt = $tm;\\n  var dublicates = utils.getTiddlersWithField(\\\"tmap.id\\\", id, { limit: 2 });\\n  delete dublicates[tObj.fields.title];\\n  \\n  var dublicate = Object.keys(dublicates)[0];\\n  \\n  if(dublicate) {\\n    \\n    var vars = {\\n      param: {\\n        changedTiddler: tObj.fields.title,\\n        existingTiddler: dublicate,\\n        id: id\\n      }\\n    }\\n\\n    $tm.dialogManager.open(\\\"dublicateIdInfo\\\", vars);\\n\\n  }\\n  \\n  if(dublicate) {\\n    // remove any defined edges\\n    utils.setField(tObj, \\\"tmap.edges\\\", undefined);\\n    // override id\\n    $tm.adapter.assignId(tObj, true);\\n  }  \\n  \\n};\\n\\n/**\\n * Builds and registers globals and the functions that depend on them.\\n */\\nvar updateGlobals = function(parent) {\\n  \\n  attachOptions($tm);\\n  attachFunctions($tm);\\n  \\n  // attention: logger() cannot be called before functions are rebuild\\n  $tm.logger(\\\"warn\\\", \\\"Rebuilt globals\\\");\\n  \\n};\\n\\nvar lastCurrentTiddler = null;\\nvar updateLiveViewTrigger = function(changedTiddlers) {\\n  \\n  if(changedTiddlers[\\\"$:/HistoryList\\\"]) {\\n    var tRef = utils.getField(\\\"$:/HistoryList\\\", \\\"current-tiddler\\\");\\n  } else if(changedTiddlers[\\\"$:/temp/focussedTiddler\\\"]) {\\n    var tRef = utils.getField(\\\"$:/temp/focussedTiddler\\\", \\\"text\\\");\\n  }\\n  \\n  if(tRef != null && lastCurrentTiddler !== tRef) {\\n    lastCurrentTiddler = tRef;\\n    utils.setField(\\\"$:/temp/tmap/currentTiddler\\\", \\\"text\\\", tRef);\\n  }   \\n      \\n};\\n\\n/**\\n * Only for debugging\\n */\\nvar printChanges = function(changedTiddlers, loopCount) {\\n\\n  if(!utils.isTrue($tm.config.sys.debug, false)) return;\\n\\n  $tm.logger(\\\"warn\\\", \\\"=== Refresh \\\" + loopCount + \\\" ===\\\");\\n\\n  for(var tRef in changedTiddlers) {\\n    var c = changedTiddlers[tRef].deleted ? \\\"[Deleted]\\\" : \\\"[Modified]\\\";\\n    $tm.logger(\\\"warn\\\", c, tRef, $tw.wiki.getTiddler(tRef));\\n  }\\n\\n};\\n\\n/**\\n * Saves the last mousemove event under $tm.mouse\\n */\\nvar registerMousemoveListener = function() {\\n  \\n  $tm.mouse = {};\\n  \\n  var fn = function(evt) { $tm.mouse = evt };\\n  window.addEventListener('mousemove', fn, false);\\n  \\n};\\n\\n/**\\n * @TODO: suggest this to Jeremy for TW popup handling\\n */\\nvar registerClickListener = function() {\\n\\n  var tempPopups = $tm.path.tempPopups;\\n  window.addEventListener(\\\"click\\\", function(evt) {\\n    \\n    var popupStates = utils.getTiddlersByPrefix(tempPopups);\\n    \\n    for(var i = popupStates.length; i--;) {\\n      if(utils.getText(popupStates[i])) break;\\n    }\\n    \\n    if(i === -1) return;\\n                                          \\n    if(!$tw.utils.hasClass(evt.target, \\\"tc-drop-down\\\")\\n       && !utils.getAncestorWithClass(evt.target, \\\"tc-drop-down\\\")) {\\n    // = clicked on an element that isn't a dropdown or inside one\\n      for(var i = popupStates.length; i--;) {\\n        utils.setText(popupStates[i], \\\"\\\");\\n      }\\n    }\\n    \\n  }, false);\\n};\\n\\n/**\\n * Todo: implement this in a better way, also with regard to the\\n * change listener and the \\\"rebuilders\\\".\\n */\\nvar updateTree = function() {\\n\\n  updateGlobals();\\n  updateNodeTypesIndeces();\\n  updateEdgeTypesIndeces();\\n  \\n};\\n\\nvar registerChangeListener = function(callbackManager) {\\n  \\n  var loopCount = 0;\\n  var rebuilders = {};\\n  rebuilders[$tm.path.options] = updateGlobals;\\n  rebuilders[$tm.path.nodeTypes] = updateNodeTypesIndeces;\\n  rebuilders[$tm.path.edgeTypes] = updateEdgeTypesIndeces;\\n\\n  $tw.wiki.addEventListener(\\\"change\\\", function(changedTiddlers) {\\n    \\n    $tm.start(\\\"Caretaker handling changes\\\");\\n    \\n    printChanges(changedTiddlers, loopCount++);\\n    callbackManager.handleChanges(changedTiddlers);\\n    \\n    var updates = { changedTiddlers: changedTiddlers };\\n    \\n    for(var tRef in changedTiddlers) {\\n      \\n      var tObj = utils.getTiddler(tRef);\\n      if(tObj && tObj.isDraft()) continue;\\n\\n      if($tw.wiki.isSystemTiddler(tRef)) {\\n        handleSysTidChanges(tRef, tObj, updates, rebuilders);\\n      } else {\\n        handleTidChanges(tRef, tObj, updates);\\n      }\\n      \\n    }\\n    \\n    dispatchUpdates(updates);\\n    \\n    // NOTE: changes will affect the next refresh cycle\\n    updateLiveViewTrigger(changedTiddlers);\\n    \\n    $tm.stop(\\\"Caretaker handling changes\\\");\\n    \\n  });\\n  \\n};\\n\\nvar handleSysTidChanges = function(tRef, tObj, updates, rebuilders) {\\n  \\n  var p = $tm.path;\\n    \\n  for(var prefix in rebuilders) {\\n    if(utils.startsWith(tRef, prefix) && !updates[prefix]) {\\n      $tm.logger(\\\"warn\\\", \\\"[System change]\\\", prefix);\\n      rebuilders[prefix]();\\n      updates[prefix] = true;\\n      return;\\n    }\\n  }\\n    \\n};\\n\\nvar handleTidChanges = function(tRef, tObj, updates) {\\n  \\n  if(tObj) { // created or modified\\n    \\n    checkForDublicates(tObj);\\n    \\n    // call assignId IN ANY CASE to make sure the index\\n    // stays intact, also after a renaming operation\\n    $tm.adapter.assignId(tObj);\\n            \\n  } else { // deleted or renamed\\n    \\n    var id = $tm.indeces.idByT[tRef];\\n\\n    // Ignore tiddler without id; assuming draft\\n    if(!id) return;\\n    \\n    var tWithId = utils.getTiddlerWithField(\\\"tmap.id\\\", id);\\n    \\n    if(tWithId) { // only renamed\\n    \\n      $tm.logger(\\\"warn\\\", \\\"[Renamed]\\\", tRef, \\\"into\\\", tWithId);\\n    \\n    } else { // removed\\n      \\n      // remove node; any edges pointing in/out; update indeces\\n      // CAREFUL with recursion here!\\n      $tm.adapter.deleteNode(id);\\n      \\n    }\\n    \\n  }\\n};\\n\\nvar cleanup = function() {\\n  \\n  utils.deleteByPrefix(\\\"$:/temp/felixhayashi\\\");\\n  utils.deleteByPrefix(\\\"$:/temp/tiddlymap\\\");\\n  utils.deleteByPrefix(\\\"$:/temp/tmap\\\");\\n                 \\n};\\n\\nvar setDefaults = function() {\\n  \\n  var defaultView = $tm.config.sys.defaultView;\\n  if(!defaultView) return;\\n  \\n  utils.setField($tm.ref.defaultViewHolder, \\\"text\\\", defaultView);\\n                 \\n};\\n\\nvar maybePrepareForFullscreenStart = function(url) {\\n  \\n  if(!url.query[\\\"tmap-enlarged\\\"]) return;\\n  \\n  var ref = $tm.ref; \\n  var tRef = utils.getTiddlersByPrefix(\\\"$:/state/tab/sidebar-\\\")[0];\\n  \\n  utils.setText(tRef, ref.mainEditor);\\n        \\n  var view = new ViewAbstraction(url.query[\\\"tmap-view\\\"]);\\n  if(view.exists()) {\\n    utils.setField(ref.defaultViewHolder, \\\"text\\\", view.getLabel());\\n  }\\n\\n};\\n\\nvar createMetaFile = function() {\\n\\n  if(utils.tiddlerExists($tm.ref.sysMeta)) return;\\n  \\n  $tm.logger(\\\"warn\\\", \\\"Creating meta file\\\");\\n  \\n  var plugin = $tw.wiki.getTiddler($tm.path.pluginRoot);\\n  $tw.wiki.setTiddlerData($tm.ref.sysMeta, {\\n    // the version originally installed\\n    originalVersion: plugin.fields.version,\\n    // the data structure in use corresponds to version x\\n    // if the structure is obsolete, it will be automatically\\n    // fixed by the fixer module.\\n    dataStructureState: \\\"0.6.9\\\",\\n    // whether or not to display a welcome message\\n    showWelcomeMessage: true\\n  });\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/startup/caretaker\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/startup/environment\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/startup/environment\\ntype: application/javascript\\nmodule-type: startup\\n\\n@preserve\\n\\n\\\\*/\\n  \\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\n// Export name and synchronous status\\nexports.name = \\\"tmap.environment\\\";\\nexports.platforms = [ \\\"browser\\\" ];\\nexports.after = [ \\\"startup\\\" ];\\nexports.before = [ \\\"tmap.caretaker\\\" ];\\nexports.synchronous = true;\\nexports.startup = run;\\n\\n/*** Imports *******************************************************/\\n\\n// NEVER\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * This module is responsible for registering a global namespace\\n * under $tw and registering fundamental path variables.\\n * \\n * Everything that doesn't change when the global config object is\\n * updated. This includes prefixes (paths) and tiddler titles.\\n * \\n * ATTENTION: The paths are deliberately written in full so they\\n * are discovered when a search is performed over the TiddlyMap code.\\n */\\n\\nfunction run(parent) {\\n  \\n  window.$tm = {};\\n  \\n  // **ATTENTION: NO TRAILING SLASHES IN PATHS EVER**\\n  $tm.path = {\\n    pluginRoot:      \\\"$:/plugins/felixhayashi/tiddlymap\\\",\\n    edgeTypes:       \\\"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes\\\",\\n    nodeTypes:       \\\"$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes\\\",\\n    views:           \\\"$:/plugins/felixhayashi/tiddlymap/graph/views\\\",\\n    options:         \\\"$:/plugins/felixhayashi/tiddlymap/config\\\",\\n    dialogs:         \\\"$:/plugins/felixhayashi/tiddlymap/dialog\\\",\\n    footers:         \\\"$:/plugins/felixhayashi/tiddlymap/dialogFooter\\\",\\n    tempRoot:        \\\"$:/temp/tmap\\\",\\n    tempStates:      \\\"$:/temp/tmap/state\\\",\\n    tempPopups:      \\\"$:/temp/tmap/state/popup\\\",\\n    localHolders:    \\\"$:/temp/tmap/holders\\\"\\n  };\\n  \\n  // static references to important tiddlers\\n  $tm.ref = {\\n    defaultViewHolder:  \\\"$:/plugins/felixhayashi/tiddlymap/misc/defaultViewHolder\\\",\\n    graphBar:           \\\"$:/plugins/felixhayashi/tiddlymap/misc/advancedEditorBar\\\",\\n    sysUserConf:        \\\"$:/plugins/felixhayashi/tiddlymap/config/sys/user\\\",\\n    visUserConf:        \\\"$:/plugins/felixhayashi/tiddlymap/config/vis/user\\\",\\n    welcomeFlag:        \\\"$:/plugins/felixhayashi/tiddlymap/flag/welcome\\\",\\n    focusButton:        \\\"$:/plugins/felixhayashi/tiddlymap/misc/focusButton\\\",\\n    sysMeta:            \\\"$:/plugins/felixhayashi/tiddlymap/misc/meta\\\",\\n    liveTab:            \\\"$:/plugins/felixhayashi/tiddlymap/hook/liveTab\\\",\\n    mainEditor:         \\\"$:/plugins/felixhayashi/tiddlymap/hook/editor\\\",\\n    sidebarBreakpoint:  \\\"$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint\\\"\\n  };\\n  \\n  // some other options\\n  $tm.misc = {\\n    // if no edge label is specified, this is used as label\\n    unknownEdgeLabel: \\\"tmap:undefined\\\",\\n    liveViewLabel: \\\"Live View\\\",\\n    defaultViewLabel: \\\"Default\\\",\\n    mainEditorId: \\\"main_editor\\\",\\n    arrows: { \\\"in\\\": \\\"⇦\\\", \\\"out\\\": \\\"➡\\\", \\\"bi\\\": \\\"⇄\\\" },\\n    magicETyNamespaces: [\\n      \\\"tw-list\\\",\\n      \\\"tw-field\\\",\\n      \\\"tw-filter\\\"\\n    ]\\n  };\\n\\n  $tm.config = {\\n    sys: {\\n      field: {\\n        nodeLabel: \\\"caption\\\",\\n        nodeIcon: \\\"icon\\\",\\n        nodeInfo: \\\"description\\\",\\n        viewMarker: \\\"isview\\\"\\n      },\\n      liveTab: {\\n        fallbackView: $tm.misc.liveViewLabel\\n      },\\n      suppressedDialogs: {},\\n      edgeClickBehaviour: \\\"manager\\\",\\n      debug: \\\"false\\\",\\n      notifications: \\\"true\\\",\\n      popups: {\\n        enabled: \\\"true\\\",\\n        delay: \\\"600\\\",\\n        width: \\\"240px\\\",\\n        height: \\\"140px\\\"\\n      },\\n      jsonIndentation: \\\"1\\\",\\n      editNodeOnCreate: \\\"false\\\",\\n      singleClickMode: \\\"false\\\",\\n      editorMenuBar: {\\n        showNeighScopeButton: \\\"true\\\",\\n        showScreenshotButton: \\\"true\\\"\\n      }\\n    }\\n  };\\n  \\n  // some popular filters\\n  $tm.filter = {\\n    nodeTypes: \\\"[prefix[\\\" + $tm.path.nodeTypes + \\\"]]\\\",\\n    edgeTypes: \\\"[prefix[\\\" + $tm.path.edgeTypes + \\\"]]\\\",\\n    views: \\\"[\\\" + $tm.config.sys.field.viewMarker + \\\"[true]]\\\"\\n  };\\n    \\n  $tm.filter.defaultEdgeTypeFilter = \\\" -[prefix[_]]\\\" +\\n                                   \\\" -[[tw-body:link]]\\\" +\\n                                   \\\" -[[tw-list:tags]]\\\" +\\n                                   \\\" -[[tw-list:list]]\\\";\\n  \\n  // some popular selectors\\n  // usually used from within tiddlers via the tmap macro\\n  var s = $tm.selector = {};\\n  var allSelector = \\\"[all[tiddlers+shadows]!has[draft.of]]\\\";\\n\\n  // all edge-types (by label)\\n  s.allEdgeTypes = allSelector + \\\" +\\\" + $tm.filter.edgeTypes;\\n  s.allEdgeTypesById = s.allEdgeTypes\\n                          + \\\" +[removeprefix[\\\" + $tm.path.edgeTypes + \\\"/]]\\\";\\n\\n  // all node-types (by label)\\n  s.allNodeTypes = allSelector + \\\" +\\\" + $tm.filter.nodeTypes;\\n  s.allNodeTypesById = s.allNodeTypes\\n                          + \\\" +[removeprefix[\\\" + $tm.path.nodeTypes + \\\"/]]\\\";\\n\\n  // all views (by label)\\n  s.allViews = allSelector + \\\" +\\\" + $tm.filter.views;\\n  s.allViewsByLabel = s.allViews + \\\"+[removeprefix[\\\" + $tm.path.views + \\\"/]]\\\";\\n\\n  // all non-draft non-system tiddlers\\n  s.allPotentialNodes = \\\"[all[tiddlers]!is[system]!has[draft.of]]\\\";\\n\\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/startup/environment\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/startup/listener\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/startup/listener\\ntype: application/javascript\\nmodule-type: startup\\n\\n@preserve\\n\\n\\\\*/\\n  \\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nexports.name = \\\"tmap.listener\\\";\\nexports.platforms = [ \\\"browser\\\" ];\\nexports.after = [ \\\"rootwidget\\\", \\\"tmap.caretaker\\\" ];\\nexports.before = [ \\\"story\\\" ];\\nexports.synchronous = true;\\nexports.startup = function() {\\n  // will register its lister functions to the root widget\\n  new GlobalListener();\\n};\\n\\n/*** Imports *******************************************************/\\n\\nvar NodeType   = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/NodeType\\\");\\nvar EdgeType   = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar utils      = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar visDefConf = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/config/vis\\\");\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * @class\\n */\\nfunction GlobalListener() {\\n    \\n  // alias\\n  this.wiki = $tw.wiki;\\n    \\n  // add handlers to the root widget to make them available from everywhere\\n  utils.addTWlisteners({ \\n    \\\"tmap:tm-remove-edge\\\": this.handleRemoveEdge,\\n    \\\"tmap:tm-load-type-form\\\": this.handleLoadTypeForm,\\n    \\\"tmap:tm-save-type-form\\\": this.handleSaveTypeForm,\\n    \\\"tmap:tm-create-type\\\": this.handleCreateType,\\n    \\\"tmap:tm-create-edge\\\": this.handleCreateEdge,\\n    \\\"tmap:tm-suppress-dialog\\\": this.handleSuppressDialog,\\n    \\\"tmap:tm-generate-widget\\\": this.handleGenerateWidget,\\n    \\\"tmap:tm-download-graph\\\": this.handleDownloadGraph,\\n    \\\"tmap:tm-configure-system\\\": this.handleConfigureSystem,\\n    \\\"tmap:tm-manage-edge-types\\\": this.handleOpenTypeManager,\\n    \\\"tmap:tm-manage-node-types\\\": this.handleOpenTypeManager,\\n    \\\"tmap:tm-cancel-dialog\\\": this.handleCancelDialog,\\n    \\\"tmap:tm-clear-tiddler\\\": this.handleClearTiddler,\\n    \\\"tmap:tm-merge-tiddlers\\\": this.handleMixTiddlers,\\n    \\\"tmap:tm-confirm-dialog\\\": this.handleConfirmDialog\\n  }, $tw.rootWidget, this);\\n  \\n};\\n\\nGlobalListener.prototype.handleCancelDialog = function(event) {\\n  utils.setField(event.param, \\\"text\\\", \\\"\\\");\\n};\\n\\nGlobalListener.prototype.handleClearTiddler = function(event) {\\n  \\n  var params = event.paramObject;\\n  if(!params || !params.title) return;\\n  \\n  var tObj = utils.getTiddler(params.title);\\n  var originalFields = tObj ? tObj.fields : {};\\n  var fieldsToKeep = params.keep ? params.keep.split() : [];\\n  var cloneFields = {\\n    title: params.title,\\n    text: \\\"\\\" // see https://github.com/Jermolene/TiddlyWiki5/issues/2025\\n  };\\n  \\n  for(var i = fieldsToKeep.length; i--;) {\\n    var fieldName = fieldsToKeep[i];\\n    cloneFields[fieldName] = originalFields[fieldName];\\n  }\\n  \\n  $tw.wiki.deleteTiddler(params.title);\\n  $tw.wiki.addTiddler(new $tw.Tiddler(cloneFields));\\n  \\n};\\n\\nGlobalListener.prototype.handleMixTiddlers = function(event) {\\n  \\n  var params = event.paramObject;\\n  if(!params || !params.tiddlers) return;\\n  \\n  var tiddlers = $tw.utils.parseStringArray(params.tiddlers);\\n  var tObj = utils.getMergedTiddlers(tiddlers, params.output);\\n                                     \\n  $tw.wiki.addTiddler(tObj);\\n  \\n};\\n\\nGlobalListener.prototype.handleConfirmDialog = function(event) {\\n  \\n  utils.setField(event.param, \\\"text\\\", \\\"1\\\");\\n  \\n};\\n  \\nGlobalListener.prototype.handleSuppressDialog = function(event) {\\n\\n  if(utils.isTrue(event.paramObject.suppress, false)) {\\n    utils.setEntry(\\n        $tm.ref.sysUserConf,\\n        \\\"suppressedDialogs.\\\" + event.paramObject.dialog,\\n        true\\n    );\\n  }\\n  \\n};\\n\\nGlobalListener.prototype.handleDownloadGraph = function(event) {\\n\\n  var graph = $tm.adapter.getGraph({ view: event.paramObject.view });  \\n  \\n  graph.nodes = utils.convert(graph.nodes, \\\"array\\\");\\n  graph.edges = utils.convert(graph.edges, \\\"array\\\");\\n  \\n  var tRef = \\\"$:/temp/tmap/export\\\";\\n\\n  utils.setField(tRef, \\\"text\\\", JSON.stringify(graph, null, 2));\\n    \\n  $tw.rootWidget.dispatchEvent({\\n    type: \\\"tm-download-file\\\",\\n    param: tRef,\\n    paramObject: {\\n      filename: event.paramObject.view + \\\".json\\\"\\n    }\\n  });\\n  \\n};\\n\\nGlobalListener.prototype.handleConfigureSystem = function() {\\n\\n  var allTiddlers = $tm.adapter.getAllPotentialNodes();\\n  var allEdges = $tm.adapter.getEdgesForSet(allTiddlers);\\n  var plugin = $tw.wiki.getTiddler($tm.path.pluginRoot).fields;\\n  var meta = $tw.wiki.getTiddlerData($tm.ref.sysMeta);\\n  var hasLiveTab = utils.getTiddler($tm.ref.liveTab)\\n                        .hasTag(\\\"$:/tags/SideBar\\\");\\n                        \\n  var args = {\\n    numberOfNodes: \\\"\\\" + allTiddlers.length,\\n    numberOfEdges: \\\"\\\" + Object.keys(allEdges).length,\\n    pluginVersion: \\\"v\\\" + plugin.version,\\n    dataStructureVersion: \\\"v\\\" + meta.dataStructureState,\\n    dialog: {\\n      preselects: {\\n        \\\"liveTab\\\": \\\"\\\" + hasLiveTab,\\n        \\\"vis-inherited\\\": JSON.stringify(visDefConf),\\n        \\\"config.vis\\\": utils.getText($tm.ref.visUserConf),\\n        \\\"config.sys\\\": $tm.config.sys\\n      }\\n    }\\n  };\\n\\n  var name = \\\"globalConfig\\\";\\n  $tm.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n    \\n    if(!isConfirmed) return;\\n      \\n    var config = utils.getPropertiesByPrefix(outTObj.fields,\\n                                             \\\"config.sys.\\\",\\n                                             true);\\n                                             \\n    // CAREFUL: this is a data tiddler!\\n    $tw.wiki.setTiddlerData($tm.ref.sysUserConf, config);\\n\\n    // show or hide the live tab; to hide the live tab, we override\\n    // the shadow tiddler; to show it, we remove the overlay again.\\n    if(utils.isTrue(outTObj.fields.liveTab, false)) {\\n      utils.setField($tm.ref.liveTab, \\\"tags\\\", \\\"$:/tags/SideBar\\\");\\n    } else {\\n      $tw.wiki.deleteTiddler($tm.ref.liveTab);\\n    }\\n    \\n    // tw doesn't translate the json to an object so this is\\n    // already a string\\n    utils.setField($tm.ref.visUserConf,\\n                   \\\"text\\\",\\n                   outTObj.fields[\\\"config.vis\\\"]);\\n            \\n\\n\\n  }.bind(this));\\n  \\n};\\n\\nGlobalListener.prototype.handleGenerateWidget = function(event) {\\n  \\n  if(!event.paramObject) event.paramObject = {};\\n  \\n  var options = {\\n    dialog: {\\n      preselects: {\\n        view: (event.paramObject.view || $tm.misc.defaultViewLabel)\\n      }\\n    }\\n  };\\n  $tm.dialogManager.open(\\\"widgetCodeGenerator\\\", options);\\n  \\n};\\n\\nGlobalListener.prototype.handleRemoveEdge = function(event) {\\n  \\n  $tm.adapter.deleteEdge(event.paramObject);\\n  \\n};\\n\\nGlobalListener.prototype.handleCreateEdge = function(event) {\\n\\n  var from = event.paramObject.from;\\n  var to = event.paramObject.to;\\n  var isForce = event.paramObject.force;\\n  \\n  if(!from || !to) return;\\n  \\n  if((utils.tiddlerExists(from) && utils.tiddlerExists(to)) || isForce) {\\n\\n    // will not override any existing tiddlers…\\n    utils.addTiddler(to);\\n    utils.addTiddler(from);\\n\\n    var edge = {\\n      from: $tm.adapter.makeNode(from).id,\\n      to: $tm.adapter.makeNode(to).id,\\n      type: event.paramObject.label,\\n      id: event.paramObject.id\\n    }\\n    \\n    $tm.adapter.insertEdge(edge);\\n    $tm.notify(\\\"Edge inserted\\\");\\n    \\n  }\\n   \\n};\\n\\nGlobalListener.prototype.handleOpenTypeManager = function(event) {\\n    \\n  if(!event.paramObject) event.paramObject = {};\\n  \\n  // either \\\"manage-edge-types\\\" or \\\"manage-node-types\\\"\\n  var mode = event.type.match(/tmap:tm-(.*)/)[1];\\n  \\n  if(mode === \\\"manage-edge-types\\\") {\\n    var topic = \\\"Edge-Type Manager\\\";\\n    var allTypesSelector = $tm.selector.allEdgeTypes;\\n    var typeRootPath = $tm.path.edgeTypes;\\n  } else {\\n    var topic = \\\"Node-Type Manager\\\";\\n    var allTypesSelector = $tm.selector.allNodeTypes;\\n    var typeRootPath = $tm.path.nodeTypes;\\n  }\\n                          \\n  var args = {\\n    mode: mode,\\n    topic: topic,\\n    searchSelector: allTypesSelector,\\n    typeRootPath: typeRootPath\\n  };\\n  \\n  var dialogTObj = $tm.dialogManager.open(\\\"MapElementTypeManager\\\", args);\\n  \\n  if(event.paramObject.type) {\\n    this.handleLoadTypeForm({\\n      paramObject: {\\n        mode: mode,\\n        id: event.paramObject.type,\\n        output: dialogTObj.fields[\\\"output\\\"]\\n      }\\n    });\\n  }\\n  \\n};\\n\\nGlobalListener.prototype.handleLoadTypeForm = function(event) {\\n  \\n  var outTRef = event.paramObject.output;\\n    \\n  var type = (event.paramObject.mode === \\\"manage-edge-types\\\"\\n              ? new EdgeType(event.paramObject.id)\\n              : new NodeType(event.paramObject.id));\\n  \\n  // inject all the type data as fields into the dialog output\\n  type.save(outTRef);\\n  \\n  // fields that need preprocessing\\n  \\n  if(event.paramObject.mode === \\\"manage-edge-types\\\") {\\n    var usage = $tm.adapter.selectEdgesByType(type);\\n    var count = Object.keys(usage).length;\\n    utils.setField(outTRef, \\\"temp.usageCount\\\", count);\\n  }\\n  \\n  $tw.wiki.addTiddler(new $tw.Tiddler(\\n    utils.getTiddler(outTRef),\\n    {\\n      \\\"typeTRef\\\": type.fullPath,\\n      \\\"temp.idImmutable\\\": (type.isShipped ? \\\"true\\\" : \\\"\\\"),\\n      \\\"temp.newId\\\": type.id,\\n      \\\"vis-inherited\\\": JSON.stringify($tm.config.vis)\\n    }\\n  ));\\n\\n  // reset the tabs to default\\n  utils.deleteByPrefix(\\\"$:/state/tabs/MapElementTypeManager\\\");\\n  \\n};\\n\\nGlobalListener.prototype.handleSaveTypeForm = function(event) {\\n  \\n  var tObj = utils.getTiddler(event.paramObject.output);  \\n  if(!tObj) return;\\n  \\n  var mode = event.paramObject.mode;\\n  var type = (mode === \\\"manage-edge-types\\\"\\n              ? new EdgeType(tObj.fields.id)\\n              : new NodeType(tObj.fields.id));\\n  \\n  if(utils.isTrue(tObj.fields[\\\"temp.deleteType\\\"], false)) {\\n    this.deleteType(mode, type, tObj);\\n  } else {\\n    this.saveType(mode, type, tObj);\\n  }\\n  \\n};\\n\\nGlobalListener.prototype.deleteType = function(mode, type, dialogOutput) {\\n  \\n  $tm.logger(\\\"debug\\\", \\\"Deleting type\\\", type);\\n      \\n  if(mode === \\\"manage-edge-types\\\") {\\n    $tm.adapter._processEdgesWithType(type, { action: \\\"delete\\\" });\\n  } else {\\n    $tm.adapter.removeNodeType(type);\\n  }\\n  \\n  this.wiki.addTiddler(new $tw.Tiddler({\\n    title: utils.getTiddlerRef(dialogOutput)\\n  }));\\n  \\n  $tm.notify(\\\"Deleted type\\\");\\n  \\n};\\n\\nGlobalListener.prototype.saveType = function(mode, type, dialogOutput) {\\n  \\n  var tObj = utils.getTiddler(dialogOutput);\\n  \\n  // update the type with the form data\\n  type.loadFromTiddler(tObj);\\n  type.save();\\n    \\n  var newId = tObj.fields[\\\"temp.newId\\\"];\\n  \\n  if(newId && newId !== tObj.fields[\\\"id\\\"]) { //renamed\\n    \\n    if(mode === \\\"manage-edge-types\\\") {\\n      \\n      $tm.adapter._processEdgesWithType(type, {\\n        action: \\\"rename\\\",\\n        newName: newId\\n      });\\n      \\n    } else {\\n      \\n      var newType = new NodeType(newId);\\n      newType.load(type);\\n      newType.save();\\n      $tw.wiki.deleteTiddler(type.fullPath);\\n      \\n    }\\n    \\n    utils.setField(tObj, \\\"id\\\", newId);\\n    \\n  }\\n    \\n  $tm.notify(\\\"Saved type data\\\");\\n  \\n};\\n\\nGlobalListener.prototype.handleCreateType = function(event) {\\n  \\n  var id = event.paramObject.id || \\\"New type\\\";\\n  var type = (event.paramObject.mode === \\\"manage-edge-types\\\"\\n              ? new EdgeType(id)\\n              : new NodeType(id));\\n  type.save();\\n\\n  this.handleLoadTypeForm({\\n    paramObject: {\\n      id: type.id,\\n      mode: event.paramObject.mode,\\n      output: event.paramObject.output\\n    }\\n  });\\n  \\n};\\n\\n/**\\n * Helper\\n */\\nGlobalListener.prototype.getTypeFromEvent = function(event) {\\n    \\n  return (event.paramObject.mode === \\\"manage-edge-types\\\"\\n          ? new EdgeType(event.paramObject.id)\\n          : new NodeType(event.paramObject.id));\\n          \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/startup/listener\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/widget/MapConfigWidget\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/MapConfigWidget\\ntype: application/javascript\\nmodule-type: widget\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nexports[\\\"tmap-config\\\"] = MapConfigWidget;\\n\\n/*** Imports *******************************************************/\\n \\nvar ViewAbstraction = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\\");\\nvar utils           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar vis             = require(\\\"$:/plugins/felixhayashi/vis/vis.js\\\");\\nvar Widget          = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * Wrapper for the Visjs configurator.\\n * \\n * ```\\n * <$tmap-config\\n *     inherited=\\\"FIELDNAME FIELDNAME …\\\"\\n *     extension=\\\"FIELDNAME\\\"\\n *     changes=\\\"FIELDNAME\\\" (default: same field as extension)\\n *     override=\\\"true|false\\\" (default: false)\\n *     mode=\\\"manage-*\\\"\\n *     refresh-trigger=\\\"tRef\\\" />\\n * ```\\n * \\n * @constructor\\n */\\nfunction MapConfigWidget(parseTreeNode, options) {\\n  \\n  // call the parent constructor\\n  Widget.call(this);\\n  \\n  // call initialise on prototype\\n  this.initialise(parseTreeNode, options);\\n      \\n  // make the html attributes available to this widget\\n  this.computeAttributes();\\n       \\n};\\n\\n// !! EXTENSION !!\\nMapConfigWidget.prototype = Object.create(Widget.prototype);\\n// !! EXTENSION !!\\n  \\n/**\\n * Method to render this widget into the DOM.\\n * \\n * @override\\n */\\nMapConfigWidget.prototype.render = function(parent, nextSibling) {\\n    \\n  // remember our place in the dom\\n  this.parentDomNode = parent;\\n  \\n  if(!this.domNode) {\\n    this.domNode = this.document.createElement(\\\"div\\\");\\n    $tw.utils.addClass(this.domNode, \\\"tmap-config-widget\\\");\\n    parent.insertBefore(this.domNode, nextSibling);\\n  }\\n\\n  if(this.network) {\\n        \\n    // destroy any previous instance\\n    this.network.destroy();\\n    \\n  }\\n  \\n  // create container for vis configurator; destroyed when vis is destroyed\\n  this.networkContainer = document.createElement(\\\"div\\\");\\n  this.domNode.appendChild(this.networkContainer);\\n      \\n  // get environment\\n  this.refreshTrigger = this.getAttribute(\\\"refresh-trigger\\\");\\n  this.pipeTRef = this.getVariable(\\\"currentTiddler\\\");\\n  this.inheritedFields = $tw.utils.parseStringArray(this.getAttribute(\\\"inherited\\\"));\\n  this.extensionTField = this.getAttribute(\\\"extension\\\");\\n  this.mode = this.getAttribute(\\\"mode\\\");\\n  \\n  // load inherited options\\n  for(var i = 0; i < this.inheritedFields.length; i++) {\\n    var fieldName = this.inheritedFields[i];\\n    var style = utils.parseFieldData(this.pipeTRef, fieldName, {});\\n    \\n    // maybe the inherited options also come without a top level property\\n    // so we do the same here to…\\n    // TODO looks clumsy; do it in a more generic way…\\n    if(this.mode === \\\"manage-edge-types\\\") {\\n      if(!style.edges) { style = { edges: style }; }\\n    } else if(this.mode === \\\"manage-node-types\\\") {\\n      if(!style.nodes) { style = { nodes: style }; }\\n    }\\n        \\n    this.inherited = utils.merge(this.inherited, style);\\n\\n  }\\n    \\n  // load extension to the inherited options; since we store vis config\\n  // for nodes and edges without the top level property, we may need to\\n  // append it again, if not done so already.\\n  this.extension = utils.parseFieldData(this.pipeTRef, this.extensionTField, {});\\n  // TODO looks clumsy; do it in a more generic way…\\n  if(this.mode === \\\"manage-edge-types\\\") {\\n    if(!this.extension.edges) {\\n      this.extension = { edges: this.extension };\\n    }\\n  } else if(this.mode === \\\"manage-node-types\\\") {\\n    if(!this.extension.nodes) {\\n      this.extension = { nodes: this.extension };\\n    }\\n  }\\n  \\n  // we record all changes in a separate variable\\n  var isSaveOnlyChanges = utils.isTrue(this.getAttribute(\\\"save-only-changes\\\"));\\n  this.changes = (isSaveOnlyChanges ? {} : this.extension);\\n                   \\n  var data = { nodes: [], edges: [] };\\n  var options = utils.merge({}, this.inherited, this.extension);\\n  $tw.utils.extend(options, {\\n    configure: {\\n      enabled: true,\\n      showButton: false,\\n      filter: this.getOptionFilter(this.mode)\\n    }\\n  });\\n  \\n  this.network = new vis.Network(this.networkContainer, data, options);\\n  this.network.on(\\\"configChange\\\", this.handleConfigChange.bind(this));\\n  \\n  // giving the parent a css height will prevent it from jumping\\n  // back when the network is destroyed and the network\\n  // container is removed.\\n  // fixes https://github.com/almende/vis/issues/1568\\n  var height = this.parentDomNode.getBoundingClientRect().height;\\n  this.parentDomNode.style[\\\"height\\\"] = height + \\\"px\\\";\\n  \\n  var reset = this.handleResetEvent.bind(this);\\n  this.networkContainer.addEventListener(\\\"reset\\\", reset, false);\\n  \\n  // register this graph at the caretaker's graph registry\\n  $tm.registry.push(this);\\n  \\n  \\n  this.enhanceConfigurator();\\n\\n};\\n\\n/**\\n * I only receive the option that has actually changed\\n */\\nMapConfigWidget.prototype.handleResetEvent = function(ev) {\\n  var change = {};\\n  change[ev.detail.trigger.path] = null;\\n  this.handleConfigChange(change);\\n};\\n\\n/**\\n * I only receive the option that has actually changed\\n */\\nMapConfigWidget.prototype.handleConfigChange = function(change) {\\n  \\n  var flatChanges = utils.flatten(this.changes);\\n  var flatChange = utils.flatten(change);\\n  var confPath = Object.keys(utils.flatten(change))[0];\\n  var isReset = (flatChange[confPath] === null);\\n    \\n  if(isReset) { // we interpret this as delete\\n    \\n    flatChanges[confPath] = undefined;\\n    this.changes = utils.unflatten(flatChanges);\\n    \\n  } else {\\n    \\n    this.changes = utils.merge(this.changes, change);\\n  }\\n  \\n  // when storing edge- or node-styles we strip the root property\\n  var options = utils.merge({}, this.changes);\\n  if(this.mode === \\\"manage-node-types\\\") { options = options[\\\"nodes\\\"]; }\\n  if(this.mode === \\\"manage-edge-types\\\") { options = options[\\\"edges\\\"]; }\\n  \\n  // save changes\\n  utils.writeFieldData(this.pipeTRef, this.extensionTField, options, $tm.config.sys.jsonIndentation);\\n  \\n  // hack to ensure vis doesn't scroll\\n  var cls = \\\"vis-configuration-wrapper\\\";\\n  var div = this.networkContainer.getElementsByClassName(cls)[0];\\n  div.style.height = div.getBoundingClientRect().height + \\\"px\\\";\\n    \\n  if(isReset) {\\n    \\n    // we need to use a timeout here, otherwise we cause a vis bug\\n    // since it is in the middle of storing the value!\\n    window.setTimeout(this.refresh.bind(this), 0);\\n    \\n  } else {\\n    \\n    // add active-config indicators\\n    window.setTimeout(this.enhanceConfigurator.bind(this), 50);\\n    \\n  }\\n  \\n};\\n\\n/**\\n * enhanceConfigurator over all config items and add an indicator.\\n */\\nMapConfigWidget.prototype.enhanceConfigurator = function() {\\n  \\n  var cls = \\\"vis-configuration-wrapper\\\";\\n  var elements = this.networkContainer\\n                     .getElementsByClassName(cls)[0].children;\\n  var list = [];\\n  var changes = utils.flatten(this.changes);\\n  for(var i = 0; i < elements.length; i++) {\\n    if(!elements[i].classList.contains(\\\"vis-config-item\\\")) continue;\\n    \\n    var conf = new VisConfElement(elements[i], list, i);\\n    list.push(conf);\\n    \\n    if(conf.level === 0) continue;\\n    \\n    conf.setActive(!!changes[conf.path]);\\n\\n  }\\n}\\n\\n/**\\n * \\n * @param {DOMElement} The config item element.\\n * @param {Array<VisConfElement>} a list of VisConfElements of which\\n *     this element is also part of.\\n * @param {number} the position in the list\\n */\\nfunction VisConfElement(el, list, pos) {\\n   \\n  var getByCls = \\\"getElementsByClassName\\\";\\n  var getByTag = \\\"getElementsByTagName\\\";\\n  \\n  this.isActive = false;\\n  this.pos = pos;\\n  this.el = el;\\n  this.inputEl = el[getByCls](\\\"vis-config-colorBlock\\\")[0]\\n                 || el[getByTag](\\\"input\\\")[0];\\n  this.labelEl = el[getByCls](\\\"vis-config-label\\\")[0]\\n                 || el[getByCls](\\\"vis-config-header\\\")[0]\\n                 || el;\\n  var labelText = (this.labelEl.innerText || this.labelEl.textContent);\\n  this.label = labelText && labelText.match(/([a-zA-Z0-9]+)/)[1];\\n  this.level = parseInt(el.className.match(/.*vis-config-s(.).*/)[1]) || 0;\\n  \\n  this.path = this.label;\\n  \\n  if(this.level > 0) {\\n    for(var i = pos; i--;) {\\n      var prev = list[i];\\n      if(prev.level < this.level) {\\n        this.path = prev.path + \\\".\\\" + this.path;\\n        break;\\n      }\\n    }\\n  }\\n}\\n\\nVisConfElement.prototype.setActive = function(isEnable) {\\n  \\n  if(!isEnable) return;\\n  \\n  // cannot use utils.hasKeyWithPrefix because some keys start with\\n  // same value as others\\n  var cls = \\\"tmap-vis-config-item-\\\" + (isEnable ? \\\"active\\\" : \\\"inactive\\\");\\n  $tw.utils.addClass(this.el, cls);\\n  \\n  if(isEnable) {\\n  \\n    var button = document.createElement(\\\"button\\\");\\n    button.innerHTML = \\\"reset\\\";\\n    button.className = \\\"tmap-config-item-reset\\\";\\n    \\n    var self = this;\\n    \\n    button.addEventListener(\\\"click\\\", function(ev) {\\n      ev.currentTarget.dispatchEvent(new CustomEvent(\\\"reset\\\", {\\n        detail: { trigger: self },\\n        bubbles: true,\\n        cancelable: true\\n      }));\\n    }, false);\\n\\n    this.el.appendChild(button);\\n  }\\n  \\n};\\n\\n/**\\n * \\n *\\n */\\nMapConfigWidget.prototype.getOptionFilter = function(mode) {\\n  \\n  var whitelist = {\\n    nodes: {\\n      borderWidth: true, \\n      borderWidthSelected: true,\\n      color: {\\n        background: true,\\n        border: true\\n      },\\n      font: {\\n        color: true,\\n        size: true\\n      },\\n      icon: true,\\n      labelHighlightBold: false,\\n      shadow: true,\\n      shape: true,\\n      shapeProperties: {\\n        borderDashes: true,\\n        \\n      },\\n      size: true\\n    },\\n    edges: {\\n      arrows: true,\\n      color: true,\\n      dashes: true,\\n      font: true,\\n      labelHighlightBold: false,\\n      length: true,\\n      selfReferenceSize: false,\\n      shadow: true,\\n      smooth: true,\\n      width: true\\n    },\\n    interaction: {\\n      hideEdgesOnDrag: true,\\n      hideNodesOnDrag: true,\\n      tooltipDelay: true\\n    },\\n    layout: {\\n      hierarchical: false\\n    },\\n    manipulation: {\\n      initiallyActive: true\\n    },\\n    physics: {\\n      forceAtlas2Based: {\\n        gravitationalConstant: true,\\n        springLength: true,\\n        springConstant: true,\\n        damping: true,  \\n        centralGravity: true\\n      }\\n    }\\n  };  \\n  \\n  if(mode === \\\"manage-edge-types\\\") {\\n    whitelist = { edges: whitelist.edges };\\n  } else if(mode === \\\"manage-node-types\\\") {\\n    whitelist = { nodes: whitelist.nodes };\\n  } else {\\n    whitelist.edges.arrows = false;\\n  }\\n    \\n  return function(option, path) {\\n    \\n    // operate on a clone; add option as element\\n    path = path.concat([ option ]);\\n    \\n    var wlObj = whitelist;\\n    for(var i = 0, l = path.length; i < l; i++) {\\n      if(wlObj[path[i]] === true) {\\n        return true;\\n      } else if(wlObj[path[i]] == null) {\\n        return false;\\n      } // else assume object\\n      wlObj = wlObj[path[i]];\\n    }\\n    \\n    return false;\\n  \\n  };\\n  \\n};\\n\\n/**\\n * A zombie widget is a widget that is removed from the dom tree\\n * but still referenced or still partly executed -- I mean\\n * otherwise you couldn't call this function, right?\\n * \\n * @TODO Outsource this as interface or common super class\\n */\\nMapConfigWidget.prototype.isZombieWidget = function() {\\n  \\n  return !document.body.contains(this.parentDomNode);\\n  \\n};\\n \\n/**\\n * called from outside.\\n * \\n * @TODO Outsource this as interface or common super class\\n */\\nMapConfigWidget.prototype.destruct = function() {\\n    \\n  if(this.network) {\\n    this.network.destroy();\\n  }\\n  \\n};\\n\\n/**\\n * This function is called by the system to notify the widget about\\n * tiddler changes.\\n * \\n * @override\\n */\\nMapConfigWidget.prototype.refresh = function(changedTiddlers) {\\n  \\n  if(this.isZombieWidget() || !this.network) return;\\n  \\n  if(!changedTiddlers || changedTiddlers[this.refreshTrigger]) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n  \\n};\\n\\nMapConfigWidget.prototype.setNull = function(obj) {\\n  \\n  for (var p in obj) {\\n    if(typeof obj[p] == \\\"object\\\") {\\n      this.setNull(obj[p]);\\n    } else {\\n      obj[p] = undefined;\\n    }\\n  }\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/widget/MapConfigWidget\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/widget/connections\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/connections\\ntype: application/javascript\\nmodule-type: widget\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nexports[\\\"tmap-edgelistitem\\\"] = EdgeListItemWidget;\\nexports[\\\"tmap-connections\\\"] = EdgeListWidget;\\n\\n/*** Imports *******************************************************/\\n\\nvar Widget   = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\nvar EdgeType = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar utils    = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\n\\n/*** Code **********************************************************/\\n\\n/**\\n * @constructor\\n */\\nfunction EdgeListWidget(parseTreeNode,options) {\\n  \\n  // call the parent constructor  \\n  Widget.call(this, parseTreeNode, options);\\n      \\n};\\n\\n// !! EXTENSION !!\\nEdgeListWidget.prototype = Object.create(Widget.prototype);\\n// !! EXTENSION !!\\n\\nEdgeListWidget.prototype.render = function(parent,nextSibling) {\\n  \\n  this.parentDomNode = parent;\\n  this.computeAttributes();\\n  this.execute();\\n  this.renderChildren(parent,nextSibling);\\n    \\n};\\n\\nEdgeListWidget.prototype.execute = function() {\\n  \\n  var nodes = [ this.getVariable(\\\"currentTiddler\\\") ]; \\n  var filter = this.getAttribute(\\\"filter\\\", \\\"\\\");\\n  var direction = this.getAttribute(\\\"direction\\\", \\\"both\\\");\\n  var allETy = $tm.indeces.allETy;  \\n  \\n  var matches = utils.getEdgeTypeMatches(filter, allETy);\\n  \\n  var options = {\\n    typeWL: utils.getLookupTable(matches),\\n    direction: direction\\n  };\\n\\n  var neighbourhood = $tm.adapter.getNeighbours(nodes, options);\\n\\n  // retrieve nodes and edges\\n  var neighbours = neighbourhood.nodes;\\n  var edges = neighbourhood.edges;\\n  \\n  var entries = [];\\n  for(var id in edges) {\\n    var edge = edges[id];\\n    var neighbour = neighbours[edge.to] || neighbours[edge.from];\\n    \\n    if(!neighbour) continue; // obsolete edge from old times;\\n    \\n    // make item template\\n    entries.push({\\n      type: \\\"tmap-edgelistitem\\\",\\n      edge: edge,\\n      typeWL: options.typeWL,\\n      neighbour: neighbour,\\n      // the children of this widget (=what is wrapped inside the\\n      // widget-element's body) is used as template for the list items\\n      children: this.parseTreeNode.children\\n    });\\n  }\\n  \\n  if(!entries.length) {\\n    this.wasEmpty = true;\\n    entries = this.getEmptyMessage();\\n  } else if(this.wasEmpty) {\\n    // we need to remove the empty message\\n    this.removeChildDomNodes();\\n  }\\n\\n  this.makeChildWidgets(entries);\\n  \\n};\\n\\nEdgeListWidget.prototype.getEmptyMessage = function() {\\n  \\n  var parser = this.wiki.parseText(\\n                  \\\"text/vnd.tiddlywiki\\\",\\n                  this.getAttribute(\\\"emptyMessage\\\", \\\"\\\"),\\n                  {parseAsInline: true});\\n    \\n  return parser ? parser.tree : [];\\n  \\n};\\n\\nEdgeListWidget.prototype.refresh = function(changedTiddlers) {\\n  \\n  var changedAttributes = this.computeAttributes();\\n  var hasChangedAttributes = Object.keys(changedAttributes).length;\\n  if(hasChangedAttributes) {\\n    this.refreshSelf();\\n    return true;\\n  }\\n\\n  for(var tRef in changedTiddlers) {\\n    if(!utils.isSystemOrDraft(tRef)) {\\n      this.refreshSelf();\\n      return true;\\n    } \\n  }\\n    \\n  // let children decide for themselves\\n  return this.refreshChildren(changedTiddlers);\\n\\n};\\n\\n/**\\n * @constructor\\n */\\nfunction EdgeListItemWidget(parseTreeNode, options) {\\n  \\n  Widget.call(this, parseTreeNode, options);\\n  \\n  this.arrows = $tm.misc.arrows;\\n    \\n};\\n\\n// !! EXTENSION !!\\nEdgeListItemWidget.prototype = Object.create(Widget.prototype);\\n// !! EXTENSION !!\\n\\nEdgeListItemWidget.prototype.execute = function() {\\n  \\n  var item = this.parseTreeNode;\\n  var tRef = $tm.indeces.tById[item.neighbour.id];\\n  \\n  // make edge properties available as variables\\n  var edge = utils.flatten(item.edge);\\n  for(var p in edge) {\\n    if(typeof edge[p] === \\\"string\\\") {\\n      this.setVariable(\\\"edge.\\\" + p, edge[p]);\\n    }\\n  }\\n  \\n  // Perspective: Neighbour\\n  this.setVariable(\\\"currentTiddler\\\", tRef);\\n  this.setVariable(\\\"neighbour\\\", tRef);\\n  \\n  var type = $tm.indeces.allETy[edge.type];\\n  \\n  var indexedAs = (edge.to === item.neighbour.id ? \\\"to\\\" : \\\"from\\\");\\n  var arrow = indexedAs;\\n  \\n  if(type.biArrow) {\\n    arrow = \\\"bi\\\";  \\n  } else {\\n    if(indexedAs === \\\"to\\\" && type.invertedArrow) {\\n      arrow = \\\"from\\\";\\n    } else if(indexedAs === \\\"from\\\" && type.invertedArrow) {\\n      arrow = \\\"to\\\";\\n    }\\n  }\\n\\n  this.setVariable(\\\"direction\\\", arrow);\\n  this.setVariable(\\\"directionSymbol\\\", arrow === \\\"bi\\\"\\n                                      ? this.arrows.bi\\n                                      : arrow === \\\"from\\\"\\n                                        ? this.arrows.in\\n                                        : this.arrows.out);\\n  \\n  // Construct the child widgets\\n  this.makeChildWidgets();\\n  \\n};\\n\\nEdgeListItemWidget.prototype.refresh = function(changedTiddlers) {\\n  \\n  return this.refreshChildren(changedTiddlers);\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/widget/connections\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget\": {\n            \"text\": \"/*\\\\\\n\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget\\ntype: application/javascript\\nmodule-type: widget\\n\\n@preserve\\n\\n\\\\*/\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n/*** Exports *******************************************************/\\n\\nexports.tiddlymap = MapWidget; // legacy\\nexports.tmap = MapWidget;\\n\\n/*** Imports *******************************************************/\\n \\nvar utils           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/utils\\\");\\nvar DialogManager   = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/DialogManager\\\");\\nvar CallbackManager = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/CallbackManager\\\");\\nvar ViewAbstraction = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\\\");\\nvar EdgeType        = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/EdgeType\\\");\\nvar NodeType        = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/NodeType\\\");\\nvar Popup           = require(\\\"$:/plugins/felixhayashi/tiddlymap/js/Popup\\\");\\nvar vis             = require(\\\"$:/plugins/felixhayashi/vis/vis.js\\\");\\nvar Widget          = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n/*** Code **********************************************************/\\n      \\n/**\\n * The map widget is responsible for drawing the actual network\\n * diagrams.\\n * \\n * @constructor\\n */\\nfunction MapWidget(parseTreeNode, options) {\\n  \\n  // call the parent constructor\\n  Widget.call(this, parseTreeNode, options);\\n    \\n  // create shortcuts for services and frequently used vars\\n  this.getAttr = this.getAttribute;\\n  this.isDebug = utils.isTrue($tm.config.sys.debug, false);\\n  \\n  // force early binding of functions to this context\\n  utils.bind(this, [\\n    \\\"constructTooltip\\\",\\n    \\\"handleResizeEvent\\\",\\n    \\\"handleClickEvent\\\",\\n    \\\"handleCanvasKeyup\\\",\\n    \\\"handleCanvasKeydown\\\",\\n    \\\"handleCanvasScroll\\\",\\n    \\\"handleWidgetKeyup\\\",\\n    \\\"handleWidgetKeydown\\\",\\n    \\\"handleTriggeredRefresh\\\",\\n    \\\"handleContextMenu\\\"\\n  ]);\\n            \\n  // instanciate managers\\n  this.callbackManager = new CallbackManager();\\n  this.dialogManager = new DialogManager(this.callbackManager, this);\\n      \\n  // make the html attributes available to this widget\\n  this.computeAttributes();\\n  this.editorMode = this.getAttr(\\\"editor\\\");\\n  this.clickToUse = utils.isTrue(this.getAttr(\\\"click-to-use\\\"), false);\\n  \\n  // who am I? the id is used for debugging and special cases\\n  this.id = this.getAttr(\\\"object-id\\\") || this.getStateQualifier();\\n  \\n  this.widgetTempStatePath = $tm.path.tempStates + \\\"/\\\" + this.id;\\n  this.widgetPopupsPath = $tm.path.tempPopups + \\\"/\\\" + this.id;\\n    \\n  // register listeners that are available in editor mode\\n  if(this.editorMode) {\\n    utils.addTWlisteners({\\n      \\\"tmap:tm-create-view\\\": this.handleCreateView,\\n      \\\"tmap:tm-rename-view\\\": this.handleRenameView,\\n      \\\"tmap:tm-delete-view\\\": this.handleDeleteView,\\n      \\\"tmap:tm-delete-element\\\": this.handleDeleteElement,\\n      \\\"tmap:tm-edit-view\\\": this.handleEditView,\\n      \\\"tmap:tm-store-position\\\": this.handleStorePositions,\\n      \\\"tmap:tm-generate-widget\\\": this.handleGenerateWidget,\\n      \\\"tmap:tm-toggle-central-topic\\\": this.handleSetCentralTopic,\\n      \\\"tmap:tm-save-canvas\\\": this.handleSaveCanvas\\n    }, this, this);\\n  }\\n  \\n  // register listeners that are available in any case\\n  utils.addTWlisteners({\\n    \\\"tmap:tm-focus-node\\\": this.handleFocusNode,\\n    \\\"tmap:tm-reset-focus\\\": this.repaintGraph\\n  }, this, this);\\n  \\n  // Visjs handlers\\n  this.visListeners = {\\n    \\\"click\\\": this.handleVisSingleClickEvent,\\n    \\\"doubleClick\\\": this.handleVisDoubleClickEvent,\\n    \\\"stabilized\\\": this.handleVisStabilizedEvent,\\n    \\\"selectNode\\\": this.handleVisSelectNode,\\n    \\\"deselectNode\\\": this.handleVisDeselectNode,\\n    'dragStart': this.handleVisDragStart,\\n    \\\"dragEnd\\\": this.handleVisDragEnd,\\n    \\\"hoverNode\\\": this.handleVisHoverElement,\\n    \\\"hoverEdge\\\": this.handleVisHoverElement,\\n    \\\"blurNode\\\": this.handleVisBlurElement,\\n    \\\"blurEdge\\\": this.handleVisBlurElement,\\n    \\\"beforeDrawing\\\": this.handleVisBeforeDrawing,\\n    \\\"stabilizationProgress\\\": this.handleVisLoading,\\n    \\\"stabilizationIterationsDone\\\": this.handleVisLoadingDone\\n  };\\n  \\n  this.windowDomListeners = {\\n    \\\"resize\\\": [ this.handleResizeEvent, false ],\\n    \\\"click\\\": [ this.handleClickEvent, false ]\\n  };\\n  \\n  this.canvasDomListeners = {\\n    \\\"keyup\\\": [ this.handleCanvasKeyup, true ],\\n    \\\"keydown\\\": [ this.handleCanvasKeydown, true ],\\n    \\\"mousewheel\\\": [ this.handleCanvasScroll, true ],\\n    \\\"contextmenu\\\": [ this.handleContextMenu, true ]\\n  };\\n    \\n  this.widgetDomListeners = {\\n    \\\"keyup\\\": [ this.handleWidgetKeyup, true ],\\n    \\\"keydown\\\": [ this.handleWidgetKeydown, true ]\\n  };\\n      \\n};\\n\\n// !! EXTENSION !!\\nMapWidget.prototype = Object.create(Widget.prototype);\\n// !! EXTENSION !!\\n  \\n/**\\n * This handler will open a dialog that allows the user to create a\\n * new relation between two edges. This includes, that the user\\n * gets a chance to specify the edgetype of the connection.\\n * \\n * If an edge-type namespace has been declared for the entire view,\\n * then add it to the `id` of the specified type…\\n *   - …if the type doesn't exist yet.\\n *   - …if the type doesn't contain a namespace already, regardless\\n *     whether it exists or not.\\n * \\n * Once the user confirmed the dialog, the edge is persisted.\\n * \\n * @param {Edge} edge - A javascript object that contains at least\\n *    the properties \\\"from\\\" and \\\"to\\\"\\n * @param {function} [callback] - A function with the signature\\n *    function(isConfirmed);\\n */\\nMapWidget.prototype.handleConnectionEvent = function(edge, callback) {\\n\\n  var eTyFilter = this.view.getEdgeTypeFilter();\\n\\n  var param = {\\n    fromLabel: $tm.adapter.selectNodeById(edge.from).label,\\n    toLabel: $tm.adapter.selectNodeById(edge.to).label,\\n    viewNS: this.view.getConfig(\\\"edge_type_namespace\\\"),\\n    eTyFilter: eTyFilter.raw\\n  };\\n  \\n  var name = \\\"getEdgeType\\\";\\n  this.dialogManager.open(name, param, function(isConfirmed, outTObj) {\\n  \\n    if(isConfirmed) {\\n                  \\n      var type = utils.getText(outTObj);\\n      \\n      var options = {\\n        namespace: this.view.getConfig(\\\"edge_type_namespace\\\")\\n      };\\n      \\n      var type = new EdgeType(type, null, options);\\n                      \\n      // persist the type if it doesn't exist\\n      if(!type.exists()) type.save();\\n      \\n      // add type to edge\\n      edge.type = type.id;\\n      $tm.adapter.insertEdge(edge);\\n      \\n      if(!this.view.isEdgeTypeVisible(type.id)) {\\n        \\n        var args = {\\n          type: type.id,\\n          view: this.view.getLabel(),\\n          eTyFilter: eTyFilter.pretty\\n        };\\n        \\n        this.dialogManager.open(\\\"edgeNotVisible\\\", args);\\n        \\n      }\\n      \\n      this.preventFitAfterRebuild = true;\\n      \\n    }\\n    \\n    if(typeof callback === \\\"function\\\") {\\n      callback(isConfirmed);\\n    }\\n      \\n  });\\n  \\n};\\n\\n/**\\n * The first time a map is opened, we want to display a welcome message.\\n * Once shown, a flag is set and the message is not displayed again.\\n */\\nMapWidget.prototype.checkForFreshInstall = function() {\\n\\n  var sysMeta = $tm.ref.sysMeta;\\n  if(!utils.getEntry(sysMeta, \\\"showWelcomeMessage\\\", true)) return;\\n  \\n  // set flag\\n  utils.setEntry(sysMeta, \\\"showWelcomeMessage\\\", false);\\n  \\n  var args = {};\\n  var name = \\\"welcome\\\";\\n  this.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n\\n    if(utils.tiddlerExists(\\\"$:/plugins/felixhayashi/topstoryview\\\")) {\\n      utils.setText(\\\"$:/view\\\", \\\"top\\\");\\n      utils.setText(\\\"$:/config/Navigation/openLinkFromInsideRiver\\\", \\\"above\\\");\\n      utils.setText(\\\"$:/config/Navigation/openLinkFromOutsideRiver\\\", \\\"top\\\");\\n      \\n      // trigger a save and reload message\\n      utils.touch(\\\"$:/plugins/felixhayashi/topstoryview\\\");\\n    }\\n        \\n    var view = $tm.misc.defaultViewLabel;\\n    \\n    var node = { label: \\\"Have fun with\\\", x: 0, y: 0 };\\n    var n1 = $tm.adapter.insertNode(node, view);\\n    \\n    var node = { label: \\\"TiddlyMap!!\\\", x: 100, y: 100 };\\n    var n2 = $tm.adapter.insertNode(node, view);\\n\\n    $tm.adapter.insertEdge({ from: n1.id, to: n2.id });\\n    \\n  });\\n  \\n};\\n\\n/**\\n * A very basic dialog that will tell the user he/she has to make\\n * a choice.\\n * \\n * @param {function} [callback] - A function with the signature\\n *     function(isConfirmed).\\n * @param {string} [message] - An small optional message to display.\\n */\\nMapWidget.prototype.openStandardConfirmDialog = function(callback, message) {\\n\\n  var param = { message : message };\\n  this.dialogManager.open(\\\"getConfirmation\\\", param, callback);\\n  \\n};\\n\\n/**\\n * An extention of the default logger mechanism. It works like\\n * `this.logger` but will include the object id of the widget\\n * instance.\\n * \\n * @param {string} type - The type of the message (debug, info, warning…)\\n *     which is exactly the same as in `console[type]`.\\n * @param {...*} message - An infinite number of arguments to be printed\\n *     (just like console).\\n */\\nMapWidget.prototype.logger = function(type, message /*, more stuff*/) {\\n  \\n  if(this.isDebug) {\\n  \\n    var args = Array.prototype.slice.call(arguments, 1);\\n    args.unshift(\\\"@\\\" + this.id);\\n    args.unshift(type);\\n    $tm.logger.apply(this, args);\\n    \\n  }\\n  \\n};\\n\\n/**\\n * Method to render this widget into the DOM.\\n * \\n * Note that we do not add this.domNode to the list of domNodes\\n * since this widget does never remove itself during a refresh.\\n * \\n * @override\\n */\\nMapWidget.prototype.render = function(parent, nextSibling) {\\n  \\n  this.parentDomNode = parent;\\n  \\n  this.domNode = this.document.createElement(\\\"div\\\");\\n  parent.insertBefore(this.domNode, nextSibling);\\n    \\n  // add widget classes\\n  this.registerClassNames(this.domNode);\\n  \\n  // get view and view holder\\n  this.viewHolderRef = this.getViewHolderRef();\\n  this.view = this.getView();\\n\\n  // create the header div\\n  this.graphBarDomNode = this.document.createElement(\\\"div\\\");\\n  $tw.utils.addClass(this.graphBarDomNode, \\\"tmap-topbar\\\");\\n  this.domNode.appendChild(this.graphBarDomNode);\\n  \\n  // create body div\\n  this.graphDomNode = this.document.createElement(\\\"div\\\");\\n  this.domNode.appendChild(this.graphDomNode);\\n      \\n  $tw.utils.addClass(this.graphDomNode, \\\"tmap-vis-graph\\\");  \\n\\n  if(utils.isPreviewed(this) || this.domNode.isTiddlyWikiFakeDom) {\\n    \\n    $tw.utils.addClass(this.domNode, \\\"tmap-static-mode\\\");\\n    this.renderPreview(this.graphBarDomNode, this.graphDomNode);\\n    \\n  } else {\\n    \\n    // render the full widget\\n    this.renderFullWidget(this.domNode, this.graphBarDomNode, this.graphDomNode);\\n    \\n  }\\n      \\n};\\n\\n/**\\n * When the widget is only previewed we do some alternative rendering.\\n */\\nMapWidget.prototype.renderPreview = function(header, body) {\\n    \\n  var snapshotTRef = this.view.getRoot() + \\\"/snapshot\\\";\\n  var snapshotTObj = utils.getTiddler(snapshotTRef);\\n  \\n  var label = this.document.createElement(\\\"span\\\");\\n  label.innerHTML = this.view.getLabel();\\n  label.className = \\\"tmap-view-label\\\";\\n  header.appendChild(label);\\n  \\n  if(snapshotTObj) {\\n\\n    // Construct child widget tree\\n    var placeholder = this.makeChildWidget(utils.getTranscludeNode(snapshotTRef), true);\\n    placeholder.renderChildren(body, null);\\n                      \\n  } else {\\n    \\n    $tw.utils.addClass(body, \\\"tmap-graph-placeholder\\\");\\n    \\n  }\\n    \\n};\\n\\n/**\\n * The standard way of rendering.\\n * Attention: BE CAREFUL WITH THE ORDER OF FUNCTION CALLS IN THIS FUNCTION.\\n */\\nMapWidget.prototype.renderFullWidget = function(widget, header, body) {\\n    \\n  // add window and widget dom node listeners\\n  utils.setDomListeners(\\\"add\\\", window, this.windowDomListeners);\\n  utils.setDomListeners(\\\"add\\\", widget, this.widgetDomListeners);\\n      \\n  // add a loading bar\\n  this.addLoadingBar(this.domNode);\\n  \\n  // prepare the tooltip for graph elements\\n  this.tooltip = new Popup(this.domNode, {\\n    className: \\\"tmap-tooltip\\\",\\n    showDelay: $tm.config.sys.popups.delay\\n  });\\n  \\n  // prepare the context menu\\n  this.contextMenu = new Popup(this.domNode, {\\n    className: \\\"tmap-context-menu\\\",\\n    showDelay: 0,\\n    hideOnClick: true,\\n    leavingDelay: 999999\\n  });\\n    \\n  // register \\n  this.sidebar = utils.getFirstElementByClassName(\\\"tc-sidebar-scrollable\\\");\\n  this.isInSidebar = (this.sidebar\\n                               && !this.domNode.isTiddlyWikiFakeDom\\n                               && this.sidebar.contains(this.domNode));\\n                                                 \\n  // flag that determines whether to zoom after stabilization finished;\\n  // always set to false after the next stabilization\\n  this.doFitAfterStabilize = true;\\n  \\n  // flag that determines whether to zoom after rebuilding the graph;\\n  // always set to false after the next rebuild\\n  this.preventFitAfterRebuild = false;\\n                  \\n  // *first* inject the bar\\n  this.initAndRenderEditorBar(header);\\n  \\n  // *second* initialise graph variables and render the graph\\n  this.initAndRenderGraph(body);\\n\\n  // register this graph at the caretaker's graph registry\\n  $tm.registry.push(this);\\n  \\n  // if any refresh-triggers exist, register them\\n  this.reloadRefreshTriggers();\\n  \\n  // maybe display a welcome message\\n  this.checkForFreshInstall();\\n  \\n  if(this.id === $tm.misc.mainEditorId) {\\n    \\n    var url = $tm.url;\\n    if(url && url.query[\\\"tmap-enlarged\\\"]) {\\n    \\n      this.toggleEnlargedMode(url.query[\\\"tmap-enlarged\\\"]);\\n      //~ this.setView(url.query[\\\"tmap-view\\\"]);\\n    \\n    }\\n    \\n  }\\n  \\n};\\n\\n/**\\n * Add some classes to give the user a chance to apply some css\\n * to different graph modes.\\n */  \\nMapWidget.prototype.registerClassNames = function(parent) {\\n  \\n  var addClass = $tw.utils.addClass;\\n  \\n  // add main class\\n  addClass(parent, \\\"tmap-widget\\\");\\n\\n  if(this.clickToUse) {\\n    addClass(parent, \\\"tmap-click-to-use\\\");\\n  }\\n  \\n  if(this.getAttr(\\\"editor\\\") === \\\"advanced\\\") {\\n    addClass(parent, \\\"tmap-advanced-editor\\\");\\n  }\\n  \\n  if(this.getAttr(\\\"design\\\") === \\\"plain\\\") {\\n    addClass(parent, \\\"tmap-plain-design\\\");\\n  }\\n  \\n  if(!utils.isTrue(this.getAttr(\\\"show-buttons\\\"), true)) {\\n    addClass(parent, \\\"tmap-no-buttons\\\");\\n  }\\n  \\n  if(this.getAttr(\\\"class\\\")) {\\n    addClass(parent, this.getAttr(\\\"class\\\"));\\n  }\\n  \\n};\\n\\n/**\\n * Adds a loading bar div below the parent.\\n */\\nMapWidget.prototype.addLoadingBar = function(parent) {\\n                \\n  this.graphLoadingBarDomNode = this.document.createElement(\\\"progress\\\");\\n  $tw.utils.addClass(this.graphLoadingBarDomNode, \\\"tmap-loading-bar\\\");\\n  parent.appendChild(this.graphLoadingBarDomNode);\\n  \\n};\\n\\n/**\\n * The editor bar contains a bunch of widgets that allow the user\\n * to manipulate the current view.\\n * \\n * Attention: The Editor bar needs to render *after* the graph\\n * because some elements depend on the graph's nodes which are\\n * calculated when the network is created.\\n * \\n * @param {Element} parent The dom node in which the editor bar will\\n *     be injected in.\\n */\\nMapWidget.prototype.initAndRenderEditorBar = function(parent) {\\n          \\n    this.rebuildEditorBar();\\n  \\n};\\n\\n/**\\n * Creates this widget's child-widgets.\\n * \\n * @see https://groups.google.com/forum/#!topic/tiddlywikidev/sJrblP4A0o4\\n * @see blob/master/editions/test/tiddlers/tests/test-wikitext-parser.js\\n */\\nMapWidget.prototype.rebuildEditorBar = function() {\\n      \\n  // register variables\\n  \\n  var view = this.view;\\n  var variables = {\\n    widgetQualifier: this.getStateQualifier(),\\n    widgetTempPath: this.widgetTempPath,\\n    widgetPopupsPath: this.widgetPopupsPath,\\n    isViewBound: String(this.isViewBound()),\\n    viewRoot: view.getRoot(),\\n    viewLabel: view.getLabel(),\\n    viewHolder: this.getViewHolderRef(),\\n    edgeTypeFilter: view.getPaths().edgeTypeFilter,\\n    allEdgesFilter: $tm.selector.allEdgeTypes,\\n    neighScopeBtnClass: \\\"tmap-neigh-scope-button\\\"\\n                        + (view.isEnabled(\\\"neighbourhood_scope\\\")\\n                           ? \\\" \\\" + \\\"tmap-active-button\\\"\\n                           : \\\"\\\")\\n  };\\n  \\n  for(var name in variables) {\\n    this.setVariable(name, variables[name]);\\n  }\\n  \\n  // Construct the child widget tree\\n  var body = utils.getTiddlerNode(view.getRoot());\\n  \\n  if(this.editorMode === \\\"advanced\\\") {\\n    \\n    body.children.push(utils.getTranscludeNode($tm.ref.graphBar));\\n    \\n  } else {\\n    \\n    var el = utils.getElementNode(\\\"span\\\", view.getLabel(), \\\"tmap-view-label\\\");\\n    body.children.push(el);\\n    \\n  }\\n  \\n  body.children.push(utils.getTranscludeNode($tm.ref.focusButton));\\n        \\n  this.makeChildWidgets([ body ]);\\n  this.renderChildren(this.graphBarDomNode, this.graphBarDomNode.firstChild);\\n\\n};\\n    \\n/**\\n * This function is called by the system to notify the widget about\\n * tiddler changes. It is ignored by TiddlyMap.\\n * \\n * ATTENTION: TiddlyMap doesn't use the refresh mechanism here.\\n * The caretaker module dispatches an `updates` object that provides\\n * more advanced information, tailored to the needs of TiddlyMap.\\n * These updates are picked up by {@link MapWidget#updates}.\\n * \\n * @override\\n */\\nMapWidget.prototype.refresh = function(changedTiddlers) {\\n\\n  // TiddlyMap never needs a full refresh so we return false\\n  return false;  \\n    \\n};\\n\\n/**\\n * This function is called by the caretaker module to notify the\\n * widget about tiddler changes.\\n * \\n * TiddlyMap is interested in the following changes:\\n * \\n * - Callbacks have been triggered (e.g. dialog results)\\n * - A view has been switched\\n * - A view has been modified (= configured)\\n * - Global options have changed\\n * - Node- or edge-types have changed\\n * - Graph elements have changed\\n * - Changes to the graph's topbar\\n * \\n * @override\\n * @see https://groups.google.com/d/msg/tiddlywikidev/hwtX59tKsIk/EWSG9glqCnsJ\\n */\\nMapWidget.prototype.update = function(updates) {\\n  \\n  if(!this.network || this.isZombieWidget() || utils.isPreviewed(this)) {\\n    return;\\n  }\\n  \\n  var changedTiddlers = updates.changedTiddlers;\\n  var rebuildEditorBar = false;\\n  var rebuildGraph = false;\\n  var reinitNetwork = false;\\n  var rebuildGraphOptions = {};\\n  \\n  // check for callback changes\\n  this.callbackManager.handleChanges(changedTiddlers);\\n                             \\n  if(this.isViewSwitched(changedTiddlers)\\n     || this.hasChangedAttributes()\\n     || updates[$tm.path.options]\\n     || updates[$tm.path.nodeTypes]\\n     || changedTiddlers[this.view.getRoot()]) {\\n    \\n    this.logger(\\\"warn\\\", \\\"View switched (or main config change)\\\");\\n        \\n    this.view = this.getView(true);\\n    this.reloadRefreshTriggers();\\n    \\n    rebuildEditorBar = true;\\n    reinitNetwork = true;\\n    \\n  } else { // view has not been switched\\n    \\n    // give the view a chance to refresh its components\\n    var isViewUpdated = this.view.update(updates);\\n    \\n    if(isViewUpdated && !this.ignoreNextViewModification) {\\n\\n      this.logger(\\\"warn\\\", \\\"View components modified\\\");\\n      \\n      this.reloadBackgroundImage();\\n      rebuildEditorBar = true;\\n      rebuildGraph = true;\\n      rebuildGraphOptions.resetEdgeTypeWL = true;\\n      \\n      if(!this.preventFitAfterRebuild) {\\n        rebuildGraphOptions.resetFocus = { delay: 0, duration: 0 };\\n      }\\n    \\n    } else { // neither view switch or view modification\\n    \\n      if(updates[$tm.path.nodeTypes]) {\\n        rebuildGraph = true;\\n        \\n      } else if(this.hasChangedElements(changedTiddlers)) {\\n        rebuildGraph = true;\\n      }\\n      \\n    }\\n  }\\n  \\n  if(reinitNetwork) {\\n    this.initAndRenderGraph(this.graphDomNode);\\n    this.hidePopups(0, true);\\n    \\n  } else if(rebuildGraph) {\\n    this.rebuildGraph(rebuildGraphOptions);\\n    this.hidePopups(0, true);\\n  }\\n  \\n  if(rebuildEditorBar) {\\n    \\n    this.removeChildDomNodes();\\n    this.rebuildEditorBar();\\n    \\n  } else {\\n    \\n    // give children a chance to update themselves\\n    this.refreshChildren(changedTiddlers);\\n    \\n  }\\n  \\n  // reset this again\\n  this.ignoreNextViewModification = false;\\n  \\n};\\n\\nMapWidget.prototype.hidePopups = function(delay, isForce) {\\n  \\n  this.tooltip.hide(delay, isForce);\\n  this.contextMenu.hide(0, true);\\n  \\n};\\n\\n/**\\n * Refresh-triggers are tiddlers whose mere occurrence in the\\n * changedTiddlers list forces tiddlymap to reassert\\n * whether a filter expression returns the same set of matches as it\\n * is currently displayed in the graph.\\n * \\n * The raison d'etre for refresh-triggers is that a filter may contain\\n * implicit text-references or variables that may require a filter to be\\n * reasserted even though, the filter expression itself did not change.\\n * \\n * For example a filter `[field:title{$:/HistoryList!!current-tiddler}]`\\n * requires a `$:/HistoryList` refresh trigger to be added to the view so\\n * everytime the `$:/HistoryList` tiddler changes, the filter gets\\n * reasserted.\\n */\\nMapWidget.prototype.reloadRefreshTriggers = function() { \\n  \\n  // remove old triggers (if there are any)\\n  this.callbackManager.remove(this.refreshTriggers);\\n      \\n  // load new trigger list either from attribute or view config\\n  var str = this.getAttr(\\\"refresh-triggers\\\")\\n            || this.view.getConfig(\\\"refresh-triggers\\\");\\n  this.refreshTriggers = $tw.utils.parseStringArray(str) || [];\\n  \\n  this.logger(\\\"debug\\\", \\\"Registering refresh trigger\\\", this.refreshTriggers);\\n  \\n  // TODO: not nice, if more than one trigger changed it\\n  // will cause multiple reassertments\\n  for(var i = this.refreshTriggers.length; i--;) {\\n    this.callbackManager.add(this.refreshTriggers[i],\\n                             this.handleTriggeredRefresh,\\n                             false);\\n  }\\n  \\n};\\n\\n/**\\n * Calling this method will cause the graph to be rebuild, which means\\n * the graph data is refreshed. A rebuild of the graph will always\\n * cause the network to stabilize again.\\n * \\n * @param {Hashmap} [options] - An optional options object.\\n * @param {boolean} [options.refreshData=false] - If this is set to\\n *     true, all datasets will be cleared before new data is added.\\n *     This guarantees a fresh start. This option should only be\\n *     used when the topic of the graph changes (= view switched).\\n * @param {boolean} [options.refreshOptions=false] - If this is set\\n *     to true, the vis options will also be reloaded. This option\\n *     should only be used if the options have actually changed, which\\n *     is always the case when a view is switched or sometimes when\\n *     a view is modified.\\n * @param {Hashmap} [options.resetFocus=null] - If not false or null,\\n *     this object requires two properties to be set: `delay` (the\\n *     time to wait before starting the fit), `duration` (the length\\n *     of the fit animation). If the global flag `preventFitAfterRebuild`\\n *     is set to true at the time `rebuildGraph` is called with the\\n *     `resetFocus` option specified, then it overrules this option\\n *     and the fit will not take place. After the rebuild,\\n *     `preventFitAfterRebuild` is said to false again.\\n */\\nMapWidget.prototype.rebuildGraph = function(options) {\\n  \\n  if(utils.isPreviewed(this)) return;\\n  \\n  this.logger(\\\"debug\\\", \\\"Rebuilding graph\\\");\\n    \\n  options = options || {};\\n  \\n  // always reset to allow handling of stabilized-event!\\n  this.hasNetworkStabilized = false;\\n    \\n  if(options.resetData) {\\n    this.graphData.edges.clear();\\n    this.graphData.nodes.clear();\\n    this.graphData.edgesById = null;\\n    this.graphData.nodesById = null;\\n  }\\n  \\n  if(!this.view.isEnabled(\\\"physics_mode\\\")) {\\n    \\n    // in static mode we need to ensure that objects spawn\\n    // near center so we need to set physics from\\n    // zero to something. Yes, we override the users\\n    // central gravity value… who cares about central\\n    // gravity in static mode anyways.\\n    var physics = this.visOptions.physics;\\n    physics[physics.solver].centralGravity = 0.015;\\n  }\\n    \\n  if(!options.resetFocus) {\\n    // option or data resets always overrule any flags!\\n    this.doFitAfterStabilize = false;\\n  }\\n    \\n  this.rebuildGraphData();\\n  \\n  //~ this.rebuildGraphData({\\n    //~ resetEdgeTypeWL: options.resetEdgeTypeWL\\n  //~ });\\n  \\n  if(!utils.hasElements(this.graphData.nodesById)) {\\n    return;\\n  }\\n\\n  // see https://github.com/almende/vis/issues/987#issuecomment-113226216\\n  // see https://github.com/almende/vis/issues/939\\n  this.network.stabilize();\\n  \\n  // resetting the focus is not the same as zooming after stabilization,\\n  // the question is whether after a rebuild the focus should be immediately\\n  // reset or not. Zooming after stabilization does always(!) takes place\\n  // after a rebuild, in contrast, resetting the focus doesn't necessarily take place.\\n  if(options.resetFocus && !this.preventFitAfterRebuild) {\\n    \\n    // a not-prevented focus reset will always also cause a fit after stabilize\\n    this.doFitAfterStabilize = true;\\n    this.fitGraph(options.resetFocus.delay, options.resetFocus.duration);\\n        \\n  }\\n  \\n  // in any case, reset to default\\n  this.preventFitAfterRebuild = false;\\n  \\n};\\n\\n/**\\n * WARNING: Do not change this functionname as it is used by the\\n * caretaker's routinely checkups.\\n */\\nMapWidget.prototype.getContainer = function() {\\n  \\n  return this.domNode;\\n  \\n};\\n\\n/**\\n * \\n */\\nMapWidget.prototype.rebuildGraphData = function(options) {\\n  \\n  $tm.start(\\\"Reloading Network\\\");\\n  \\n  options = options || {};\\n  \\n  //~ if(!this.edgeTypeWL || options.resetEdgeTypeWL) {\\n    //~ this.rebuildEdgeTypeWL();\\n  //~ }\\n  \\n  var graph = $tm.adapter.getGraph({\\n    view: this.view\\n    //~ ,edgeTypeWL: this.edgeTypeWL\\n  });    \\n  \\n  var nodes = graph.nodes;\\n  var edges = graph.edges;\\n      \\n  this.graphData.nodes = this.getRefreshedDataSet(nodes, // new nodes\\n                                       this.graphData.nodesById, // old nodes\\n                                       this.graphData.nodes); // dataset\\n                                                                                \\n  this.graphData.edges = this.getRefreshedDataSet(edges, // new edges\\n                                       this.graphData.edgesById, // old edges\\n                                       this.graphData.edges); // dataset\\n                                     \\n  // create lookup tables\\n  \\n  this.graphData.nodesById = nodes;\\n  this.graphData.edgesById = edges;\\n  \\n  // TODO: that's a performance killer. this should be loaded when\\n  // the search is actually used!\\n  // update: Careful when refactoring, some modules are using this…\\n  utils.setField(\\\"$:/temp/tmap/nodes/\\\" + this.view.getLabel(),\\n                 \\\"list\\\",\\n                 $tm.adapter.getTiddlersById(nodes));\\n  \\n  $tm.stop(\\\"Reloading Network\\\");\\n  \\n  return this.graphData;\\n      \\n};\\n\\nMapWidget.prototype.isViewBound = function() {\\n  \\n  return utils.startsWith(this.getViewHolderRef(), $tm.path.localHolders);  \\n  \\n};\\n  \\n/**\\n * A view is switched, if the holder was changed.\\n */\\nMapWidget.prototype.isViewSwitched = function(changedTiddlers) {\\n  \\n  return changedTiddlers[this.getViewHolderRef()];\\n  \\n};\\n\\n/**\\n * A view is switched, if the holder was changed.\\n */\\nMapWidget.prototype.hasChangedAttributes = function() {\\n  \\n  return Object.keys(this.computeAttributes()).length;\\n  \\n};\\n\\n/**\\n * Rebuild or update the graph if one of the following is true:\\n * \\n * 1. A tiddler currently contained as node in the graph has been\\n *    deleted or modified. This also includes tiddlers that are \\n *    represented as neighbours in the graph.\\n * 2. The neighbourhood is shown and a non-system tiddler has changed.\\n * 3. A tiddler that matches the node filter has been modified\\n *    (not deleted).\\n * \\n * Since edges are stored in tiddlers themselves, any edge modification\\n * is always accounted for as in this case the tiddler holding the\\n * edge would be included as changed tiddler.\\n * \\n * @param {Hashmap<TiddlerReference, *>} changedTiddlers - A list of\\n *     tiddler changes.\\n * \\n * @return {boolean} true if the graph needs a refresh.\\n */\\nMapWidget.prototype.hasChangedElements = function(changedTiddlers) {\\n    \\n  var maybeMatches = [];\\n  var inGraph = this.graphData.nodesById;\\n  var isShowNeighbourhood = this.view.isEnabled(\\\"neighbourhood_scope\\\");\\n  var edgeTypeWL = this.view.getEdgeTypeFilter(\\\"whitelist\\\");\\n  \\n  for(var tRef in changedTiddlers) {\\n    if(utils.isSystemOrDraft(tRef)) continue;\\n    \\n    if(inGraph[$tm.adapter.getId(tRef)] || isShowNeighbourhood) {\\n      return true;\\n    }\\n    \\n    if(changedTiddlers[tRef].modified) {\\n      // still may be a match so we store this and process it later\\n      maybeMatches.push(tRef);\\n    }\\n  }\\n  \\n  if(maybeMatches.length) {\\n    \\n    var nodeFilter = this.view.getNodeFilter(\\\"compiled\\\");\\n    var matches = utils.getMatches(nodeFilter, maybeMatches);\\n    return !!matches.length;\\n    \\n  }\\n  \\n};\\n    \\n/**\\n * Rebuild the graph\\n * \\n * @see\\n *   - http://visjs.org/docs/network.html\\n *   - http://visjs.org/docs/dataset.html\\n */\\nMapWidget.prototype.initAndRenderGraph = function(parent) {\\n  \\n  // make sure to destroy any previous instance\\n  if(this.network) this._destructVis();\\n  \\n  this.logger(\\\"info\\\", \\\"Initializing and rendering the graph\\\");\\n          \\n  if(!this.isInSidebar) {\\n    this.callbackManager.add(\\\"$:/state/sidebar\\\", this.handleResizeEvent);\\n  }\\n  \\n  this.visOptions = this.getVisOptions();\\n  //~ this.edgeTypeWL = null;\\n  this.graphData = {\\n    nodes: new vis.DataSet(),\\n    edges: new vis.DataSet(),\\n    nodesById: utils.makeHashMap(),\\n    edgesById: utils.makeHashMap()\\n  };\\n  \\n  this.tooltip.setEnabled(\\n    utils.isTrue($tm.config.sys.popups.enabled, true));\\n  \\n  this.network = new vis.Network(parent, this.graphData, this.visOptions);\\n  // after vis.Network has been instantiated, we fetch a reference to\\n  // the canvas element\\n  this.canvas = parent.getElementsByTagName(\\\"canvas\\\")[0];\\n  // just to be sure\\n  this.canvas.tabIndex = 0;\\n  \\n  for(var event in this.visListeners) {\\n    this.network.on(event, this.visListeners[event].bind(this));\\n  }\\n  \\n  this.addGraphButtons({\\n    \\\"fullscreen-button\\\": function() {\\n      this.toggleEnlargedMode(\\\"fullscreen\\\"); },\\n    \\\"halfscreen-button\\\": function() {\\n      this.toggleEnlargedMode(\\\"halfscreen\\\"); }\\n  });\\n  \\n  utils.setDomListeners(\\\"add\\\", this.canvas, this.canvasDomListeners);\\n  \\n  this.reloadBackgroundImage();\\n  this.rebuildGraph({ resetFocus: { delay: 0, duration: 0 }});\\n  this.handleResizeEvent();\\n  this.canvas.focus();\\n\\n};\\n\\nMapWidget.prototype.handleCanvasKeyup = (function() {\\n    \\n  var conVector = { from: null, to: null };\\n  \\n  // we return an inner closure so we have shared access to conVector\\n  return function(ev) {\\n    var nodeIds = this.network.getSelectedNodes();\\n    \\n    if(ev.ctrlKey) { // ctrl key is hold down\\n      ev.preventDefault();\\n      \\n      if(ev.keyCode === 88) { // x\\n        if(this.editorMode) {\\n          this.handleAddNodesToClipboard(\\\"move\\\");\\n        } else {\\n          $tm.notify(\\\"Map is read only!\\\");\\n        }\\n        \\n      } else if(ev.keyCode === 67) { // c\\n        this.handleAddNodesToClipboard(\\\"copy\\\");\\n        \\n      } else if(ev.keyCode === 86) { // v\\n        this.handlePasteNodesFromClipboard();\\n      \\n      } else if(ev.keyCode === 65) { // a\\n        var allNodes = Object.keys(this.graphData.nodesById);\\n        this.network.selectNodes(allNodes);\\n        \\n      } else if(ev.keyCode === 49 || ev.keyCode === 50) { // 1 || 2\\n        if(nodeIds.length !== 1) return;\\n        \\n        var role = ev.keyCode === 49 ? \\\"from\\\" : \\\"to\\\";\\n        $tm.notify(utils.ucFirst(role) + \\\"-part selected\\\");\\n        \\n        conVector[role] = nodeIds[0];\\n        if(conVector.from && conVector.to) {\\n          // create the edge\\n          this.handleConnectionEvent(conVector, function() {\\n            // reset both properties, regardless whether confirmed\\n            conVector = { from: null, to: null };\\n          });\\n        }\\n        \\n      }\\n      \\n    } else if(ev.keyCode === 13) { // ENTER\\n      \\n      if(nodeIds.length !== 1) return;\\n      \\n      this.openTiddlerWithId(nodeIds[0]);\\n      \\n    }\\n  }\\n})();\\n\\nMapWidget.prototype.handleDeleteElement = function(ev) {\\n  \\n  var id = ev.paramObject.id;\\n  var elements = (id ? [ id ] : this.network.getSelectedNodes());\\n  \\n  this.handleRemoveElements({\\n    nodes: elements\\n  });\\n  \\n};\\n\\nMapWidget.prototype.handleConfigureElement = function(ev) {\\n  \\n  \\n};\\n\\nMapWidget.prototype.handleCanvasKeydown = function(ev) {\\n\\n  if(ev.keyCode === 46) { // delete\\n    ev.preventDefault();\\n    this.handleRemoveElements(this.network.getSelection());\\n  }\\n  \\n};\\n\\n//https://github.com/almende/vis/blob/111c9984bc4c1870d42ca96b45d90c13cb92fe0a/lib/network/modules/InteractionHandler.js\\nMapWidget.prototype.handleCanvasScroll = function(ev) {\\n\\n  var zoomView = !!(ev.ctrlKey || this.isInSidebar || this.enlargedMode);\\n  \\n  if(zoomView) {\\n    ev.preventDefault();\\n  }\\n  \\n  if(zoomView !== this.visOptions.interaction.zoomView) {\\n    \\n    ev.preventDefault();\\n    ev.stopPropagation();\\n        \\n    this.visOptions.interaction.zoomView = zoomView;\\n    this.network.setOptions({ interaction: { zoomView: zoomView }});\\n    \\n    return false;\\n  }\\n\\n};\\n\\n/**\\n * Called when the user click on the canvas with the right\\n * mouse button. A context menu is opened.\\n */\\nMapWidget.prototype.handleContextMenu = function(ev) {\\n  \\n  ev.preventDefault();\\n  \\n  this.tooltip.hide(0, true);\\n  \\n  var nodeId = this.network.getNodeAt({ x: ev.offsetX, y: ev.offsetY });\\n  if(!nodeId) return;\\n  \\n  // ids of selected nodes\\n  var selectedNodes = this.network.getSelectedNodes();\\n  \\n  if(!utils.inArray(nodeId, selectedNodes)) {\\n    // unselect other nodes and select this one instead…\\n    selectedNodes = [ nodeId ];\\n    this.network.selectNodes(selectedNodes);\\n  }\\n  \\n  this.contextMenu.show(selectedNodes, function(selectedNodes, div) {\\n        \\n    var mode = (selectedNodes.length > 1 ? \\\"multi\\\" : \\\"single\\\");\\n    \\n    var tRef = \\\"$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node\\\";\\n    utils.registerTransclude(this, \\\"contextMenuWidget\\\", tRef);\\n    this.contextMenuWidget.setVariable(\\\"mode\\\", mode);\\n    this.contextMenuWidget.render(div);\\n      \\n  }.bind(this));\\n\\n};\\n\\nMapWidget.prototype.handleWidgetKeyup = function(ev) {\\n\\n};\\n\\nMapWidget.prototype.handleWidgetKeydown = function(ev) {\\n    \\n  if(ev.ctrlKey) { // ctrl key is hold down\\n    ev.preventDefault();\\n    \\n    if(ev.keyCode === 70) { // f\\n      ev.preventDefault(); \\n            \\n      var focusButtonStateTRef = this.widgetPopupsPath + \\\"/focus\\\";\\n      utils.setText(focusButtonStateTRef,\\n                    utils.getText(focusButtonStateTRef) ? \\\"\\\" : \\\"1\\\");\\n                    \\n      // note: it is ok to focus the graph right after this,\\n      // if the focus button is activated it will steal the focus anyway\\n\\n    } else {\\n      return;\\n    }\\n  \\n  } else if(ev.keyCode === 120) { // F9\\n    ev.preventDefault();\\n    this.toggleEnlargedMode(\\\"halfscreen\\\");\\n\\n  } else if(ev.keyCode === 121) { // F10\\n    ev.preventDefault();\\n    this.toggleEnlargedMode(\\\"fullscreen\\\");\\n\\n  } else if(ev.keyCode === 27) { // ESC\\n    ev.preventDefault();\\n    \\n    utils.deleteByPrefix(this.widgetPopupsPath);\\n    \\n  } else {\\n    return;\\n  }\\n  \\n  this.canvas.focus();\\n  \\n};\\n  \\nMapWidget.prototype.handlePasteNodesFromClipboard = function() {\\n  \\n  if(!this.editorMode || this.view.isLiveView()) {\\n    $tm.notify(\\\"Map is read only!\\\");\\n    return;\\n  }\\n  \\n  if($tm.clipBoard) {\\n    if($tm.clipBoard.type === \\\"nodes\\\") {\\n      var nodes = $tm.clipBoard.nodes;\\n      var ids = Object.keys(nodes);\\n      if(ids.length) {\\n        for(var id in nodes) {\\n          \\n          // node already present in this view\\n          if(this.graphData.nodesById[id]) continue;\\n          \\n          this.view.addNode(nodes[id]);\\n          // paste nodes already so we can select them!\\n          this.graphData.nodes.update({\\n            id: id\\n          });\\n        }\\n        this.network.selectNodes(ids);\\n        $tm.notify(\\\"pasted \\\" + ids.length + \\\" nodes into map.\\\");\\n      }\\n      return;\\n    }\\n  }\\n  \\n  $tm.notify(\\\"TiddlyMap clipboad is empty!\\\");\\n    \\n};\\n\\nMapWidget.prototype.handleAddNodesToClipboard = function(mode) {\\n  \\n  var nodeIds = this.network.getSelectedNodes();\\n  if(!nodeIds.length) return;\\n  \\n  $tm.clipBoard = {\\n    type: \\\"nodes\\\",\\n    nodes: this.graphData.nodes.get(nodeIds,\\n                                    { returnType: \\\"Object\\\" })\\n  };\\n  \\n  $tm.notify(\\\"Copied \\\" + nodeIds.length + \\\" nodes to clipboard\\\");\\n  \\n  if(mode === \\\"move\\\") {\\n    for(var i = nodeIds.length; i--;) {\\n      this.view.removeNode(nodeIds[i]);\\n    }\\n  }\\n    \\n};\\n\\nMapWidget.prototype.isMobileMode = function() {\\n  \\n  var breakpoint = utils.getText($tm.ref.sidebarBreakpoint, 960);\\n  return (window.innerWidth <= parseInt(breakpoint));\\n         \\n};\\n\\n/**\\n * @todo Instead of redrawing the whole graph when an edge or node is\\n * added it may be worth considering only getting the element from the\\n * adapter and directly inserting it into the graph and *avoid* a\\n * reload of the graph via `rebuildGraph`!\\n * \\n * @todo: too much recomputation -> outsource\\n */\\nMapWidget.prototype.getVisOptions = function() {\\n  \\n  // merge options\\n  var globalOptions = $tm.config.vis;\\n  var localOptions = utils.parseJSON(this.view.getConfig(\\\"vis\\\"));\\n  var options = utils.merge({}, globalOptions, localOptions);\\n  \\n  options.clickToUse = this.clickToUse;\\n\\n  options.manipulation.enabled = !!this.editorMode;\\n  \\n  options.manipulation.deleteNode = function(data, callback) {\\n    this.handleRemoveElements(data);\\n    this.resetVisManipulationBar(callback);\\n  }.bind(this);\\n  \\n  options.manipulation.deleteEdge = function(data, callback) {\\n    this.handleRemoveElements(data);\\n    this.resetVisManipulationBar(callback);\\n  }.bind(this);\\n  \\n  options.manipulation.addEdge = function(data, callback) {\\n    this.handleConnectionEvent(data);\\n    this.resetVisManipulationBar(callback);\\n  }.bind(this);\\n\\n  options.manipulation.addNode = function(data, callback) {\\n    this.handleInsertNode(data);\\n    this.resetVisManipulationBar(callback);\\n  }.bind(this);\\n  \\n  options.manipulation.editNode = function(data, callback) {\\n    this.handleEditNode(data);\\n    this.resetVisManipulationBar(callback);\\n  }.bind(this);\\n  \\n  options.interaction.zoomView = !!(this.isInSidebar || this.enlargedMode);\\n  \\n  // not allowed\\n  options.manipulation.editEdge = false;\\n  \\n  // make sure the actual solver is an object\\n  var physics = options.physics;\\n  physics[physics.solver] = physics[physics.solver] || {};\\n   \\n  physics.stabilization.iterations = 1000;\\n  \\n  this.logger(\\\"debug\\\", \\\"Loaded graph options\\\", options);\\n    \\n  return options;\\n  \\n};\\n\\nMapWidget.prototype.resetVisManipulationBar = function(visCallback) {\\n  \\n  if(visCallback) visCallback(null);\\n  this.network.disableEditMode();\\n  this.network.enableEditMode();\\n  \\n};\\n\\nMapWidget.prototype.isVisInEditMode = function() {\\n  \\n  var cls = \\\"vis-button vis-back\\\";\\n  return this.graphDomNode.getElementsByClassName(cls).length > 0;\\n  \\n};\\n\\n/**\\n * Create an empty view. A dialog is opened that asks the user how to\\n * name the view. The view is then registered as current view.\\n */\\nMapWidget.prototype.handleCreateView = function() {\\n  \\n  var args = {\\n    view: this.view.getLabel()\\n  };\\n  \\n  var name = \\\"createView\\\";\\n  this.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n  \\n    if(!isConfirmed) return;\\n      \\n    var label = utils.getField(outTObj, \\\"name\\\");\\n    var isClone = utils.getField(outTObj, \\\"clone\\\", false);\\n    var view = new ViewAbstraction(label);\\n    \\n    if(view.exists()) {\\n      $tm.notify(\\\"Forbidden! View already exists!\\\");\\n      return;\\n    }\\n\\n    if(isClone && this.view.isLiveView()) {\\n      $tm.notify(\\\"Forbidden to clone the live view!\\\");\\n      return;\\n    }\\n    \\n    view = new ViewAbstraction(label, {\\n      isCreate: true,\\n      protoView: (isClone ? this.view : null)\\n    });\\n\\n    this.setView(view);\\n    \\n  });\\n  \\n};\\n\\nMapWidget.prototype.handleRenameView = function() {\\n     \\n  if(this.view.isLocked()) {\\n    \\n    $tm.notify(\\\"Forbidden!\\\");\\n    return;\\n    \\n  }\\n\\n  var references = this.view.getOccurrences();\\n  \\n  var args = {\\n    count : references.length.toString(),\\n    filter : utils.joinAndWrap(references, \\\"[[\\\", \\\"]]\\\")\\n  };\\n\\n  var name = \\\"renameView\\\";\\n  this.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n  \\n    if(isConfirmed) {\\n      \\n      var label = utils.getText(outTObj);\\n      var view = new ViewAbstraction(label);\\n      \\n      if(!label) {\\n        $tm.notify(\\\"Invalid name!\\\");\\n        \\n      } else if(view.exists()) {\\n        $tm.notify(\\\"Forbidden! View already exists!\\\");\\n        \\n      } else {\\n        this.view.rename(label);\\n        this.setView(this.view);\\n      }\\n      \\n    }\\n\\n  });\\n  \\n};\\n\\nMapWidget.prototype.handleEditView = function() {\\n  \\n  var visInherited = JSON.stringify($tm.config.vis);\\n  var data = this.graphData;\\n  \\n  var viewConfig = this.view.getConfig();\\n  \\n  var preselects = {\\n    \\\"filter.prettyNodeFltr\\\": this.view.getNodeFilter(\\\"pretty\\\"),\\n    \\\"filter.prettyEdgeFltr\\\": this.view.getEdgeTypeFilter(\\\"pretty\\\"),\\n    \\\"vis-inherited\\\": visInherited\\n  };\\n  \\n  var args = {\\n    view: this.view.getLabel(),\\n    createdOn: this.view.getCreationDate(true),\\n    numberOfNodes: Object.keys(data.nodesById).length.toString(),\\n    numberOfEdges: Object.keys(data.edgesById).length.toString(),\\n    dialog: {\\n      preselects: $tw.utils.extend({}, viewConfig, preselects)\\n    }\\n  };\\n  \\n  var name = \\\"configureView\\\";\\n  this.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n    \\n    if(!isConfirmed) return;\\n      \\n    var config = utils.getPropertiesByPrefix(outTObj.fields, \\\"config.\\\", true);\\n    \\n    // ATTENTION: needs to be tested before applying new config!\\n    var prvBg = this.view.getConfig(\\\"background_image\\\");\\n    \\n    this.view.setConfig(config);\\n    if(config[\\\"physics_mode\\\"] && !this.view.isEnabled(\\\"physics_mode\\\")) {\\n      // when not in physics mode, store positions\\n      // to prevent floating afterwards\\n      this.handleStorePositions();\\n    }\\n    \\n    var curBg = this.view.getConfig(\\\"background_image\\\");\\n    if(curBg && curBg !== prvBg) {\\n      $tm.notify(\\\"Background changed! You may need to zoom out a bit.\\\");      \\n    }\\n    \\n    var nf = utils.getField(outTObj, \\\"filter.prettyNodeFltr\\\", \\\"\\\");\\n    var eTf = utils.getField(outTObj, \\\"filter.prettyEdgeFltr\\\", \\\"\\\");\\n    \\n    this.view.setNodeFilter(nf);\\n    this.view.setEdgeTypeFilter(eTf);\\n          \\n  });\\n  \\n};\\n\\n/**\\n * Triggers a download dialog where the user can store the canvas\\n * as png on his/her harddrive.\\n */\\nMapWidget.prototype.handleSaveCanvas = function() {\\n  \\n  var tempImagePath = \\\"$:/temp/tmap/snapshot\\\";\\n  var tempImage = this.createAndSaveSnapshot(tempImagePath);\\n  var defaultName = utils.getSnapshotTitle(this.view.getLabel(), \\\"png\\\");\\n  \\n  var args = {\\n    dialog: {\\n      snapshot: tempImagePath,\\n      width: this.canvas.width.toString(),\\n      height: this.canvas.height.toString(),\\n      preselects: {\\n        name: defaultName,\\n        action: \\\"download\\\"\\n      }\\n    }\\n  };\\n\\n  var name = \\\"saveCanvas\\\";\\n  this.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n    if(!isConfirmed) return;\\n    \\n    // allow the user to override the default name or if name is\\n    // empty use the original default name\\n    defaultName = outTObj.fields.name || defaultName;\\n    \\n    var action = outTObj.fields.action;\\n    \\n    if(action === \\\"download\\\") {\\n      this.handleDownloadSnapshot(defaultName);\\n      \\n    } else if(action === \\\"wiki\\\") { \\n      utils.cp(tempImagePath, defaultName, true); \\n      this.dispatchEvent({\\n        type: \\\"tm-navigate\\\", navigateTo: defaultName\\n      });\\n      \\n    } else if(action === \\\"placeholder\\\") { \\n      this.view.addPlaceholder(tempImagePath);\\n      \\n    }\\n    \\n    // in any case\\n    $tw.wiki.deleteTiddler(\\\"$:/temp/tmap/snapshot\\\");\\n          \\n  });\\n  \\n};\\n\\nMapWidget.prototype.handleDownloadSnapshot = function(title) {\\n  \\n  var a = this.document.createElement(\\\"a\\\");\\n  var label = this.view.getLabel();\\n  a.download = title || utils.getSnapshotTitle(label, \\\"png\\\");\\n  a.href = this.getSnapshot();\\n\\n  // we cannot simply call click() on <a>; chrome is cool with it but\\n  // firefox requires us to create a mouse event…\\n  var event = new MouseEvent('click');\\n  a.dispatchEvent(event);\\n  \\n};\\n\\nMapWidget.prototype.createAndSaveSnapshot = function(title) {\\n    \\n  var label = this.view.getLabel();\\n  var tRef = title || this.view.getRoot() + \\\"/snapshot\\\";\\n  $tw.wiki.addTiddler(new $tw.Tiddler({\\n    title: tRef,\\n    type: \\\"image/png\\\",\\n    text: this.getSnapshot(true),\\n    modified: new Date()\\n  }));\\n  \\n  return tRef;\\n  \\n};\\n\\nMapWidget.prototype.getSnapshot = function(stripPreamble) {\\n  \\n  var data = this.canvas.toDataURL(\\\"image/png\\\");\\n  return (stripPreamble\\n          ? utils.getWithoutPrefix(data, \\\"data:image/png;base64,\\\")\\n          : data);\\n  \\n};\\n\\nMapWidget.prototype.handleDeleteView = function() {\\n  \\n  var viewname = this.view.getLabel();\\n  \\n  if(this.view.isLocked()) {\\n    $tm.notify(\\\"Forbidden!\\\");\\n    return;\\n  }\\n  \\n  // regex is non-greedy\\n\\n  var references = this.view.getOccurrences();\\n  if(references.length) {\\n          \\n    var fields = {\\n      count : references.length.toString(),\\n      filter : utils.joinAndWrap(references, \\\"[[\\\", \\\"]]\\\")\\n    };\\n\\n    this.dialogManager.open(\\\"cannotDeleteViewDialog\\\", fields);\\n\\n    return;\\n    \\n  }\\n\\n  var message = \\\"You are about to delete the view \\\" + \\n                \\\"''\\\" + viewname\\n                + \\\"'' (no tiddler currently references this view).\\\";\\n                \\n  this.openStandardConfirmDialog(function(isConfirmed) { // TODO: this dialog needs an update\\n    \\n    if(isConfirmed) {\\n      this.view.destroy();\\n      this.setView($tm.misc.defaultViewLabel); \\n      this.logger(\\\"debug\\\", \\\"view \\\\\\\"\\\" + viewname + \\\"\\\\\\\" deleted \\\");\\n      $tm.notify(\\\"view \\\\\\\"\\\" + viewname + \\\"\\\\\\\" deleted \\\");\\n    }\\n\\n  }, message);\\n  \\n};\\n\\n/**\\n * This will rebuild the graph after a trigger has been activated.\\n * \\n * Prior to TiddlyMap v0.9, an additional check was performed\\n * to verify, if the graph had actually changed before rebuilding\\n * the graph. This check, however, was an overkill and as such removed.\\n */\\nMapWidget.prototype.handleTriggeredRefresh = function(trigger) {\\n      \\n  this.logger(\\\"log\\\", trigger, \\\"Triggered a refresh\\\");\\n  \\n  // special case for the live tab\\n  if(this.id === \\\"live_tab\\\") {\\n    var curTiddler = utils.getTiddler(utils.getText(trigger));\\n    if(curTiddler) {\\n      var view = (curTiddler.fields[\\\"tmap.open-view\\\"]\\n                  || $tm.config.sys.liveTab.fallbackView);\\n      if(view && view !== this.view.getLabel()) {\\n        this.setView(view);\\n        return;\\n      }\\n    }\\n  }\\n\\n  this.rebuildGraph({\\n    resetFocus: {\\n      delay: 1000,\\n      duration: 1000\\n    }\\n  });\\n  \\n};\\n\\n/**\\n * Called by vis when the user tries to delete nodes or edges.\\n * The action is delegated to subhandlers.\\n * \\n * @param {Object} elements - An object containing the elements to be\\n *     removed.\\n * @param {Array<Id>} elements.nodes - Removed edges.\\n * @param {Array<Id>} elements.edges - Removed nodes.\\n */\\nMapWidget.prototype.handleRemoveElements = function(elements) {\\n          \\n  if(elements.nodes.length) {\\n    // the adapter also removes edges when nodes are removed.\\n    this.handleRemoveNodes(elements.nodes);\\n    \\n  } else if(elements.edges.length) {\\n    this.handleRemoveEdges(elements.edges);\\n    \\n  }\\n  \\n  this.resetVisManipulationBar();\\n  \\n  \\n};\\n\\nMapWidget.prototype.handleRemoveEdges = function(edgeIds) {\\n  \\n  $tm.adapter.deleteEdges(this.graphData.edges.get(edgeIds));\\n  $tm.notify(\\\"edge\\\" + (edgeIds.length > 1 ? \\\"s\\\" : \\\"\\\") + \\\" removed\\\");\\n  \\n  this.preventFitAfterRebuild = true;\\n  \\n};\\n\\n\\n/**\\n * Handler that guides the user through the process of deleting a node\\n * from the graph. The nodes may be removed from the filter (if possible)\\n * or from the system.\\n * \\n * This action represents a direct graph manipulation by the user,\\n * which means it will prevent a graph fitting (viewport adjusting)\\n * in the course of the next rebuild.\\n */\\nMapWidget.prototype.handleRemoveNodes = function(nodeIds) {\\n\\n  var tiddlers = $tm.adapter.getTiddlersById(nodeIds);\\n  var params = {\\n    \\\"count\\\": nodeIds.length.toString(),\\n    \\\"tiddlers\\\": $tw.utils.stringifyList(tiddlers),\\n    dialog: {\\n      preselects: {\\n        \\\"delete-from\\\": \\\"filter\\\"\\n      }\\n    }\\n  };\\n\\n  var name = \\\"deleteNodeDialog\\\";\\n  this.dialogManager.open(name, params, function(isConfirmed, outTObj) {\\n    \\n    if(!isConfirmed) return;\\n      \\n    if(outTObj.fields[\\\"delete-from\\\"] === \\\"system\\\") {\\n\\n      // will also delete edges\\n      $tm.adapter.deleteNodes(nodeIds);\\n      var deletionCount = nodeIds.length; // we just say so ;)\\n\\n    } else {\\n    \\n      var deletionCount = 0;\\n      for(var i = nodeIds.length; i--;) {\\n        \\n        var success = this.view.removeNode(nodeIds[i]);\\n        if(success) deletionCount++;\\n      \\n      }\\n      \\n    }\\n    \\n    this.preventFitAfterRebuild = true;\\n    \\n    $tm.notify(\\\"Removed \\\" +  deletionCount\\n                + \\\" of \\\" + nodeIds.length\\n                + \\\" from \\\" + outTObj.fields[\\\"delete-from\\\"]);\\n    \\n  });\\n    \\n};\\n\\n/**\\n * Calling this function will toggle the enlargement of the map\\n * instance. Markers need to be added at various places to ensure the\\n * map stretches properly. This includes marking ancestor dom nodes\\n * to be able to shift the stacking context.\\n * \\n * @param {string} type - either \\\"halfscreen\\\" or \\\"fullscreen\\\".\\n */\\n\\nMapWidget.prototype.toggleEnlargedMode = function(type) {\\n  \\n  if(!this.isInSidebar && type === \\\"halfscreen\\\") return;\\n  \\n  this.logger(\\\"log\\\", \\\"Toggled graph enlargement\\\");\\n          \\n  var enlargedMode = this.enlargedMode;\\n  \\n  // in any case, exit enlarged mode if active\\n  if(enlargedMode) {\\n    \\n    // reset click to use\\n    this.network.setOptions({ clickToUse: this.clickToUse });\\n    // remove markers\\n    utils.findAndRemoveClassNames([\\n      \\\"tmap-has-\\\" + enlargedMode + \\\"-widget\\\",\\n      \\\"tmap-\\\" + enlargedMode\\n    ]);\\n    // reset flag\\n    this.enlargedMode = null;\\n    document.body.scrollTop = this.scrollTop;\\n  }\\n  \\n  if(!enlargedMode\\n     || (enlargedMode !== type\\n         && (type === \\\"fullscreen\\\"\\n             || (type === \\\"halfscreen\\\" && !this.isInSidebar)))) {\\n    \\n    var doc = document.documentElement;\\n    this.scrollTop = document.body.scrollTop;\\n    \\n    this.enlargedMode = type;\\n  \\n    var pContainer = (this.isInSidebar\\n                      ? this.sidebar\\n                      : utils.getFirstElementByClassName(\\\"tc-story-river\\\"));\\n            \\n    $tw.utils.addClass(this.document.body, \\\"tmap-has-\\\" + type + \\\"-widget\\\");\\n    $tw.utils.addClass(pContainer, \\\"tmap-has-\\\" + type + \\\"-widget\\\");\\n    $tw.utils.addClass(this.domNode, \\\"tmap-\\\" + type);  \\n            \\n    // disable click to use by force\\n    this.network.setOptions({ clickToUse: false });\\n    \\n    $tm.notify(\\\"Toggled \\\" + type + \\\" mode\\\");\\n\\n  }\\n  \\n  // always do resize\\n  this.handleResizeEvent();\\n\\n};\\n   \\nMapWidget.prototype.handleGenerateWidget = function(event) {\\n  \\n  $tw.rootWidget.dispatchEvent({\\n    type: \\\"tmap:tm-generate-widget\\\",\\n    paramObject: { view: this.view.getLabel() }\\n  });\\n  \\n};\\n\\nMapWidget.prototype.handleSetCentralTopic = function(event) {\\n   \\n  var nodeId = event.paramObject.id || this.network.getSelectedNodes()[0];\\n  \\n  if(nodeId === this.view.getConfig(\\\"central-topic\\\")) {\\n    nodeId = \\\"\\\";\\n  }\\n  \\n  this.view.setCentralTopic(nodeId);\\n  \\n};\\n\\nMapWidget.prototype.handleStorePositions = function(withNotify) {\\n\\n  var data = this.view.getNodeData();\\n  var positions = this.network.getPositions();\\n  for(var id in positions) {\\n    data[id] = data[id] || {};\\n    data[id].x = positions[id].x;\\n    data[id].y = positions[id].y;\\n  }\\n  this.view.saveNodeData(data);\\n  this.ignoreNextViewModification = true;\\n      \\n  if(withNotify) {\\n    $tm.notify(\\\"positions stored\\\");\\n  }\\n  \\n};\\n\\n/**\\n * Called by vis when the graph has stabilized itself.\\n * \\n * ATTENTION: never store positions in a view's map during stabilize\\n * as this will affect other graphs positions and will cause recursion!\\n * Storing positions inside vis' nodes is fine though\\n */\\nMapWidget.prototype.handleVisStabilizedEvent = function(properties) {\\n  \\n  if(this.hasNetworkStabilized) return;\\n    \\n  this.hasNetworkStabilized = true;\\n  this.logger(\\\"log\\\", \\\"Network stabilized after\\\",\\n                      properties.iterations,\\n                      \\\"iterations\\\");\\n    \\n  if(!this.view.isEnabled(\\\"physics_mode\\\")) { // static mode\\n\\n    // store positions if new nodes without position were added\\n    var nodes = this.graphData.nodesById;\\n    var idsOfNodesWithoutPosition = [];\\n    for(var id in nodes) {\\n      if(!nodes[id].x) { idsOfNodesWithoutPosition.push(id); }\\n    }\\n    if(idsOfNodesWithoutPosition.length) {\\n      this.setNodesMoveable(idsOfNodesWithoutPosition, false);\\n      $tm.notify(idsOfNodesWithoutPosition.length\\n                  + \\\" nodes were added to the graph\\\");\\n      this.doFitAfterStabilize = true;\\n    }\\n    \\n    // after storing positions, set gravity to zero again\\n    var physics = this.visOptions.physics;\\n    physics[physics.solver].centralGravity = 0;\\n    this.network.setOptions(this.visOptions);\\n\\n  }\\n  \\n  if(this.doFitAfterStabilize) {\\n    this.doFitAfterStabilize = false;\\n    this.fitGraph(1000, 1000);\\n  }\\n      \\n};\\n\\n/**\\n * Zooms on a specific node in the graph\\n * \\n * @param {Object} event - An object containing a `param` property\\n *     that holds a tiddler reference/title.\\n */\\nMapWidget.prototype.handleFocusNode = function(event) {\\n  this.network.focus($tm.adapter.getId(event.param), {\\n    scale: 1.5,\\n    animation: true\\n  });\\n};\\n\\n/**\\n * A zombie widget is a widget that is removed from the dom tree\\n * but still referenced or still partly executed -- I mean\\n * otherwise you couldn't call this function, right?\\n * \\n * If TiddlyMap is executed in a fake environment, the function\\n * always returns true.\\n */\\nMapWidget.prototype.isZombieWidget = function() {\\n  \\n  if(this.domNode.isTiddlyWikiFakeDom === true) {\\n    return true;\\n  } else {\\n    return !this.document.body.contains(this.getContainer());\\n  }\\n  \\n};\\n\\n/**\\n * This method allows us to specify after what time and for how long\\n * the zoom-to-fit process should be executed for a graph.\\n * \\n * @param {number} [delay=0] - How long to wait before starting to zoom.\\n * @param {number} [duration=0] - After the delay, how long should it\\n *     take for the graph to be zoomed.\\n */\\nMapWidget.prototype.fitGraph = function(delay, duration) {\\n    \\n  // clear any existing fitting attempt\\n  window.clearTimeout(this.activeFitTimeout);\\n  \\n  duration = duration || 0;\\n  delay = delay || 0;\\n  \\n  var fit = function() {\\n        \\n    // happens when widget is removed after stabilize but before fit\\n    if(this.isZombieWidget()) return;\\n    \\n    // fixes #97\\n    this.network.redraw();\\n    \\n    this.network.fit({ // v4: formerly zoomExtent\\n      animation: {\\n        duration: duration,\\n        easingFunction: \\\"easeOutQuart\\\"\\n      }\\n    });\\n    \\n  };\\n  \\n  this.activeFitTimeout = window.setTimeout(fit.bind(this), delay);\\n  \\n}\\n\\n/**\\n * Spawns a dialog in which the user can specify node attributes.\\n * Once the dialog is closed, the node is inserted into the current\\n * view, unless the operation was cancelled.\\n */\\nMapWidget.prototype.handleInsertNode = function(node) {\\n  \\n  var name = \\\"addNodeToMap\\\";\\n  this.dialogManager.open(name, null, function(isConfirmed, outTObj) {\\n    if(!isConfirmed) return;\\n      \\n    var tRef = utils.getField(outTObj, \\\"draft.title\\\");\\n    \\n    if(utils.tiddlerExists(tRef)) {\\n      \\n      // Todo: use graphData and test if node is match (!=neighbour)\\n      if(utils.isMatch(tRef, this.view.getNodeFilter(\\\"compiled\\\"))) {\\n        \\n        $tm.notify(\\\"Node already exists\\\");\\n        return;\\n        \\n      } else {\\n        node = $tm.adapter.makeNode(tRef, node);\\n        this.view.addNode(node);\\n        \\n      }\\n      \\n    } else {\\n    \\n      var tObj = new $tw.Tiddler(outTObj, { \\\"draft.title\\\": null });\\n      \\n      node.label = tRef;\\n      $tm.adapter.insertNode(node, this.view, tObj);\\n    \\n    }\\n    \\n    this.preventFitAfterRebuild = true;\\n      \\n  });\\n  \\n};\\n\\n/**\\n * Open the node editor to style the node.\\n */\\nMapWidget.prototype.handleEditNode = function(node) {\\n    \\n  var tRef = $tm.indeces.tById[node.id];\\n  var tObj = utils.getTiddler(tRef);\\n  var globalDefaults = JSON.stringify($tm.config.vis);\\n  var localDefaults = this.view.getConfig(\\\"vis\\\");\\n  var nodes = {};\\n  nodes[node.id] = node;\\n  var nodeStylesByTRef = $tm.adapter.getInheritedNodeStyles(nodes);\\n  var groupStyles = JSON.stringify(nodeStylesByTRef[tRef]);\\n  var globalNodeStyle = JSON.stringify(utils.merge(\\n                          {},\\n                          { color: tObj.fields[\\\"color\\\"] },\\n                          utils.parseJSON(tObj.fields[\\\"tmap.style\\\"])));\\n  \\n  var viewLabel = this.view.getLabel();\\n  var rawNode = { id: node.id };\\n  \\n  // we do not used the cashed version since we need a new object!\\n  var nodeData = this.view.getNodeData(node.id, true) || {};\\n  // we need to delete the positions so they are not reset when a user\\n  // resets the style…\\n  delete nodeData.x;\\n  delete nodeData.y;\\n    \\n  var args = {\\n    \\\"view\\\": viewLabel,\\n    \\\"tiddler\\\": tObj.fields.title,\\n    \\\"tidColor\\\": tObj.fields[\\\"color\\\"],\\n    \\\"tidIcon\\\": tObj.fields[$tm.field.nodeIcon]\\n               || tObj.fields[\\\"tmap.fa-icon\\\"],\\n    \\\"tidLabelField\\\": \\\"global.\\\" + $tm.field.nodeLabel,\\n    \\\"tidIconField\\\": \\\"global.\\\" + $tm.field.nodeIcon,\\n    dialog: {\\n      preselects: {\\n        \\\"inherited-global-default-style\\\": globalDefaults,\\n        \\\"inherited-local-default-style\\\": localDefaults,\\n        \\\"inherited-group-styles\\\": groupStyles,\\n        \\\"global.tmap.style\\\": globalNodeStyle,\\n        \\\"local-node-style\\\": JSON.stringify(nodeData)\\n      }\\n    }\\n  };\\n  \\n  // function to iterate over attributes that shall be available\\n  // in the dialog.\\n  var addToPreselects = function(scope, store, keys) {\\n    for(var i = keys.length; i--;) {\\n      args.dialog.preselects[scope + \\\".\\\" + keys[i]] = store[keys[i]] || \\\"\\\";\\n    }\\n  };\\n  // local values are retrieved from the view's node data store\\n  addToPreselects(\\\"local\\\", nodeData, [\\n    \\\"label\\\", \\\"tw-icon\\\", \\\"fa-icon\\\", \\\"open-view\\\"\\n  ]);\\n  // global values are taken from the tiddler's field object\\n  addToPreselects(\\\"global\\\", tObj.fields, [\\n    $tm.field.nodeLabel,\\n    $tm.field.nodeIcon,\\n    \\\"tmap.fa-icon\\\",\\n    \\\"tmap.open-view\\\"\\n  ]);\\n\\n  this.dialogManager.open(\\\"editNode\\\", args, function(isConfirmed, outTObj) {\\n    \\n    if(!isConfirmed) return;\\n    \\n    var fields = outTObj.fields;\\n    \\n    // save or remove global individual style\\n    var global = utils.getPropertiesByPrefix(fields, \\\"global.\\\", true);\\n    for(var p in global) {\\n      utils.setField(tRef, p, global[p] || undefined);\\n    }\\n    \\n    // save local individual data (style + config)\\n    var local = utils.getPropertiesByPrefix(fields, \\\"local.\\\", true);\\n    // CAREFUL: Never change \\\"local-node-style\\\" to \\\"local.node-style\\\"\\n    // (with a dot) because it will get included in the loop!\\n    var data = utils.parseJSON(fields[\\\"local-node-style\\\"], {});\\n    for(var p in local) {\\n      data[p] = local[p] || undefined;\\n    } \\n    \\n    this.view.saveNodeStyle(node.id, data);\\n    \\n    this.preventFitAfterRebuild = true;\\n     \\n  });\\n\\n};\\n\\n/**\\n * This handler is registered at and called by the vis network event\\n * system.\\n */\\nMapWidget.prototype.handleVisSingleClickEvent = function(properties) {\\n  \\n  var isActivated = utils.isTrue($tm.config.sys.singleClickMode);\\n  if(isActivated && !this.editorMode) {\\n    this.handleOpenMapElementEvent(properties);\\n  }\\n  \\n};\\n  \\n/**\\n * This handler is registered at and called by the vis network event\\n * system.\\n * \\n * @see\\n *   - Coordinates not passed on click/tap events within the properties object\\n *     https://github.com/almende/vis/issues/440\\n * \\n * @properties a list of nodes and/or edges that correspond to the\\n * click event.\\n */\\nMapWidget.prototype.handleVisDoubleClickEvent = function(properties) {\\n  \\n  if(properties.nodes.length || properties.edges.length) {\\n  \\n    if(this.editorMode\\n       || !utils.isTrue($tm.config.sys.singleClickMode)) {\\n      this.handleOpenMapElementEvent(properties);\\n    }\\n\\n    \\n  } else { // = clicked on an empty spot\\n    if(this.editorMode) {\\n      this.handleInsertNode(properties.pointer.canvas);\\n    }\\n  }\\n  \\n};\\n\\nMapWidget.prototype.handleOpenMapElementEvent = function(properties) {\\n  \\n  if(properties.nodes.length) { // clicked on a node\\n    \\n    var node = this.graphData.nodesById[properties.nodes[0]];\\n    if(node[\\\"open-view\\\"]) {\\n      $tm.notify(\\\"Switching view\\\");\\n      this.setView(node[\\\"open-view\\\"]);\\n    } else {\\n      this.openTiddlerWithId(properties.nodes[0]);\\n    }\\n    \\n  } else if(properties.edges.length) { // clicked on an edge  \\n    \\n    this.logger(\\\"debug\\\", \\\"Clicked on an Edge\\\");\\n    var typeId = this.graphData.edgesById[properties.edges[0]].type;\\n    this.handleEditEdgeType(typeId);\\n    \\n  } else {\\n    \\n    return;\\n    \\n  }\\n  \\n  this.hidePopups(0, true);\\n\\n};\\n\\nMapWidget.prototype.handleEditEdgeType = function(type) {\\n  \\n  if(!this.editorMode) return;\\n  \\n  var behaviour = $tm.config.sys.edgeClickBehaviour;\\n  if(behaviour !== \\\"manager\\\") return;\\n    \\n  $tw.rootWidget.dispatchEvent({\\n    type: \\\"tmap:tm-manage-edge-types\\\",\\n    paramObject: {\\n      type: type\\n    }\\n  });\\n  \\n};\\n\\n/**\\n * Listener will be removed if the parent is not part of the dom anymore\\n * \\n * @see\\n *   - [TW5] Is there a destructor for widgets?\\n *     https://groups.google.com/d/topic/tiddlywikidev/yuQB1KwlKx8/discussion\\n *   - https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\\n */\\nMapWidget.prototype.handleResizeEvent = function(event) {\\n  \\n  if(this.isZombieWidget()) return;\\n  \\n  var height = this.getAttr(\\\"height\\\");\\n  var width = this.getAttr(\\\"width\\\");\\n  \\n  if(this.isInSidebar) {\\n    \\n    var rect = this.domNode.getBoundingClientRect();\\n    var distRight = 15;\\n    width = (document.body.clientWidth - rect.left - distRight) + \\\"px\\\";\\n    \\n    var distBottom = parseInt(this.getAttr(\\\"bottom-spacing\\\")) || 15;\\n    var calculatedHeight = window.innerHeight - rect.top;\\n    height = (calculatedHeight - distBottom) + \\\"px\\\";\\n    \\n  }\\n  \\n  this.domNode.style.height = height || \\\"300px\\\";\\n  this.domNode.style.width = width;\\n  \\n  this.repaintGraph(); // redraw graph\\n  \\n};\\n  \\n/**\\n * used to prevent nasty deletion as edges are not unselected when leaving vis\\n */\\nMapWidget.prototype.handleClickEvent = function(evt) {\\n  \\n  if(this.isZombieWidget() || !this.network) return;\\n  \\n  if(!this.graphDomNode.contains(evt.target)) { // clicked outside\\n  \\n    var selected = this.network.getSelection();\\n    if(selected.nodes.length || selected.edges.length) {\\n      this.logger(\\\"debug\\\", \\\"Clicked outside; deselecting nodes/edges\\\");\\n      // upstream bug: this.network.unselectAll() doesn't work\\n      this.network.selectNodes([]); // deselect nodes and edges\\n      this.resetVisManipulationBar();\\n    }\\n    \\n  } else {\\n    \\n    this.canvas.focus();\\n    \\n  }\\n  \\n  this.contextMenu.hide(0, true);\\n\\n};\\n\\nMapWidget.prototype.handleVisSelectNode = function(properties) {\\n  \\n  // assign selected style\\n  this.assignActiveStyle(properties.nodes);\\n  \\n};\\n\\n/**\\n * Assign some styles when the graph element becomes active, i.e.\\n * it is selected or hovered over.\\n * \\n * @param {Id|Array<Id>} nodeIds - A single id or an Array of ids.\\n */\\nMapWidget.prototype.assignActiveStyle = function(nodeIds) {\\n    \\n  if(!Array.isArray(nodeIds)) nodeIds = [ nodeIds ];\\n  \\n  var defaultColor = this.visOptions.nodes.color;\\n  \\n  // iterate over selected nodes\\n  for(var i = nodeIds.length; i--;) {\\n    var id = nodeIds[i];\\n    var node = this.graphData.nodesById[id];\\n    var colorObj = utils.merge({}, defaultColor, node.color);\\n    this.graphData.nodes.update({\\n      id: id,\\n      color: {\\n        highlight: colorObj,\\n        hover: colorObj\\n      }\\n    });\\n  };\\n  \\n};\\n\\nMapWidget.prototype.handleVisDeselectNode = function(properties) {\\n  \\n  //~ var prevSelectedNodes = properties.previousSelection.nodes;\\n  //~ for(var i = prevSelectedNodes.length; i--;) {\\n  //~ };\\n  \\n};\\n\\n/**\\n * Called by vis when the dragging of a node(s) has ended.\\n * @param {Object} properties - A vis object containing event-related\\n *     information.\\n * @param {Array<Id>} properties.nodes - Array of ids of the nodes\\n *     that were being dragged.\\n */\\nMapWidget.prototype.handleVisDragEnd = function(properties) {\\n  \\n  if(!properties.nodes.length) return;\\n            \\n  // fix node again and store positions\\n  // if in static mode, fixing will be ignored\\n  this.setNodesMoveable(properties.nodes, false);\\n      \\n};\\n\\nMapWidget.prototype.handleVisBeforeDrawing = function(context2d) {\\n  \\n  if(this.backgroundImage) {\\n    //utils.drawRaster(context2d, this.network.getScale(), this.network.getViewPosition());\\n    context2d.drawImage(this.backgroundImage, 0, 0);\\n  }\\n\\n};\\n\\n/**\\n * called by tooltip class when tooltip is displayed;\\n */\\nMapWidget.prototype.constructTooltip = function(signature, div) {\\n              \\n  var ev = utils.parseJSON(signature);\\n  var id = ev.node || ev.edge;\\n  \\n  var text = null;\\n  var outType = \\\"text/html\\\";\\n  var inType = \\\"text/vnd-tiddlywiki\\\";\\n  \\n  if(ev.node) { // node\\n    \\n    var tRef = $tm.indeces.tById[id];\\n    var tObj = utils.getTiddler(tRef);\\n    \\n    var descr = tObj.fields[$tm.field.nodeInfo];\\n    \\n    if(descr) {\\n      \\n      div.innerHTML = $tw.wiki.renderText(outType, inType, descr);\\n\\n    } else if(tObj.fields.text) {\\n      \\n      // simply rendering the text is not sufficient as this prevents\\n      // us from updating the tooltip content on refresh. So we need\\n      // to create a temporary widget that is registered to the dom\\n      // node passed by the tooltip.\\n            \\n      utils.registerTransclude(this, \\\"tooltipWidget\\\", tRef);\\n      this.tooltipWidget.setVariable(\\\"tv-tiddler-preview\\\", \\\"yes\\\");\\n      this.tooltipWidget.render(div);\\n      \\n    } else {\\n      \\n      div.innerHTML = tRef;\\n      \\n    }\\n      \\n  } else { // edge\\n    \\n    var edge = this.graphData.edgesById[id];\\n    var type = $tm.indeces.allETy[edge.type];\\n    \\n    if(type.description) {\\n      text = $tw.wiki.renderText(outType, inType, type.description);\\n    }\\n    \\n    div.innerHTML = (text || type.label || type.id);\\n    \\n  }\\n  \\n};\\n\\nMapWidget.prototype.handleVisHoverElement = function(ev) {\\n    \\n  if($tm.mouse.buttons) return;\\n  \\n  //~ this.graphDomNode.style.cursor = \\\"pointer\\\";\\n        \\n  var id = ev.node || ev.edge;\\n  var signature = JSON.stringify(ev);\\n  \\n  if(ev.node) {\\n    \\n    // override the hover color\\n    this.assignActiveStyle(id);\\n      \\n  }\\n  \\n  // show tooltip if not in edit mode\\n  if(!this.isVisInEditMode() && !this.contextMenu.isShown()) {\\n    var populator = this.constructTooltip;\\n    var signature = JSON.stringify(ev);\\n    this.tooltip.show(signature, populator);\\n  }\\n\\n};\\n\\nMapWidget.prototype.handleVisBlurElement = function(ev) {\\n  \\n  //~ console.log(\\\"vis blur fired\\\");\\n  //~ this.graphDomNode.style.cursor = \\\"auto\\\";\\n  this.tooltip.hide();\\n\\n};\\n\\nMapWidget.prototype.handleVisLoading = function(params) {\\n  \\n  // we only start to show the progress bar after a while\\n  //~ if(params.iterations / params.total < 0.05) return;\\n  \\n  this.graphLoadingBarDomNode.style.display = \\\"block\\\";\\n  this.graphLoadingBarDomNode.setAttribute(\\\"max\\\", params.total);\\n  this.graphLoadingBarDomNode.setAttribute(\\\"value\\\", params.iterations);\\n  \\n  //~ var text = \\\"Loading \\\" + Math.round((params.iterations / params.total) * 100) + \\\"%\\\";\\n  //~ this.graphLoadingBarDomNode.innerHTML = text;\\n\\n};\\n\\nMapWidget.prototype.handleVisLoadingDone = function(params) {\\n  \\n  this.graphLoadingBarDomNode.style.display = \\\"none\\\";\\n  \\n};\\n\\n/**\\n * Called by vis when a node is being dragged.\\n * @param {Object} properties - A vis object containing event-related\\n *     information.\\n * @param {Array<Id>} properties.nodes - Array of ids of the nodes\\n *     that are being dragged.\\n */\\nMapWidget.prototype.handleVisDragStart = function(properties) {\\n\\n  if(properties.nodes.length) {\\n    this.hidePopups(0, true);\\n    this.assignActiveStyle(properties.nodes);\\n    this.setNodesMoveable(properties.nodes, true);\\n  }\\n  \\n};\\n \\n/**\\n * called from outside.\\n */\\nMapWidget.prototype.destruct = function() {\\n      \\n  // while the container should be destroyed and the listeners\\n  // garbage collected, we remove them manually just to be save  \\n  \\n  utils.setDomListeners(\\\"remove\\\", window, this.windowDomListeners);\\n  utils.setDomListeners(\\\"remove\\\", this.domNode, this.widgetDomListeners);\\n\\n  this._destructVis();\\n};\\n\\n/**\\n * Only destructs stuff related to vis.\\n */\\nMapWidget.prototype._destructVis = function() {\\n    \\n  if(!this.network) return;\\n  \\n  utils.setDomListeners(\\\"remove\\\", this.canvas, this.canvasDomListeners); \\n  \\n  this.network.destroy();\\n  this.network = null;\\n\\n};\\n\\n/**\\n * Opens the tiddler that corresponds to the given id either as\\n * modal (when in fullscreen mode) or in the story river.\\n */\\nMapWidget.prototype.openTiddlerWithId = function(id) {\\n  \\n  var tRef = $tm.indeces.tById[id];\\n  \\n  this.logger(\\\"debug\\\", \\\"Opening tiddler\\\", tRef, \\\"with id\\\", id);\\n  \\n  if(this.enlargedMode === \\\"fullscreen\\\") {\\n    \\n    var draftTRef = this.wiki.findDraft(tRef);\\n    var wasInDraftAlready = !!draftTRef;\\n        \\n    if(!wasInDraftAlready) {\\n      \\n      var type = \\\"tm-edit-tiddler\\\";\\n      this.dispatchEvent({ type: type, tiddlerTitle: tRef });\\n      draftTRef = this.wiki.findDraft(tRef);\\n      \\n    }\\n    \\n    var args = {\\n      draftTRef: draftTRef,\\n      originalTRef: tRef\\n    };\\n\\n    var name = \\\"fullscreenTiddlerEditor\\\";\\n    this.dialogManager.open(name, args, function(isConfirmed, outTObj) {\\n    \\n      if(isConfirmed) {\\n        \\n        var type = \\\"tm-save-tiddler\\\";\\n        this.dispatchEvent({ type: type, tiddlerTitle: draftTRef }); \\n        \\n      } else if(!wasInDraftAlready) {\\n\\n        // also removes the draft from the river before deletion!\\n        utils.deleteTiddlers([ draftTRef ]);\\n        \\n      }\\n      \\n      // in any case, remove the original tiddler from the river\\n      var type = \\\"tm-close-tiddler\\\";\\n      this.dispatchEvent({ type: type, tiddlerTitle: tRef }); \\n      \\n    });\\n    \\n  } else {\\n    \\n    var bounds = this.domNode.getBoundingClientRect();\\n    \\n    this.dispatchEvent({\\n      type: \\\"tm-navigate\\\",\\n      navigateTo: tRef,\\n      navigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n      navigateFromNode: this,\\n      navigateFromClientRect: {\\n        top: bounds.top,\\n        left: bounds.left,\\n        width: bounds.width,\\n        right: bounds.right,\\n        bottom: bounds.bottom,\\n        height: bounds.height\\n      }\\n    }); \\n    \\n  }\\n};\\n \\n/**\\n * The view holder is a tiddler that stores a references to the current\\n * view. If the graph is not bound to a view by the user via an\\n * attribute, the default view holder is used. Otherwise, a temporary\\n * holder is created whose value is set to the view specified by the user.\\n * This way, the graph is independent from view changes made in a\\n * tiddlymap editor.\\n * \\n * This function will only calculate a new reference to the holder\\n * on first call (that is when no view holder is registered to \\\"this\\\".\\n * \\n */\\nMapWidget.prototype.getViewHolderRef = function() {\\n  \\n  // the viewholder is never recalculated once it exists\\n  if(this.viewHolderRef) {\\n    return this.viewHolderRef;\\n  }\\n  \\n  this.logger(\\\"info\\\", \\\"Retrieving or generating the view holder reference\\\");\\n  \\n  // if given, try to retrieve the viewHolderRef by specified attribute\\n  var viewName = this.getAttr(\\\"view\\\");\\n  if(viewName) {\\n    \\n    this.logger(\\\"log\\\", \\\"User wants to bind view \\\\\\\"\\\" + viewName + \\\"\\\\\\\" to graph\\\");\\n          \\n    var viewRef = $tm.path.views + \\\"/\\\" + viewName;\\n    if(this.wiki.getTiddler(viewRef)) {\\n      \\n      // create a view holder that is exclusive for this graph\\n      \\n      var holderRef = $tm.path.localHolders + \\\"/\\\" + utils.genUUID();\\n      this.logger(\\\"log\\\", \\\"Created an independent temporary view holder \\\\\\\"\\\" + holderRef + \\\"\\\\\\\"\\\");\\n      \\n      // we do not use setView here because it would store and reload the view unnecessarily...\\n      utils.setText(holderRef, viewRef);\\n      \\n      this.logger(\\\"log\\\", \\\"View \\\\\\\"\\\" + viewRef + \\\"\\\\\\\" inserted into independend holder\\\");\\n      \\n    } else {\\n      this.logger(\\\"log\\\", \\\"View \\\\\\\"\\\" + viewName + \\\"\\\\\\\" does not exist\\\");\\n    }\\n    \\n  }\\n  \\n  if(typeof holderRef === \\\"undefined\\\") {\\n    this.logger(\\\"log\\\", \\\"Using default (global) view holder\\\");\\n    var holderRef =  $tm.ref.defaultViewHolder;\\n  }\\n  \\n  return holderRef;\\n  \\n};\\n\\n/**\\n * This function will switch the current view reference of the\\n * view holder.\\n * \\n * NOTE:\\n * The changes will be picked up in the next refresh cycle.\\n * This function will never update the view object currently\\n * held by this widget (this.view)! This would create a race\\n * condition where the view has changed, but the graph data hasn't\\n * and maybe a stabilization event fires in this moment. At this point\\n * it would work with graph data that doesn't relate to the view\\n * and do bad things, trust me, big time bad things.\\n * \\n * @param {ViewAbstraction|string} view – A reference to the view.\\n * @param {string} [viewHolderRef] – A reference to the view holder.\\n */\\nMapWidget.prototype.setView = function(view, viewHolderRef) {\\n  \\n  view = new ViewAbstraction(view);\\n  \\n  if(!view.exists()) return;\\n    \\n  var viewLabel = view.getLabel();\\n  viewHolderRef = viewHolderRef || this.viewHolderRef;\\n  this.logger(\\\"info\\\", \\\"Inserting view '\\\"\\n                      + viewLabel\\n                      + \\\"' into holder '\\\"\\n                      + viewHolderRef\\n                      + \\\"'\\\");\\n  this.wiki.addTiddler(new $tw.Tiddler({ \\n    title : viewHolderRef,\\n    text : viewLabel\\n  }));\\n  \\n  // WARNING: Never set this.view to the new view state at this point.\\n  // e.g. via `this.view = this.getView(true)` This would produce a\\n  // race condition!\\n  \\n};\\n\\n/**\\n * This function will return a view abstraction that is based on the\\n * view specified in the view holder of this graph.\\n * \\n * @param {boolean} noCache - Retrieve the view reference again\\n *     from the holder and recreate the view abstraction object.\\n * @return {ViewAbstraction} the view\\n */\\nMapWidget.prototype.getView = function(noCache) {\\n  \\n  if(!noCache && this.view) {\\n    return this.view;\\n  }\\n  \\n  var viewHolderRef = this.getViewHolderRef();\\n                     \\n  // transform into view object\\n  var text = utils.getText(viewHolderRef);\\n  var view = new ViewAbstraction(text);\\n    \\n  this.logger(\\\"debug\\\", \\\"Retrieved view from holder\\\");\\n  \\n  if(!view.exists()) {\\n    this.logger(\\\"debug\\\", \\\"Warning: View \\\\\\\"\\\" + text\\n                + \\\"\\\\\\\" doesn't exist. Default is used instead.\\\");\\n    view = new ViewAbstraction(\\\"Default\\\");\\n  }\\n    \\n  return view;\\n  \\n};\\n\\nMapWidget.prototype.reloadBackgroundImage = function(msg) {\\n\\n  this.backgroundImage = null;\\n  \\n  var bgFieldValue = this.view.getConfig(\\\"background_image\\\");\\n  var imgTObj = utils.getTiddler(bgFieldValue);\\n  if(!imgTObj && !bgFieldValue) return;\\n  \\n  var img = new Image();\\n  var ajaxCallback = function(b64) { img.src = b64; };\\n  img.onload = function() {\\n    // only now set the backgroundImage to the img object!\\n    this.backgroundImage = img;\\n    this.repaintGraph();\\n    if(msg) { $tm.notify(msg); }\\n  }.bind(this);\\n  \\n  if(imgTObj) { // try loading from tiddler\\n    var urlField = imgTObj.fields[\\\"_canonical_uri\\\"];\\n    if(urlField) { // try loading by uri field\\n      utils.getImgFromWeb(urlField, ajaxCallback);\\n    } else if(imgTObj.fields.text) { // try loading from base64\\n       var b64 = $tw.utils.makeDataUri(imgTObj.fields.text,\\n                                       imgTObj.fields.type);\\n       img.src = b64;\\n    }\\n    \\n  } else if(bgFieldValue) { // try loading directly from reference\\n    utils.getImgFromWeb(bgFieldValue, ajaxCallback);\\n    \\n  }\\n  \\n};\\n\\n/**\\n * using an existing dataset to reflect the changes between\\n * two node sets.\\n * \\n * @param {Hashmap<id, Node>} lt1 - Lookup table that contains the\\n *     *new* set of nodes.\\n * @param {Hashmap<id, Node>} lt2 - lookup table that holds the\\n *     *old* set of nodes.\\n * @param {vis.DataSet} [ds] - The dataset to be updated\\n */\\nMapWidget.prototype.getRefreshedDataSet = function(ltNew, ltOld, ds) {\\n  \\n  if(!ds) {\\n    return new vis.DataSet(utils.getValues(ltNew));\\n  }\\n\\n  // remove all elements;\\n  // formerly I kept all elements that were included in the new set in\\n  // the dataset. I would then set properties to null that are\\n  // not present anymore to prevent property relicts. This turned out\\n  // to be cumbersome and didn't really work with vis, especially\\n  // setting nested properties to null. therefore I decided to simply\\n  // remove all previous elements – surprisingly you don't see any\\n  // performance decrease…\\n  if(ltOld) ds.remove(Object.keys(ltOld));\\n        \\n  // inject the new data\\n  ds.update(utils.getValues(ltNew));\\n  \\n  return ds;\\n  \\n};\\n\\n/**\\n * The graph of this widget is only repainted if the following counts:\\n * \\n * The network object exists (prerequisit).\\n * \\n * 1. We are not in fullscreen at all\\n * 2. This particular graph instance is currently running fullscreen.\\n */\\nMapWidget.prototype.repaintGraph = function() {\\n  \\n  var isInFS = $tw.utils.hasClass(this.document.body,\\n                                  \\\"tmap-has-fullscreen-widget\\\");\\n  if(this.network && (!isInFS || (isInFS && this.enlargedMode))) {\\n  \\n    this.logger(\\\"info\\\", \\\"Repainting the whole graph\\\");\\n  \\n    this.network.redraw();\\n    this.fitGraph(0, 1000);\\n    \\n  }\\n  \\n};\\n  \\n/**\\n * If a button is enabled it means it is displayed on the graph canvas.\\n * \\n * @param {string} name - The name of the button to enabled. Has to\\n *     correspond with the css button name.\\n * @param {boolean} enable - True if the button should be visible,\\n *     false otherwise.\\n */ \\nMapWidget.prototype.setGraphButtonEnabled = function(name, enable) {\\n  \\n  var className = \\\"vis-button\\\" + \\\" \\\" + \\\"tmap-\\\" + name;\\n  var b = utils.getFirstElementByClassName(className, this.domNode);\\n  $tw.utils.toggleClass(b, \\\"tmap-button-enabled\\\", enable);\\n  \\n}; \\n\\nMapWidget.prototype.dialogPostProcessor = function() {\\n    \\n  this.network.selectNodes([]);\\n  this.resetVisManipulationBar();\\n\\n}; \\n\\n/**\\n * Allow the given nodes to be moveable.\\n * \\n * @param {Array<NodeId>} nodeIds - The ids of the nodes for which\\n *     we allow or disallow the movement.\\n * @param {boolean} isMoveable - True, if the nodes are allowed to\\n *     move or be moved.\\n */    \\nMapWidget.prototype.setNodesMoveable = function(nodeIds, isMoveable) {\\n\\n  if(!nodeIds || !nodeIds.length || this.view.isEnabled(\\\"physics_mode\\\")) {\\n  // = no ids passed or in floating mode\\n    return;\\n  }\\n  \\n  //~ this.network.storePositions();\\n  \\n  var updates = [];\\n  var isFixed = !isMoveable;\\n  for(var i = nodeIds.length; i--;) {\\n        \\n    updates.push({\\n      id: nodeIds[i],\\n      fixed: { x: isFixed, y: isFixed }\\n    });\\n    \\n  }\\n    \\n  this.graphData.nodes.update(updates);\\n  \\n  if(isFixed) {\\n    \\n    this.logger(\\\"debug\\\", \\\"Fixing\\\", updates.length, \\\"nodes\\\");\\n    \\n    // if we fix nodes in static mode then we also store the positions\\n    this.handleStorePositions();\\n  }\\n\\n};\\n\\n/**\\n * This function will create the dom elements for all tiddlymap-vis\\n * buttons and register the event listeners.\\n * \\n * @param {Object<string, function>} buttonEvents - The label of the\\n *     button that is used as css class and the click handler.\\n */\\nMapWidget.prototype.addGraphButtons = function(buttonEvents) {\\n  \\n  var parent = utils.getFirstElementByClassName(\\\"vis-navigation\\\", this.domNode);\\n  \\n  for(var name in buttonEvents) {\\n    var div = this.document.createElement(\\\"div\\\");\\n    div.className = \\\"vis-button \\\" + \\\" \\\" + \\\"tmap-\\\" + name;\\n    div.addEventListener(\\\"click\\\", buttonEvents[name].bind(this), false);\\n    parent.appendChild(div);\\n    \\n    this.setGraphButtonEnabled(name, true);\\n    \\n  }\\n  \\n};\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/license\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/license\",\n            \"subtitle\": \"License\",\n            \"caption\": \"License\",\n            \"text\": \"\\\\rules except wikilink\\n\\n!! TiddlyMap\\n\\nCopyright (c) 2014, Felix Küppers\\nAll rights reserved.\\n\\nTiddlyMap is licensed under the [[BSD 2-Clause License|http://opensource.org/licenses/BSD-2-Clause]]. For the exact license terms, please visit [[https://github.com/felixhayashi/TW5-TiddlyMap/blob/master/LICENSE]]. \\n\\n!! TiddlyWiki\\n\\nCreated by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\\n\\nCopyright © Jeremy Ruston 2004-2007 Copyright © UnaMesa Association 2007-2014\\n\\nPublished under the following [licenses](https://github.com/Jermolene/TiddlyWiki5/tree/master/licenses):\\n\\n# BSD 3-clause \\\"New\\\" or \\\"Revised\\\" License (including any right to adopt any future version of a license if permitted)\\n# Creative Commons Attribution 3.0 (including any right to adopt any future version of a license if permitted)\\n\\n!! Vis.js\\n\\nCopyright (c) 2014 [Almende B.V.](https://github.com/almende/vis)\\n\\nPublished under the following licenses:\\n\\n# Apache License Version 2.0, January 2004 http://www.apache.org/licenses/\\n# MIT License (MIT)\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/readme\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/readme\",\n            \"text\": \"* Please refer to the project-readme hosted at [[https://github.com/felixhayashi/TW5-TiddlyMap]].\\n* A demo with several examples and explanations can be found at [[http://tiddlymap.org]].\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tmap:unknown\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tmap:unknown\",\n            \"description\": \"Automatically assigned to an edge that does not have a type assigned\",\n            \"style\": \"{\\\"color\\\":\\\"gray\\\"}\",\n            \"show-label\": \"false\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-body:link\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-body:link\",\n            \"description\": \"A link that is contained in the tiddler's body pointing to another resource.\",\n            \"style\": \"{\\\"color\\\":\\\"orange\\\", \\\"dashes\\\":true}\",\n            \"label\": \"links to\",\n            \"text\": \"\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:list\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:list\",\n            \"description\": \"Contained in a list of this tiddler\",\n            \"style\": \"{ \\\"color\\\": \\\"red\\\", \\\"dashes\\\":true}\",\n            \"label\": \"listed in\",\n            \"text\": \"\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:tags\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:tags\",\n            \"description\": \"A tag that refers to a tiddler of the same name.\",\n            \"style\": \"{ \\\"color\\\": \\\"DarkSlateGray\\\", \\\"dashes\\\":true}\",\n            \"label\": \"tagged with\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/default\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/default\",\n            \"caption\": \"Overview\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-plain\\\">\\n  Please visit the [[online docs|http://tiddlymap.org/Documentation]]\\n  for more information about the available global options.\\n</div>\\n<table class=\\\"tmap-key-value-table\\\">\\n  <tr>\\n    <th align=\\\"left\\\">Plugin version</th>\\n    <td><<pluginVersion>></td>\\n  </tr>\\n<!--\\n  <tr>\\n    <th align=\\\"left\\\">Datastructure version</th>\\n    <td><<dataStructureVersion>></td>\\n  </tr>\\n-->\\n  <tr>\\n    <th align=\\\"left\\\">Nodes in system</th>\\n    <td><<numberOfNodes>></td>\\n  </tr>\\n  <tr>\\n    <th align=\\\"left\\\">Edges in system</th>\\n    <td><<numberOfEdges>></td>\\n  </tr>\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/editor\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/editor\",\n            \"caption\": \"Editor\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Show Neighbour&shy;hood button\\\"\\n      field:\\\"config.sys.editorMenuBar.showNeighScopeButton\\\" \\n      descr:\\\"Show or hide the neighbourhood scope button from the menu.\\\">>\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Show Screen&shy;shot button\\\"\\n      field:\\\"config.sys.editorMenuBar.showScreenshotButton\\\" \\n      descr:\\\"Show or hide the screenshot button.\\\">>\\n</table>   \\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/fields\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/fields\",\n            \"caption\": \"Field settings\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Node-icon field\\\"\\n      field:\\\"config.sys.field.nodeIcon\\\" \\n      descr:\\\"Local image used as node image in the graphs.\\\">>\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Node-label field\\\"\\n      field:\\\"config.sys.field.nodeLabel\\\" \\n      descr:\\\"Alternative node label to use instead of the title.\\\">>\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Node-info field\\\"\\n      field:\\\"config.sys.field.nodeInfo\\\" \\n      descr:\\\"Field used as tooltip when hovering over a node in a graph.\\\"\\n      note:\\\"It is prohibited to use the text field here.\\\">>\\n</table>   \\n\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/interaction\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/interaction\",\n            \"caption\": \"Interaction & behaviour\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table\\\">\\n<!--\\n  <<tmap-row type:\\\"input-select\\\"\\n      title:\\\"Default node tooltip\\\"\\n      field:\\\"config.sys.defaultNodeTooltip\\\" \\n      descr:\\\"What to show when hovering over a node.\\\"\\n      nochoice:\\\"No\\\"\\n      selectFilter:\\\"[[nothing|Nothing]]\\n                    [[manager|Open edge-type manager]]\\\">>\\n-->\\n  <$macrocall type=\\\"input-select\\\"\\n        $name=\\\"tmap-row\\\"\\n        title=\\\"Default startup view\\\"\\n        field=\\\"config.sys.defaultView\\\"\\n        nochoice=\\\"Last view used at startup\\\"\\n        selectFilter=<<tmap \\\"option\\\" \\\"selector.allViewsByLabel\\\">>\\n        descr=\\\"The view to display at startup\\\" />\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Show popups\\\"\\n      field:\\\"config.sys.popups.enabled\\\" \\n      descr:\\\"Set this to true if you want to see automatic\\n             popups in the map.\\\">>\\n  <$list filter=\\\"[config.sys.popups.enabled[true]]\\\">\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Popup delay\\\"\\n      field:\\\"config.sys.popups.delay\\\"\\n      descr:\\\"The time in miliseconds that needs to pass after\\n             a tooltip is triggered.\\\">>\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Popup width\\\"\\n      field:\\\"config.sys.popups.width\\\"\\n      descr:\\\"The default max-width of the popup.\\\"\\n      note:\\\"Make sure you added the desired unit (e.g. `px`).\\n            Requires a wiki refresh.\\\">>\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Popup height\\\"\\n      field:\\\"config.sys.popups.height\\\"\\n      descr:\\\"The default max-height of the popup.\\\"\\n      note:\\\"Make sure you added desired the unit (e.g.  `px`).\\n            Requires a wiki refresh.\\\">>\\n  </$list>\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Allow single click mode\\\"\\n      field:\\\"config.sys.singleClickMode\\\" \\n      descr:\\\"A single click on a node is sufficient to open the\\n             corresponding tiddler.\\\"\\n      note:\\\"Drag and drop will still work and does not cause a\\n            tiddler to be opened. Single click is never active in\\n            the map editor.\\\">>\\n  <<tmap-row type:\\\"input-select\\\"\\n      title:\\\"Edge click behaviour\\\"\\n      field:\\\"config.sys.edgeClickBehaviour\\\" \\n      selectFilter:\\\"[[nothing|Nothing]]\\n                    [[manager|Open edge-type manager]]\\\"\\n      descr:\\\"What should happen when you click on an edge?\\\">>\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/liveTab\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/liveTab\",\n            \"caption\": \"Live tab\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Show Live tab\\\"\\n      field:\\\"liveTab\\\" \\n      descr:\\\"Show or hide the live tab in the sidebar.\\\">>\\n  <$macrocall type=\\\"input-select\\\"\\n      $name=\\\"tmap-row\\\"\\n      title=\\\"Fallback view\\\"\\n      field=\\\"config.sys.liveTab.fallbackView\\\" \\n      selectFilter=<<tmap \\\"option\\\" \\\"selector.allViewsByLabel\\\">>\\n      descr=\\\"The view to display in the sidebar's live tab in\\n             case the current tiddler did not specify a view\\n             to open.\\\" />\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig\",\n            \"subtitle\": \"{{$:/core/images/options-button}} Global configuration of TiddlyMap\",\n            \"classes\": \"tmap-remove-top-space\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$macrocall $name=\\\"tabs\\\"\\n  default=<<concat \\\"$(template)$/default\\\">>\\n  tabsList=\\\"[all[shadows]prefix<template>] -[<template>]\\\"\\n/>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/verbosity\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/verbosity\",\n            \"caption\": \"Verbosity\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-plain\\\">\\n  Here you can restrict the system's talkativeness.\\n</div>\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Debug output\\\"\\n      field:\\\"config.sys.debug\\\" \\n      descr:\\\"Set this to true if you want debug information to be\\n             displayed in the browser console.\\\">>\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Show notifications\\\"\\n      field:\\\"config.sys.notifications\\\" \\n      descr:\\\"Set this to true if you want to receive fade-out\\n             notifications for important events.\\\">>\\n</table> \"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/vis\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/vis\",\n            \"classes\": \"tmap-remove-top-space\",\n            \"caption\": \"Graph\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  The global vis configurations will affect all views and their\\n  elements (nodes and edges) unless they are overridden on a lower\\n  level. All options below are documented at\\n  [[vis.js.org|http://visjs.org/docs/network]].\\n</div>\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  Only config items that you actually changed have an effect on\\n  the graph. Other options are visible, yet, inactive.\\n</div>\\n<$tmap-config\\n    mode=\\\"manage-config\\\"\\n    inherited=\\\"vis-inherited\\\"\\n    extension=\\\"config.vis\\\" />\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/default\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/default\",\n            \"caption\": \"Overview\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n   All configurations __only__ affect this view.\\n</div>\\n\\n<table class=\\\"tmap-key-value-table\\\">\\n  <tr>\\n    <th align=\\\"left\\\">Created on</th>\\n    <td><<createdOn>></td>\\n  </tr>\\n  <tr>\\n    <th align=\\\"left\\\">Nodes contained in graph</th>\\n    <td><<numberOfNodes>></td>\\n  </tr>\\n  <tr>\\n    <th align=\\\"left\\\">Edges contained in graph</th>\\n    <td><<numberOfEdges>></td>\\n  </tr>\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/editFilters\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/editFilters\",\n            \"caption\": \"Edit filters\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  Completely new to filters? Please read\\n  [[Introduction to filter notation|http://tiddlywiki.com/#Introduction%20to%20filter%20notation]]\\n  first.\\n</div>\\n\\n<fieldset>\\n  <legend>Filters <sup>[1]</sup></legend>\\n  <table class=\\\"tmap-config-table tmap-large-input\\\">\\n    <<tmap-row type:\\\"input-textarea\\\"\\n        title:\\\"Node filter\\\"\\n        field:\\\"filter.prettyNodeFltr\\\"\\n        descr:\\\"In the map, only those tiddlers that match this filter\\n               are shown. Drafts and system tiddlers are automatically\\n               excluded.\\\">>\\n    <<tmap-row type:\\\"input-textarea\\\"\\n        title:\\\"Edge-type filter\\\"\\n        field:\\\"filter.prettyEdgeFltr\\\" \\n        descr:\\\"Only edges with a type that matches the filter are shown.\\\">>\\n  </table>   \\n</fieldset>\\n\\n---\\n\\n<sup>[1]</sup> In the editors above, a new line is equivalent to a space symbol.<br />\\n<sup>[2]</sup> It is suggested to read\\n[[Node and edge-type filters|http://tiddlymap.org#Node%20and%20edge-type%20filters]]\\nand [[Edge-type namespaces|http://tiddlymap.org#Node%20and%20edge-type%20filters]]\\nbefore using Tiddlymap's filter editor.\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/layout\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/layout\",\n            \"caption\": \"Layout\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Floating nodes\\\"\\n      field:\\\"config.physics_mode\\\" \\n      descr:\\\"Set this to true if you want your nodes to freely\\n             swirl around.\\\">>\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Background image\\\"\\n      field:\\\"config.background_image\\\" \\n      descr:\\\"The title of an image tiddler to be used as background\\n             in the view.\\\"\\n      note:\\\"You can also use an image url directly, however, the\\n            image needs be stored under the same domain as your wiki.\\n            Otherwise, it won't be displayed!\\\">>\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/namespace\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/namespace\",\n            \"caption\": \"Namespace\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table tmap-small-input\\\">\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Edge-type namespace\\\"\\n      field:\\\"config.edge_type_namespace\\\" \\n      descr:\\\"A namespace (like `foaf` in `foaf:knows`) that will be\\n             automatically added to all edge types you create in\\n             this view. The namespace is only added if the types\\n             do not exist yet and do not have a namespace assigned yet.\\n             Namespaces are always hidden in the graph.\\\"\\n      note:\\\"Most likely, you don't want the edges created with this\\n            namespace to leak into other views, moreover, you don't\\n            want edges that do not possess the namespace ever to be\\n            shown here. In this case, use a private marker (`_`)\\n            in front of your namespace, e.g. `_mynamespace` and use\\n            an appropriate edge type filter, i.e. `+[prefix[_mynamespace]]`\\n            For further information see:\\n            \\n            * [[Edge-type namespaces|http://tiddlymap.org/#Edge-type%20namespaces]]\\n            * [[Private edge types|http://tiddlymap.org/#Private%20edge%20types]]\\n            \\\">>\\n</table>\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView\",\n            \"subtitle\": \"{{$:/core/images/options-button}} View configuration -- <<view>>\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define privateEdgeTypes() [[private edge-types|http://tiddlymap.org/#Private%20edge%20types]]\\n\\n<$macrocall $name=\\\"tabs\\\"\\n  default=<<concat \\\"$(template)$/default\\\">>\\n  tabsList=\\\"[all[shadows]prefix<template>] -[<template>]\\\"\\n/>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/vis\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/configureView/vis\",\n            \"caption\": \"Graph\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n   The local vis configurations will affect all\\n   elements (nodes and edges) of this view, unless they are\\n   overridden on a lower level. All options below are documented at\\n   [[vis.js.org|http://visjs.org/docs/network]].\\n</div>\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  Only config items that you actually changed have an effect on the\\n  graph. Other options are visible, yet, inactive.\\n</div>\\n<$tmap-config\\n    mode=\\\"manage-config\\\"\\n    inherited=\\\"vis-inherited\\\"\\n    extension=\\\"config.vis\\\" />\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/cannotDeleteViewDialog\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/cannotDeleteViewDialog\",\n            \"subtitle\": \"{{$:/core/images/locked-padlock}} You cannot delete this view!\",\n            \"buttons\": \"ok\",\n            \"text\": \"\\\\rules except wikilink\\n\\nIt is not possible to delete the current view as ''<<count>>'' tiddlers\\nare referencing it. To delete the view you must first remove the tiddlymap\\nwidgets in the tiddlers listed below or change their view attributes.\\n\\n''References''\\n\\n<ul>\\n<$list filter=<<filter>> variable=\\\"item\\\">\\n  <li><$link><<item>></$link></li>\\n</$list>\\n</ul>\\n\\nAfter the references are removed, you may delete the view.\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/getConfirmation\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/getConfirmation\",\n            \"subtitle\": \"{{$:/core/images/import-button}} You must confirm in order to proceed!\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<<message>>\\n\\n''Are you really sure you want to do this?''\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/createView\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/createView\",\n            \"subtitle\": \"{{$:/core/images/new-button}} Creating a new view\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"View name\\\"\\n      field:\\\"name\\\" \\n      descr:\\\"The name for the new view. If no name is entered,\\n             the program will invent one for you.\\\"\\n      note:\\\"You cannot override an existing view. In this case,\\n            you need to delete the old view first! You must no use\\n            slashes (`/`) in the name.\\\">>\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Clone view\\\"\\n      field:\\\"clone\\\" \\n      descr:\\\"Use the view that is currently displayed in the\\n             editor as blueprint. The view will be an __exact__\\n             clone of the current one, only with a different \\n             name.\\\">>\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/deleteNodeDialog\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/deleteNodeDialog\",\n            \"subtitle\": \"{{$:/core/images/delete-button}} You are about to delete <<count>> nodes\",\n            \"text\": \"\\\\rules except wikilink\\n\\n''Please choose an option or abort:''\\n\\n<$radio tiddler=<<output>> field=\\\"delete-from\\\" value=\\\"system\\\">\\n  Delete nodes from system <sup>[1]</sup>\\n</$radio><br />\\n<$radio tiddler=<<output>> field=\\\"delete-from\\\" value=\\\"filter\\\">\\n  Delete nodes from graph's filter <sup>[2]</sup>\\n</$radio>\\n\\nThe following nodes will be deleted:\\n\\n<ul>\\n<$list filter=<<tiddlers>>>\\n  <li><$view tiddler={{!!title}} field=\\\"title\\\" /></li>\\n</$list>\\n</ul>\\n\\n---\\n\\n<sup>[1]</sup>\\n<small>This will delete all nodes, their corresponding tiddlers and all connected edges.</small><br/>\\n<sup>[2]</sup>\\n<small>''Important:'' Removing a node from the graph's filter only works, if the node has been added in the map editor per double click or via \\\"Add Node\\\". If the node hasn't been added as mentioned above, you need to change the underlying tiddler in a way that it doesn't match your filter anymore, if you don't want it to be displayed in the graph.</small>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/dublicateIdInfo\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/dublicateIdInfo\",\n            \"subtitle\": \"{{$:/core/images/info-button}} Dublicate id detected\",\n            \"buttons\": \"ok_suppress\",\n            \"text\": \"\\\\rules except wikilink\\n\\nTiddlyMap requires the value of the id field (\\\"tmap.id\\\") to be\\nunique in order to correctly identify nodes and tiddlers.\\n\\nThe tiddler \\\"<<param.changedTiddler>>\\\" had the same id as the\\ntiddler \\\"<<param.existingTiddler>>\\\".\\n\\nTherefore TiddlyMap\\n\\n* assigned a new id to tiddler \\\"<<param.changedTiddler>>\\\"\\n* removed all edges from \\\"<<param.changedTiddler>>\\\"\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/edgeNotVisible\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/edgeNotVisible\",\n            \"subtitle\": \"{{$:/core/images/info-button}} Edge will not be visible in view \\\"<<view>>\\\"\",\n            \"buttons\": \"ok_suppress\",\n            \"text\": \"\\\\rules except wikilink\\n\\nYou just created an edge of type\\n<code><$text text=<<type>> /></code> that will not be\\nvisible in this view because it doesn't match your\\nedge-type filter settings.\\n\\nThe current edge-type filter of view \\\"<<view>>\\\" looks like this:\\n\\n<pre><code><$text text=<<eTyFilter>> /></code></pre>\\n\\nTo have the newly added type displayed in your view, adjust your\\nedge-type filter accordingly. \\n\\nSome suggestions:\\n\\n<ul>\\n  <li>\\n    Explicitly add the type to the filter:\\n    <code><$text text=\\\"[[\\\" /><$text text=<<type>> /><$text text=\\\"]]\\\" /></code>\\n  </li>\\n  <li>\\n  <$set\\n      filter=\\\"[<type>regexp[:]splitbefore[:]]\\\"\\n      name=\\\"prefix\\\"\\n      emptyValue=<<tmap halfOfString \\\"$(type)$\\\">>>\\n  Add a filter rule (e.g. a prefix filter) that will match\\n  your type: <code>[prefix[<<prefix>>]]</code>\\n  </$set>\\n  </li>\\n  <li>Make your current view-filter less restrictive.</li>\\n</ul>\\n\\nFor further information, please see:\\n[[Node and edge-type filters|http://tiddlymap.org#Node%20and%20edge-type%20filters]].\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/editNode/default\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/editNode/default\",\n            \"caption\": \"Global node style\",\n            \"classes\": \"tmap-remove-top-space\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  A node's ''global configuration''\\n  (also referred to as //global individual config//) defines its\\n  individual appearance and behaviour in all views.\\n</div>\\n<<maybeShowTidColorWarning>>\\n    \\n<$macrocall $name=\\\"sharedSettings\\\"\\n    twIconField=<<tidIconField>>\\n    faIconField=\\\"global.tmap.fa-icon\\\"\\n    labelField=<<tidLabelField>> />\\n\\n<$macrocall $name=\\\"visConfiguration\\\"\\n    mode=\\\"manage-node-types\\\"\\n    extensionField=\\\"global.tmap.style\\\"\\n    styleName=\\\"node's global style\\\"\\n    inheritedList=\\\"[[inherited-global-default-style]]\\n                   [[inherited-local-default-style]]\\n                   [[inherited-group-styles]]\\\" />\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/editNode/local\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/editNode/local\",\n            \"caption\": \"Local node style\",\n            \"classes\": \"tmap-remove-top-space\",\n            \"text\": \"\\\\rules except wikilink\\n    \\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  The ''local node configuration'' \\n  (also referred to as //view-specific node configuration//)\\n  overrides the //global individual configuration// and only affects\\n  the node's appearance and behaviour in the current view.\\n</div>\\n<<maybeShowTidColorWarning>>\\n\\n<fieldset>\\n  <legend>Behaviour</legend>\\n  <table class=\\\"tmap-config-table\\\">\\n    <$macrocall type=\\\"input-select\\\"\\n        $name=\\\"tmap-row\\\"\\n        title=\\\"Open view\\\"\\n        field=\\\"local.open-view\\\"\\n        nochoice=\\\"Disabled\\\"\\n        selectFilter=<<tmap \\\"option\\\" \\\"selector.allViewsByLabel\\\">>\\n        descr=\\\"Clicking on this node will open the specified\\n               view instead of the tiddler represented by this node.\\\" />\\n  </table>\\n</fieldset>\\n\\n<$macrocall $name=\\\"sharedSettings\\\"\\n    twIconField=\\\"local.tw-icon\\\"\\n    faIconField=\\\"local.fa-icon\\\"\\n    labelField=\\\"local.label\\\" />\\n                         \\n<$macrocall $name=\\\"visConfiguration\\\"\\n    mode=\\\"manage-node-types\\\"\\n    extensionField=\\\"local-node-style\\\"\\n    styleName=\\\"node's local style\\\"\\n    inheritedList=\\\"[[inherited-global-default-style]]\\n                   [[inherited-local-default-style]]\\n                   [[inherited-group-styles]]\\n                   [[global.tmap.style]]\\\" />\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/editNode\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/editNode\",\n            \"subtitle\": \"{{$:/core/images/edit-button}} Editing style of node \\\"<<tiddler>>\\\"\",\n            \"classes\": \"tmap-remove-top-space\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define maybeShowTidColorWarning()\\n  <$list filter=\\\"[<tidColor>regexp[.+]]\\\">\\n  <div class=\\\"tmap-flash-message tmap-warning\\\">\\n    You have set the tiddler's color\\n    field to \\\"<<tidColor>>\\\". This value will be completely ignored\\n    when you change node's color properties in the vis editor below.\\n  </div>\\n  </$list>\\n\\\\end\\n\\n\\\\define iconSettings(twIconField, faIconField)\\n  <fieldset>\\n    <legend>Icon Settings</legend>\\n    <table class=\\\"tmap-config-table\\\">\\n      <<tmap-row type:\\\"input-text\\\"\\n          title:\\\"TW-icon\\\"\\n          field:\\\"$twIconField$\\\"\\n          descr:\\\"A tiddlywiki image reference.\\n                 For example '$:/core/icon' for Movotun Jack.\\\">>\\n      <<tmap-row type:\\\"input-text\\\"\\n          title:\\\"FA-icon\\\"\\n          field:\\\"$faIconField$\\\"\\n          descr:\\\"A Font Awesome icon code.\\n                 For example 'f206' for the bicycle symbol.\\\">>\\n    </table>\\n  </fieldset>\\n\\\\end\\n\\n\\\\define sharedSettings(twIconField, faIconField, labelField)\\n  <fieldset>\\n    <legend>General Settings</legend>\\n    <table class=\\\"tmap-config-table\\\">\\n      <<tmap-row type:\\\"input-text\\\"\\n          title:\\\"Label\\\"\\n          field:\\\"$labelField$\\\"\\n          descr:\\\"Use this value as node label.\\\">>\\n    </table>\\n  </fieldset>\\n  <!-- display icon fieldset -->\\n  <<iconSettings \\\"$twIconField$\\\" \\\"$faIconField$\\\">>  \\n\\\\end\\n\\n<$macrocall\\n  $name=\\\"tabs\\\"\\n  default=<<concat \\\"$(template)$/default\\\">>\\n  tabsList=\\\"[all[shadows]prefix<template>] -[<template>]\\\"\\n/>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/draft\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/draft\",\n            \"caption\": \"Draft\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-modal-editor\\\">\\n  <$importvariables filter=\\\"[all[tiddlers+shadows]prefix[$:/core/macros/]]\\\">\\n    <$set name=\\\"currentTiddler\\\" value=<<draftTRef>> >\\n      <$transclude tiddler=\\\"$:/core/ui/EditTemplate\\\" field=\\\"text\\\" mode=\\\"block\\\" />\\n    </$set>\\n  </$importvariables>\\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/original\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/original\",\n            \"caption\": \"Preview\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-modal-editor\\\">\\n  <$importvariables filter=\\\"[all[tiddlers+shadows]prefix[$:/core/macros/]]\\\">\\n    <$set name=\\\"currentTiddler\\\" value=<<draftTRef>> >\\n      <$transclude tiddler=\\\"$:/core/ui/ViewTemplate\\\" field=\\\"text\\\" mode=\\\"block\\\" />\\n    </$set>\\n  </$importvariables>\\n</div>\\n\\n<!--\\n<$set name=\\\"currentTiddler\\\" value=<<draftTRef>> >\\n  <$transclude tiddler=\\\"$:/core/ui/ViewTemplate\\\" field=\\\"text\\\" mode=\\\"block\\\" />\\n</$set>-->\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor\",\n            \"subtitle\": \"{{$:/core/images/edit-button}} <<originalTRef>>\",\n            \"classes\": \"tmap-modal-fullscreen-editor tmap-remove-top-space\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define defaultTab() $:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/original\\n\\n<$macrocall $name=\\\"tabs\\\"\\n    default=<<defaultTab>>\\n    tabsList=\\\"[all[shadows]prefix[$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/]]\\\" />\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/fieldChanged\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/fieldChanged\",\n            \"subtitle\": \"{{$:/core/images/info-button}} The field \\\"<<name>>\\\" changed\",\n            \"text\": \"\\\\rules except wikilink\\n\\nYou changed the field \\\"<<name>>\\\" from \\\"<<oldValue>>\\\" to \\\"<<newValue>>\\\".\\n\\nIt is recommended to let TiddlyMap copy all values from the former field \\\"<<oldValue>>\\\" to the new field \\\"<<newValue>>\\\" so the data stored in \\\"<<oldValue>>\\\" is not lost. This operation has to be done now or never.\\n\\nDo you want to move each tiddler's existing \\\"<<oldValue>>\\\" value to \\\"<<newValue>>\\\"? Please note that any value currently stored in \\\"<<newValue>>\\\" would consequently be overridden and the old field \\\"<<oldValue>>\\\" would be eventually removed!\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenNotSupported\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenNotSupported\",\n            \"subtitle\": \"{{$:/core/images/info-button}} Your machine does not support fullscreen\",\n            \"buttons\": \"ok_suppress\",\n            \"text\": \"\\\\rules except wikilink\\n\\nPlease have a look [[here|http://caniuse.com/#feat=fullscreen]] to see a list of supported devices/browsers.\\n\\nSorry for this :(\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/addNodeToMap\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/addNodeToMap\",\n            \"subtitle\": \"{{$:/core/images/tag-button}} Add node\",\n            \"classes\": \"tmap-modal-add-node\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define backButtonText() back to list\\n\\\\define outputAndTemplate() [[$(output)$]] [[$(template)$]]\\n\\n\\\\define editor()\\n  <$button class=\\\"tmap-go-back tc-btn-invisible\\\">\\n    {{$:/core/images/chevron-left}} <<backButtonText>>\\n    <$action-deletefield $tiddler=<<temp>> more template />\\n    <$action-sendmessage\\n        $message=\\\"tmap:tm-clear-tiddler\\\"\\n        keep=\\\"draft.title\\\"\\n        title=<<output>> />\\n  </$button>\\n  \\n  <$list filter=\\\"[<output>get[draft.title]is[tiddler]]\\\">\\n  <div class=\\\"tmap-flash-message tmap-warning\\\">\\n   Tiddler already exists! Use another title or click\\n   \\\"<<backButtonText>>\\\" to cancel your edit.\\n  </div>\\n  </$list>\\n  \\n  <div class=\\\"tmap-modal-editor\\\">\\n    <table class=\\\"tmap-config-table\\\">\\n      <tr class=\\\"tmap-template-select\\\">\\n        <td>Template</td>\\n        <td>\\n          <$select\\n              tiddler=<<temp>>\\n              field=\\\"template\\\">\\n            <option value=\\\"\\\"></option>\\n            <$list filter=<<tmap \\\"option\\\" \\\"selector.allPotentialNodes\\\">>>\\n            <option><$view field=\\\"title\\\" /></option>\\n            </$list> \\n          </$select>\\n          <$button>Load\\n            <$action-sendmessage\\n                $message=\\\"tmap:tm-clear-tiddler\\\"\\n                keep=\\\"draft.title\\\"\\n                title=<<output>> />\\n            <$list filter=\\\"[<temp>get[template]]\\\" variable=\\\"template\\\">\\n            <$action-sendmessage\\n                $message=\\\"tmap:tm-merge-tiddlers\\\"\\n                tiddlers=<<outputAndTemplate>>\\n                output=<<output>> />\\n            <$action-deletefield $tiddler=<<output>> tmap.id tmap.edges />\\n            </$list>\\n          </$button>\\n       </td>\\n       <td></td>\\n      </tr>\\n    </table>\\n    <$importvariables filter=\\\"[all[tiddlers+shadows]prefix[$:/core/macros/]]\\\">\\n      <$set name=\\\"currentTiddler\\\" value=<<output>>>\\n        <$transclude tiddler=\\\"$:/core/ui/EditTemplate\\\" mode=\\\"block\\\" />\\n      </$set>\\n    </$importvariables>\\n  </div>\\n\\\\end\\n\\n\\\\define search()\\n<p>Add an existing tiddler to the map or create a new one.</p>\\n<table id=\\\"tmap-search-table\\\">\\n  <tr>\\n    <td><b>Title:</b></td>\\n    <td>\\n      <$edit-text\\n          tiddler=<<output>>\\n          field=\\\"draft.title\\\"\\n          focus=\\\"true\\\"\\n          type=\\\"text\\\"\\n          tag=\\\"input\\\"\\n          default=\\\"\\\" />\\n      <$list filter=\\\"[<output>get[draft.title]!is[tiddler]]\\\">\\n      <$button\\n          tooltip=\\\"The tiddler does not exist yet and you may edit it\\n                   before it is added to the map\\\">\\n        {{$:/core/images/edit-button}}\\n        <$action-setfield $tiddler=<<temp>> more=\\\"true\\\" />\\n      </$button> <sup>[1]</sup>\\n      </$list>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td></td>\\n    <td>\\n      <$set name=\\\"term\\\" value={{!!draft.title}}>\\n      <ul class=\\\"tmap-small-list\\\">\\n        <$list filter=\\\"[search:title<term>!is[system]!has[draft.of]]\\\">\\n        <li>\\n          <$button class=\\\"tc-btn-invisible tmap-link\\\">\\n            <$view field=\\\"title\\\" />\\n            <$action-setfield $tiddler=<<output>> draft.title={{!!title}} />\\n          </$button>\\n        </li>\\n        </$list>\\n      </ul>\\n      </$set>\\n    </td>\\n  </tr>\\n</table>\\n\\n<$list filter=\\\"[<output>get[draft.title]!is[tiddler]]\\\">\\n<hr />\\n<sup>[1]</sup>\\n<small>\\n  The tiddler does not exist yet and you may edit it\\n  before it is added to the map\\n</small>\\n</$list>\\n\\\\end\\n\\n<$list filter=\\\"[<temp>!has[more]]\\\" variable=\\\"item\\\"><<search>></$list>\\n<$list filter=\\\"[<temp>has[more]]\\\" variable=\\\"item\\\"><<editor>></$list>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/renameView\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/renameView\",\n            \"subtitle\": \"{{$:/core/images/tag-button}} Please specify a view name\",\n            \"text\": \"\\\\rules except wikilink\\n\\n''Name:''\\n<$edit-text focus=\\\"true\\\" tiddler=<<output>> field=\\\"text\\\" type=\\\"text\\\" tag=\\\"input\\\" default=\\\"\\\"\\n            class=\\\"tmap-trigger-field tmap-triggers-ok-button-on-enter\\\" />\\n\\nNote that ''<<count>>'' tiddlers are referencing this view.\\n\\n<$reveal type=\\\"nomatch\\\" text=\\\"0\\\" default=<<count>>>\\n  \\nRenaming the view will cause the reference to be invalid.\\nIt is recommended to first remove the tiddlymap widgets in\\nthe tiddlers listed below or change their view attributes\\naccordingly.\\n\\n''References''\\n\\n<ul>\\n<$list filter=<<filter>> variable=\\\"item\\\">\\n  <li><$text text=<<item>> /></li>\\n</$list>\\n</ul>\\n  \\n</$reveal>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/saveCanvas\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/saveCanvas\",\n            \"subtitle\": \"{{$:/core/images/options-button}} Save a snapshot image of view \\\"<<view>>\\\"\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define preview()\\n<div class=\\\"tmap-save-canvas-preview\\\">\\n  <$transclude tiddler=<<snapshot>> /><br />\\n  Measures: <<width>> × <<height>>\\n</div>\\n\\\\end\\n\\n<table class=\\\"tmap-config-table\\\">\\n<!--\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Name\\\"\\n      field:\\\"name\\\">\\n-->\\n<$macrocall $name=\\\"tmap-row\\\"\\n    type=\\\"input-text\\\"\\n    title=\\\"Name\\\"\\n    field=\\\"name\\\"\\n    descr=<<preview>> />\\n</table>\\n\\n<fieldset><legend>Options</legend>\\n  <table class=\\\"tmap-config-table\\\">\\n    <<tmap-row type:\\\"input-radio\\\"\\n        title:\\\"Action\\\"\\n        field:\\\"action\\\" \\n        selectFilter:\\\"[[download|Download]]\\n                      [[wiki|Save in wiki]]\\n                      [[placeholder|Use as placeholder for this view]]\\\"\\n        descr:\\\"Save the image by downloading it to your computer or\\n               save it as a tiddler in your wiki.<br /><br />\\n               A third option is to make TiddlyMap use this image as\\n               placeholder for the current view. Placeholders are used\\n               when tiddlers are exported in form of static html\\n               or when editing a tiddler while having the preview\\n               shown. In this case the title input is ignored.\\\">>\\n  </table>\\n</fieldset>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/getEdgeType\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/getEdgeType\",\n            \"subtitle\": \"{{$:/plugins/felixhayashi/tiddlymap/icon}} Edge type specification\",\n            \"text\": \"\\\\rules except wikilink\\n\\\\rules except underscore\\n\\n\\\\define filter() $(allEdgeTypes)$ +[search:title[$(term)$]]\\n\\n\\\\define badge(color, label, tooltip)\\n<span style=\\\"background: $color$\\\" title=\\\"$tooltip$\\\">$label$</span>\\n\\\\end\\n\\n\\\\define badges()\\n<$tiddler tiddler={{!!text}}>\\n<$set name=\\\"id\\\" value=<<tmap \\\"getETyId\\\" \\\"$(viewNS)$\\\">>>\\n<$set name=\\\"isVisible\\\" value=<<tmap \\\"isETyVisible\\\" \\\"$(viewNS)$\\\" \\\"$(eTyFilter)$\\\">>>\\n<div class=\\\"tmap-badges\\\">\\n  <span\\n      style=\\\"background: darkslategray\\\"\\n      title=\\\"Your input translates into this id.\\\">\\n  <<id>>\\n  </span>\\n  <$list filter=\\\"[<isVisible>regexp[true]]\\\">\\n    <<badge \\\"green\\\" \\\"visible\\\" \\\"Matches your view's filter\\\">>\\n  </$list>\\n  <$list filter=\\\"[<isVisible>regexp[false]]\\\">\\n    <<badge \\\"red\\\" \\\"not visible\\\" \\\"Doesn't match your view's filter\\\">>\\n  </$list>\\n  <$list filter=\\\"[<id>!regexp[^tmap:unknown$]]\\\" variable=\\\"item\\\">\\n    <$list filter=\\\"[<id>regexp[^_]]\\\">\\n      <<badge \\\"purple\\\" \\\"private\\\" \\\"Not shown in other views per default\\\">>\\n    </$list>\\n    <$list filter=\\\"[<id>regexp[.+:.+]]\\\">\\n      <<badge \\\"orange\\\" \\\"namespace\\\" \\\"This type is prefixed with a proper namespace\\\">>\\n    </$list>\\n  </$list>  \\n</div>\\n</$set>\\n</$set>\\n</$tiddler>\\n\\\\end\\n\\n\\\\define search()\\n<p>\\n  You are about to connect \\\"<$text text=\\\"$(fromLabel)$\\\" />\\\"\\n  with \\\"<$text text=\\\"$(toLabel)$\\\" />\\\". Please specify a type.\\n</p>\\n<table id=\\\"tmap-search-table\\\">\\n  <tr>\\n    <td><b>Type:</b></td>\\n    <td>\\n      <$edit-text\\n          focus=\\\"true\\\"\\n          field=\\\"text\\\"\\n          type=\\\"text\\\"\\n          tag=\\\"input\\\"\\n          default=\\\"\\\"\\n          class=\\\"tmap-trigger-field tmap-triggers-ok-button-on-enter\\\" />\\n      <<badges>>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td></td>\\n    <td>\\n      <$set name=\\\"term\\\" value={{!!text}}>\\n      <$set name=\\\"allEdgeTypes\\\" value=<<tmap \\\"option\\\" \\\"selector.allEdgeTypesById\\\">>>\\n      <ul class=\\\"tmap-small-list\\\">\\n        <$list filter=<<filter>>>\\n        <li>\\n          <$button class=\\\"tc-btn-invisible tmap-link\\\">\\n            <$view field=\\\"title\\\" />\\n            <$action-setfield $tiddler=<<output>> text={{!!title}} />\\n          </$button>\\n        </li>\\n        </$list>\\n      </ul>\\n      </$set>\\n      </$set>\\n    </td>\\n  </tr>\\n</table>\\n\\\\end\\n\\n<$list filter=\\\"[<temp>!has[more]]\\\" variable=\\\"item\\\"><<search>></$list>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=<<classes>>>\\n<$importvariables\\n    filter=\\\"[[$:/plugins/felixhayashi/tiddlymap/misc/macros]]\\n            [[$:/core/macros/tabs]]\\\">\\n<$transclude tiddler=<<template>> mode=\\\"block\\\" />\\n</$importvariables>\\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/welcome\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/welcome\",\n            \"subtitle\": \"{{$:/core/images/info-button }} Welcome\",\n            \"buttons\": \"ok\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$list filter=\\\"[[$:/plugins/felixhayashi/topstoryview]]\\\">\\n<div class=\\\"tmap-flash-message tmap-success\\\">\\n  TiddlyMap configured your wiki for optimal use. Please save &amp;\\n  restart after closing this dialog.\\n</div>\\n</$list>\\n\\nIt seems that you freshly installed TiddlyMap.\\n\\n* In case you need any help, please consult the [[online docs|http://tiddlymap.org#Documentation]] first.\\n* You are welcome to create an [[issue|https://github.com/felixhayashi/TW5-TiddlyMap/issues]] at GitHub for any bug you discover.\\n* Make sure to revisit the [[demo site|http://tiddlymap.org]] to see whether your version is up-to-date.\\n* If you like TiddlyMap, please give it a star at [[GitHub|https://github.com/felixhayashi/TW5-TiddlyMap]] or tell your friends about it :)\\n\\nHave a great time.\\n\\n---\\n\\n''Please note:'' TiddlyMap is distributed under the [[BSD 2-Clause License|http://opensource.org/licenses/BSD-2-Clause]], which belongs to the same license family, as the license used by TiddlyWiki. By using this plugin you agree to the product's [[License Terms|https://github.com/felixhayashi/TW5-TiddlyMap/blob/master/LICENSE]].\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/widgetCodeGenerator\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/widgetCodeGenerator\",\n            \"subtitle\": \"{{$:/core/images/permalink-button}} Widget Code Generator\",\n            \"buttons\": \"close\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<div class=\\\"tmap-flash-message tmap-info\\\">\\n  Use the code below to embed a view in a tiddler.\\n</div>\\n\\n<pre style=\\\"white-space: normal;\\\">\\n&lt;$tmap\\n\\n<$list filter=\\\"[<output>has[var.view]]\\\">\\n  view=\\\"<$view field='var.view' />\\\"</$list>\\n<$list filter=\\\"[<output>field:var.click-to-use[true]]\\\">\\n  click-to-use=\\\"true\\\"</$list>\\n<$list filter=\\\"[<output>has[var.editor]]\\\">\\n  editor=\\\"<$view field='var.editor' />\\\"</$list>\\n<$list filter=\\\"[<output>has[var.width]]\\\">\\n  width=\\\"<$view field='var.width' />\\\"</$list>\\n<$list filter=\\\"[<output>has[var.height]]\\\">\\n  height=\\\"<$view field='var.height' />\\\"</$list>\\n<$list filter=\\\"[<output>has[var.class]]\\\">\\n  class=\\\"<$view field='var.class' />\\\"</$list>\\n<$list filter=\\\"[<output>field:var.show-buttons[false]]\\\">\\n  show-buttons=\\\"false\\\"</$list>\\n<$list filter=\\\"[<output>has[var.design]]\\\">\\n  design=\\\"<$view field='var.design' />\\\"</$list>&gt;&lt;/$tmap&gt;\\n</pre>\\n\\n<fieldset>\\n  <legend>Parameters</legend> \\n  <table class=\\\"tmap-config-table\\\">\\n      <$macrocall type=\\\"input-select\\\"\\n          $name=\\\"tmap-row\\\"\\n          title=\\\"View\\\"\\n          field=\\\"var.view\\\"\\n          nochoice=\\\" \\\"\\n          selectFilter=<<tmap \\\"option\\\" \\\"selector.allViewsByLabel\\\">>\\n          descr=\\\"The view to bind the wiedget to\\\" />\\n      <<tmap-row type:\\\"input-select\\\"\\n          title:\\\"Editor bar\\\"\\n          field:\\\"var.editor\\\"\\n          selectFilter:\\\"[[|Hidden]]\\n                        [[vis|Simple]]\\n                        [[advanced|Advanced]]\\\"\\n          descr:\\\"Whether the widget should act as an editor or not.\\\">>\\n      <<tmap-row type:\\\"input-select\\\"\\n          title:\\\"Design\\\"\\n          field:\\\"var.design\\\"\\n          selectFilter:\\\"[[|Normal]]\\n                        [[plain|Plain]]\\\"\\n          descr:\\\"Usually a header is displayed and borders. Plain\\n                 design will only show the mere graph.\\\">>\\n      <<tmap-row type:\\\"input-text\\\"\\n          title:\\\"Height\\\"\\n          field:\\\"var.height\\\"\\n          descr:\\\"Graph's height in css units. Defaults to '300px'.\\\">>\\n      <<tmap-row type:\\\"input-text\\\"\\n          title:\\\"Width\\\"\\n          field:\\\"var.width\\\"\\n          descr:\\\"Graph's width in css units. Defaults to '100%'.\\\">>\\n      <<tmap-row type:\\\"input-text\\\"\\n          title:\\\"Class\\\"\\n          field:\\\"var.class\\\"\\n          descr:\\\"A custom class to apply your own css.\\\">>\\n      <<tmap-row type:\\\"input-checkbox\\\"\\n          title:\\\"Click to use\\\"\\n          field:\\\"var.click-to-use\\\"\\n          default:\\\"false\\\"\\n          descr:\\\"A click is needed to enable the graph.\\\">>\\n      <<tmap-row type:\\\"input-checkbox\\\"\\n          title:\\\"Show buttons\\\"\\n          field:\\\"var.show-buttons\\\"\\n          default:\\\"true\\\"\\n          descr:\\\"Show or hide the graph's navigation buttons.\\\">>\\n  </table>\\n</fieldset>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/close\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/close\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$button class=\\\"tmap-dialog-button tmap-close-button\\\" tooltip=\\\"Close this dialog\\\">Close\\n\\n  <!-- trigger dialog callback -->\\n  <$action-setfield $tiddler=<<result>> text=\\\"1\\\" />\\n                       \\n</$button>\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$button class=\\\"tmap-dialog-button tmap-ok-button\\\" tooltip=\\\"Confirm dialog\\\">OK\\n\\n  <!-- trigger dialog callback -->\\n  <$action-setfield $tiddler=<<result>> text=\\\"1\\\" />\\n                       \\n</$button>\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_cancel\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_cancel\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$transclude tiddler=\\\"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok\\\" mode=\\\"inline\\\" />\\n<$button class=\\\"tmap-dialog-button tmap-cancel-button\\\" tooltip=\\\"Close dialog without saving\\\">Cancel\\n  <!-- trigger dialog callback -->\\n  <$action-setfield $tiddler=<<result>> text=\\\"\\\" />\\n</$button>\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_suppress\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_suppress\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$set name=\\\"currentTiddler\\\" value=<<title>> >\\n\\n<$checkbox field=\\\"suppress\\\" checked=\\\"1\\\" unchecked=\\\"0\\\" default=\\\"0\\\"> Do not show this dialog again</$checkbox>\\n<$button class=\\\"tmap-dialog-button tmap-ok-button\\\" tooltip=\\\"Confirm this dialog\\\">OK\\n\\n  <!-- trigger dialog callback -->\\n  <$action-setfield $tiddler=<<result>> text=\\\"1\\\" />\\n  \\n  <!-- suppress dialog in the future -->\\n  <$action-sendmessage $message=\\\"tmap:tm-suppress-dialog\\\"\\n                       dialog=<<templateId>>\\n                       suppress={{!!suppress}} />\\n                       \\n</$button>\\n\\n</$set>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialogFooter\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialogFooter\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define footer() $:/plugins/felixhayashi/tiddlymap/dialogFooter/$(buttons)$\\n\\n<$transclude tiddler=<<footer>> />\\n\\n<!-- we need this button to be able to close a tiddler from outside programmatically -->\\n<$button class=\\\"tmap-hidden-close-button\\\" message=\\\"tm-close-tiddler\\\" />\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/element_type_manager\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialogFooter/element_type_manager\",\n            \"text\": \"\\\\rules except wikilink\\n\\n<$button\\n    class=\\\"tmap-dialog-button tmap-save-button\\\"\\n    tooltip=\\\"Save the current changes\\\">Save\\n  <$action-sendmessage\\n      $message=\\\"tmap:tm-save-type-form\\\"\\n      mode=<<mode>>\\n      output=<<output>> />\\n</$button>\\n<$button\\n    class=\\\"tmap-dialog-button tmap-cancel-button\\\"\\n    tooltip=\\\"Cancel the most resent changes and exit\\\">Quit\\n  <$action-setfield $tiddler=<<result>> text=\\\"1\\\" />\\n</$button>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/deleteType\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/deleteType\",\n            \"caption\": \"Removal\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define manage-edge-types()\\n  <$macrocall $name=\\\"tmap-row\\\"\\n      type=\\\"input-checkbox\\\"\\n      title=\\\"Delete type\\\"\\n      field=\\\"temp.deleteType\\\"\\n      default={{!id}}\\n      readonly={{!!temp.idImmutable}}\\n      descr=\\\"If you want to delete this type, set this to true\\n             and click the save button afterwards. Predefined system\\n             types cannot be deleted.\\\" note=\\\"Consequently, all edges\\n             of this type will be deleted.\\\" />\\n\\\\end\\n\\n\\\\define manage-node-types()\\n  <$macrocall $name=\\\"tmap-row\\\"\\n      type=\\\"input-checkbox\\\"\\n      title=\\\"Delete type\\\"\\n      field=\\\"temp.deleteType\\\"\\n      default={{!id}}\\n      readonly={{!!temp.idImmutable}}\\n      descr=\\\"If you want to delete this type, set this to true and\\n             click the save button afterwards. Predefined system\\n             types cannot be deleted.\\\" />\\n\\\\end\\n\\n<table class=\\\"tmap-config-table\\\"><$macrocall $name=<<mode>> /></table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/description\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/description\",\n            \"caption\": \"Description\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define manage-edge-types()\\n  <<tmap-row type:\\\"input-textarea\\\"\\n      title:\\\"Description\\\"\\n      field:\\\"description\\\"\\n      descr:\\\"An optional description for this type. The\\n             description will be displayed as tooltip when\\n             moving the mouse over an edge of this type.\\\">>\\n\\\\end\\n\\n\\\\define manage-node-types()\\n  <<tmap-row type:\\\"input-textarea\\\"\\n      title:\\\"Description\\\"\\n      field:\\\"description\\\" \\n      descr:\\\"An optional description for this type.\\\">>\\n\\\\end\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <$macrocall $name=<<mode>> />\\n</table>\\n\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/generalSettings\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/generalSettings\",\n            \"caption\": \"General\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define manage-edge-types()\\n  <<tmap-row type:\\\"input-text\\\"\\n      title:\\\"Label\\\"\\n      field:\\\"label\\\" \\n      descr:\\\"An optional alias used as edge-label.\\\">>\\n  <<tmap-row type:\\\"input-checkbox\\\"\\n      title:\\\"Show label\\\"\\n      field:\\\"show-label\\\"\\n      default:\\\"true\\\"\\n      descr:\\\"If unchecked, no edge label will be displayed.\\\">>\\n\\\\end\\n\\\\define manage-node-types()\\n  <$list filter=\\\"[<currentTiddler>regexp[tmap:]]\\\">\\n  <<tmap-row type:\\\"input-textarea\\\"\\n      title:\\\"Scope\\\"\\n      field:\\\"scope\\\" \\n      descr:\\\"A filter expression that defines, which nodes inherit\\n             this node-type and its style.\\\">>\\n  </$list>\\n  <$macrocall type=\\\"input-select\\\"\\n      $name=\\\"tmap-row\\\" \\n      title=\\\"Priority\\\"\\n      field=\\\"priority\\\"\\n      selectFilter=<<tmap \\\"scale\\\" \\\"100\\\">>\\n      descr=\\\"When a type has a a higher priority than another type,\\n             its style will override the other style\\\" />\\n\\\\end\\n\\n<table class=\\\"tmap-config-table\\\">\\n  <$macrocall\\n    $name=\\\"tmap-row\\\"\\n    title=\\\"Identifier\\\"\\n    field=\\\"temp.newId\\\"\\n    type=\\\"input-text\\\"\\n    default={{!!id}}\\n    readonly={{!!temp.idImmutable}}\\n    descr=\\\"A unique identifier\\\"\\n  />\\n  <$macrocall $name=<<mode>> />\\n</table>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/overview\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/overview\",\n            \"caption\": \"Overview\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define date(f) <$view field=$f$ format=\\\"date\\\" template=\\\"DDth mmm hh:mm:ss\\\"/>\\n\\n! <$link to={{!!typeTRef}}><$view field=\\\"id\\\" /></$link>\\n\\n<table class=\\\"tmap-key-value-table\\\">\\n  <tr>\\n    <th align=\\\"left\\\">Created on</th>\\n    <td>\\n      <<date \\\"created\\\">>\\n    </td>\\n  </tr>\\n  <tr>\\n    <th align=\\\"left\\\">Modified on</th>\\n    <td><<date \\\"modified\\\">></td>\\n  </tr>\\n  <tr>\\n    <th align=\\\"left\\\">Usage count</th>\\n    <td>\\n      <span class=\\\"tmap-edge-type-specific\\\">\\n        <$view field=\\\"temp.usageCount\\\" />\\n      </span>\\n      <span class=\\\"tmap-node-type-specific\\\">\\n        <$count filter={{!!scope}}>0</$count>\\n      </span>\\n    </td>\\n  </tr>\\n</table>\\n\\n<$view field=\\\"description\\\">//No description available//</$view>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/styling\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/styling\",\n            \"caption\": \"Styling\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define url()\\n  <$set\\n      filter=\\\"[<mode>prefix[manage-edge-types]]\\\"\\n      name=\\\"module\\\"\\n      value=\\\"edges\\\"\\n      emptyValue=\\\"nodes\\\">\\n    [[visjs.org|http://visjs.org/docs/network/$(module)$]]\\n  </$set>\\n\\\\end\\n\\n<fieldset class=\\\"tmap-node-type-specific\\\">\\n  <legend>Icon Settings</legend>\\n  <table class=\\\"tmap-config-table\\\">\\n    <<tmap-row type:\\\"input-text\\\"\\n        title:\\\"TW-icon\\\"\\n        field:\\\"tw-icon\\\"\\n        descr:\\\"A tiddlywiki image reference.\\n               For example '$:/core/icon' for Movotun Jack.\\\">>\\n    <<tmap-row type:\\\"input-text\\\"\\n        title:\\\"FA-icon\\\"\\n        field:\\\"fa-icon\\\"\\n        descr:\\\"A Font Awesome icon code.\\n               For example 'f206' for the bicycle symbol.\\\">>\\n  </table>\\n</fieldset>\\n\\n<fieldset><legend>Visjs styles</legend>\\n  <div class=\\\"tmap-flash-message tmap-info\\\">\\n     All visjs options below are documented at <<url>>.\\n  </div>\\n  <div class=\\\"tmap-flash-message tmap-info\\\">\\n     Only config items that you actually changed have an effect on\\n     the graph. Other options are visible, yet, inactive.\\n  </div>\\n  <$tmap-config\\n      mode=<<mode>>\\n      inherited=\\\"vis-inherited\\\"\\n      extension=\\\"style\\\" />\\n</fieldset>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager\",\n            \"subtitle\": \"{{$:/core/images/tag-button}} <<topic>>\",\n            \"buttons\": \"element_type_manager\",\n            \"classes\": \"tmap-remove-top-space\",\n            \"text\": \"\\\\rules except wikilink\\n\\n\\\\define defaultTab() \\n$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/overview\\n\\\\end\\n\\n\\\\define settingsTab()\\n$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/generalSettings\\n\\\\end\\n\\n\\\\define tabsFilter()\\n[all[shadows]prefix[$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/]]\\n\\\\end\\n\\n\\\\define searchFilter()\\n$(searchSelector)$\\n+[sort[title]nsort[priority]]\\n+[removeprefix<typeRootPath>removeprefix[/]]\\n+[search:title{$:/temp/tmap/MapElementTypeSearch}]\\n\\\\end\\n\\n\\\\define managerClass() tmap-$(mode)$\\n\\n\\\\define typePath() $(typeRootPath)$/$(id)$\\n\\n<div id=\\\"tmap-element-type-manager\\\" class=<<managerClass>>>\\n  <div>\\n    <div class=\\\"tmap-searchbar\\\">\\n      <$edit-text\\n          focus=\\\"true\\\"\\n          tiddler=\\\"$:/temp/tmap/MapElementTypeSearch\\\"\\n          type=\\\"text\\\"\\n          tag=\\\"input\\\"\\n          default=\\\"\\\" />\\n      <$list filter=\\\"[{$:/temp/tmap/MapElementTypeSearch}regexp[.+]]\\n                     +[addprefix[/]]\\n                     +[addprefix<typeRootPath>]\\n                     +[!is[tiddler]!is[shadow]]\\\">\\n      <$button tooltip=\\\"Create a new type of this name\\\">\\n      {{$:/core/images/new-button}}\\n        <$action-setfield $tiddler=\\\"$:/temp/tmap/MapElementTypeSearch\\\" text=\\\"\\\" />\\n        <$action-sendmessage\\n            $message=\\\"tmap:tm-create-type\\\"\\n            mode=<<mode>> id={{$:/temp/tmap/MapElementTypeSearch}}\\n            output=<<output>> />\\n      </$button>\\n      </$list>\\n          \\n    </div>\\n    <ul>\\n      <$list\\n          filter=<<searchFilter>>\\n          emptyMessage=<<noTypeFound>>\\n          variable=\\\"id\\\">\\n      <li>\\n        <span class=\\\"tmap-ranking tmap-node-type-specific\\\">\\n          # <$view tiddler=<<typePath>> field=\\\"priority\\\">1</$view>\\n        </span>\\n        <$button class=\\\"tc-btn-invisible tmap-link\\\"><<id>>\\n          <$action-setfield\\n              $tiddler=<<qualify \\\"$:/state/tabs/MapElementTypeManager\\\">>\\n              text=<<defaultTab>> />\\n          <$action-sendmessage\\n              $message=\\\"tmap:tm-load-type-form\\\"\\n              id=<<id>>\\n              mode=<<mode>>\\n              output=<<output>> />\\n        </$button>\\n      </li>\\n      </$list>\\n    </ul>\\n  </div>\\n  <div>\\n    <$reveal type=\\\"nomatch\\\" text=\\\"\\\" default={{!!id}} >\\n      <$macrocall\\n          $name=\\\"tabs\\\"\\n          default=<<defaultTab>>\\n          state=\\\"$:/state/tabs/MapElementTypeManager\\\"\\n          tabsList=<<tabsFilter>> />\\n    </$reveal>\\n    <$reveal type=\\\"match\\\" text=\\\"\\\" default={{!!id}} >\\n      <div class=\\\"tmap-flash-message tmap-info\\\">\\n        Please select a type from the list or create a new one by\\n        entering the type name in the search field on the left.\\n      </div>\\n      <div class=\\\"tmap-flash-message tmap-info tmap-node-type-specific\\\">\\n        The number next to the node-type label represents it's priority.\\n      </div>\\n    </$reveal>\\n  </div>\\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node\",\n            \"text\": \"\\\\define single()\\n  <$list filter=\\\"\\n      [[tmap:tm-toggle-central-topic, $:/core/images/star-filled, Toggle central topic]]\\n      [[tmap:tm-delete-element, $:/core/images/delete-button, Delete node]]\\\">\\n    <$button class=\\\"tc-btn-invisible\\\">\\n      <$action-sendmessage $message=<<tmap \\\"splitAndSelect\\\" \\\", \\\" \\\"0\\\">> />\\n      <$transclude tiddler=<<tmap \\\"splitAndSelect\\\" \\\", \\\" \\\"1\\\">> />\\n      <<tmap \\\"splitAndSelect\\\" \\\", \\\" \\\"2\\\">>\\n    </$button>\\n  </$list>\\n\\\\end\\n\\n\\\\define multi()\\n  <$list filter=\\\"\\n      [[tmap:tm-delete-element, $:/core/images/delete-button, Delete selected nodes]]\\\">\\n    <$button class=\\\"tc-btn-invisible\\\">\\n      <$action-sendmessage $message=<<tmap \\\"splitAndSelect\\\" \\\", \\\" \\\"0\\\">> />\\n      <$transclude tiddler=<<tmap \\\"splitAndSelect\\\" \\\", \\\" \\\"1\\\">> />\\n      <<tmap \\\"splitAndSelect\\\" \\\", \\\" \\\"2\\\">>\\n    </$button>\\n  </$list>\\n\\\\end\\n\\n<div class=\\\"tc-drop-down\\\">\\n  <$macrocall $name=<<mode>> />\\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/misc/advancedEditorBar\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/misc/advancedEditorBar\",\n            \"text\": \"\\\\rules except wikilink\\n\\\\define showEdgeField() show-$(curEdgeId)$\\n\\n<!-- === View Switcher ========================================== -->\\n\\n<div class=\\\"tmap-menu-bar\\\">\\n  View:\\n  <$reveal type=\\\"match\\\" text=\\\"false\\\" default=<<isViewBound>> >\\n    <$select\\n        tiddler=<<viewHolder>>\\n        field=\\\"text\\\"\\n        default=<<viewLabel>> >\\n      <$list filter=<<tmap \\\"option\\\" \\\"selector.allViewsByLabel\\\">> >\\n        <option value={{!!title}}>\\n          <$view tiddler={{!!title}} field=\\\"title\\\" />\\n        </option>\\n      </$list>\\n    </$select>\\n  </$reveal>\\n  <$reveal type=\\\"match\\\" text=\\\"true\\\" default=<<isViewBound>> >\\n    <b><<viewLabel>></b>\\n  </$reveal>\\n\\n<!-- === Menu =================================================== -->\\n\\n  <$button\\n      popup=<<qualify \\\"$:/temp/menu\\\">>\\n      tooltip=\\\"Open the Menu\\\">{{$:/core/images/menu-button}}\\n  </$button>\\n  \\n  <$reveal type=\\\"popup\\\" position=\\\"below\\\" state=<<qualify \\\"$:/temp/menu\\\">> >\\n    <div class=\\\"tc-drop-down\\\">\\n      <a href=\\\"http://tiddlymap.org#Documentation\\\" target=\\\"_blank\\\">\\n        {{$:/core/images/info-button}} Open online help\\n      </a>\\n      <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-create-view\\\">\\n        {{$:/core/images/new-button}} Create new view\\n      </$button>\\n      <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-generate-widget\\\">\\n        {{$:/core/images/permalink-button}} Grab widget code\\n      </$button>\\n      <div class=\\\"tmap-list-separator\\\">Global configurations:</div>\\n      <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-configure-system\\\">\\n        {{$:/core/images/options-button}} Configure TiddlyMap\\n      </$button>\\n      <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-manage-edge-types\\\">\\n        <span class=\\\"tmap-unicode-icon\\\">◭</span> Manage edge-types\\n      </$button>\\n      <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-manage-node-types\\\">\\n        <span class=\\\"tmap-unicode-icon\\\">▢</span> Manage node-types\\n      </$button>\\n      <div class=\\\"tmap-view-actions\\\">\\n        <div class=\\\"tmap-list-separator\\\">Actions for this view:</div>\\n        <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-edit-view\\\">\\n          {{$:/core/images/options-button}} Configure view\\n        </$button>\\n        <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-store-position\\\">\\n          {{$:/core/images/globe}} Save positions\\n        </$button>\\n        <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-rename-view\\\">\\n          {{$:/core/images/tag-button}} Rename view\\n        </$button>\\n        <$button class=\\\"tc-btn-invisible\\\" message=\\\"tmap:tm-delete-view\\\">\\n          {{$:/core/images/delete-button}} Delete view\\n        </$button>\\n      </div>\\n    </div>\\n  </$reveal>\\n  \\n<!-- === Neighbourhood menu ===================================== -->\\n\\n  <$reveal\\n      type=\\\"match\\\"\\n      text=\\\"true\\\"\\n      default=<<tmap \\\"option\\\"\\n                     \\\"config.sys.editorMenuBar.showNeighScopeButton\\\">>>\\n    <$button\\n        class=<<neighScopeBtnClass>>\\n        tooltip=\\\"Change the neighbourhood scope\\\"\\n        popup=<<qualify \\\"$:/temp/neighScope\\\">>>☀\\n    </$button>\\n  </$reveal>\\n  \\n  <$reveal type=\\\"popup\\\" position=\\\"below\\\" state=<<qualify \\\"$:/temp/neighScope\\\">> >\\n    <div class=\\\"tc-drop-down\\\">\\n      <div class=\\\"tmap-list-separator\\\">Neighbourhood scope</div>\\n      <$button class=\\\"tc-btn-invisible\\\">None\\n        <$action-setfield\\n            $tiddler=<<viewRoot>>\\n            config.neighbourhood_scope=\\\"\\\" />\\n      </$button>\\n      <$list filter=\\\"[[1|1 step distance]]\\n                     [[2|2 step distance]]\\n                     [[3|3 step distance]]\\n                     [[4|4 step distance]]\\n                     [[5|5 step distance]]\\\">\\n        <$button class=\\\"tc-btn-invisible\\\">\\n          <<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"1\\\">>\\n          <$action-setfield\\n              $tiddler=<<viewRoot>>\\n              config.neighbourhood_scope=<<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"0\\\">> />\\n        </$button>\\n      </$list>\\n      <$button class=\\\"tc-btn-invisible\\\">No limit\\n        <$action-setfield\\n            $tiddler=<<viewRoot>>\\n            config.neighbourhood_scope=\\\"100\\\" />\\n      </$button>\\n      <div class=\\\"tmap-list-separator\\\">Neighbourhood traversal</div>\\n      <$radio field=\\\"config.neighbourhood_directions\\\" value=\\\"in\\\"> Incoming</$radio><br />\\n      <$radio field=\\\"config.neighbourhood_directions\\\" value=\\\"out\\\"> Outgoing</$radio><br />\\n      <$radio field=\\\"config.neighbourhood_directions\\\" value=\\\"\\\"> Both</$radio>\\n      <div class=\\\"tmap-list-separator\\\">Other</div>\\n      <$checkbox field=\\\"config.show_inter_neighbour_edges\\\"\\n          checked=\\\"true\\\" unchecked=\\\"false\\\"> Inter-neighbour edges</$checkbox>\\n      \\n    </div>\\n  </$reveal>\\n  \\n<!-- === Export menu ============================================ -->\\n  \\n  <$reveal\\n      type=\\\"match\\\"\\n      text=\\\"true\\\"\\n      default=<<tmap \\\"option\\\"\\n                     \\\"config.sys.editorMenuBar.showScreenshotButton\\\">>>\\n    <$button\\n        tooltip=\\\"Open the map-export menu\\\"\\n        popup=<<qualify \\\"$:/temp/mapExport\\\">>>\\n      {{$:/core/images/download-button}}\\n    </$button>\\n  </$reveal>\\n  \\n  <$reveal\\n      type=\\\"popup\\\"\\n      position=\\\"below\\\"\\n      state=<<qualify \\\"$:/temp/mapExport\\\">>>\\n    <div class=\\\"tc-drop-down\\\">\\n    <$button\\n        class=\\\"tc-btn-invisible\\\"\\n        tooltip=\\\"Export the graph and all its elements\\n                 in form of a JSON file\\\">\\n        {{$:/core/images/permalink-button}} Save as JSON file\\n      <$action-sendmessage\\n          $message=\\\"tmap:tm-download-graph\\\"\\n          view=<<viewLabel>> />\\n    </$button>\\n    <$button\\n        class=\\\"tc-btn-invisible\\\"\\n        tooltip=\\\"Create a png image to download or save it\\n                 as image or view-placeholder in your wiki\\\">\\n        {{$:/core/images/palette}} Save as png image\\n      <$action-sendmessage $message=\\\"tmap:tm-save-canvas\\\" />\\n    </$button>\\n    </div>\\n  </$reveal>\\n    \\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/misc/focusButton\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/misc/focusButton\",\n            \"text\": \"\\\\define filter() [list[$:/temp/tmap/nodes/$(viewLabel)$]search:title{$:/temp/tmap/bar/search}]\\n\\\\define concat(str) $str$\\n\\n\\\\define state() $(widgetPopupsPath)$/focus\\n\\n<div class=\\\"tmap-focus-button\\\">\\n  <$reveal type=\\\"match\\\" state=<<state>> text=\\\"\\\">\\n    <$button\\n        tooltip=\\\"Zoom on a specific node\\\"\\n        class=<<tv-config-toolbar-class>>>{{$:/core/images/advanced-search-button}}\\n     <$action-setfield $tiddler=\\\"$:/temp/tmap/bar/search\\\" text=\\\"\\\" />\\n     <$action-setfield $tiddler=<<state>> text=\\\"1\\\" />\\n    </$button>\\n  </$reveal>\\n  <$reveal type=\\\"nomatch\\\" state=<<state>> text=\\\"\\\">\\n    <$button\\n        tooltip=\\\"Close zoom popup\\\"\\n        class=<<tv-config-toolbar-class>>>{{$:/core/images/advanced-search-button}}\\n     <$action-setfield $tiddler=<<state>> text=\\\"\\\" />\\n    </$button>\\n    <div class=\\\"tmap-search-dropdown\\\">\\n      <div class=\\\"tc-drop-down\\\">\\n        <$edit-text\\n            focus=\\\"true\\\"\\n            tiddler=\\\"$:/temp/tmap/bar/search\\\"\\n            field=\\\"text\\\"\\n            type=\\\"text\\\"\\n            tag=\\\"input\\\"\\n            default=\\\"\\\" />\\n        <small><$count filter=<<filter>> /> results</small>\\n        <hr />\\n        <div class=\\\"tmap-very-small-list\\\">\\n          <$list filter=<<filter>>\\n              variable=\\\"item\\\"\\n              emptyMessage=\\\"//No results//\\\">\\n            <$button\\n                class=\\\"tc-btn-invisible\\\"\\n                message=\\\"tmap:tm-focus-node\\\"\\n                param=<<item>>>\\n              <$view tiddler=<<item>> field=\\\"title\\\" />\\n            </$button>\\n          </$list>\\n        </div>\\n      </div>\\n    </div>\\n  </$reveal>\\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/hook/editor\": {\n            \"caption\": \"Map\",\n            \"tags\": \"$:/tags/SideBar\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/hook/editor\",\n            \"text\": \"\\\\define width() calc(100% - 15px)\\n\\n<div class=\\\"tmap-mobile-editor\\\">\\n  <div class=\\\"tmap-flash-message tmap-warning\\\">\\n    The editor is not displayed in mobile mode.\\n  </div>\\n</div>\\n<div class=\\\"tmap-desktop-editor\\\">\\n  <$tiddlymap\\n    class=\\\"tmap-sidebar-map-editor\\\"\\n    editor=\\\"advanced\\\"\\n    object-id=\\\"main_editor\\\"\\n    click-to-use=\\\"false\\\">\\n  </$tiddlymap>\\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/hook/liveTab\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/hook/liveTab\",\n            \"caption\": \"Live\",\n            \"text\": \"\\\\define width() calc(100% - 15px)\\n\\n<div class=\\\"tmap-mobile-editor\\\">\\n  <div class=\\\"tmap-flash-message tmap-warning\\\">\\n    The live tab is not displayed in mobile mode.\\n  </div>\\n</div>\\n<div class=\\\"tmap-desktop-editor\\\">\\n  <$set name=\\\"view\\\"\\n      filter=\\\"[{$:/temp/tmap/currentTiddler}get[tmap.open-view]]\\\"\\n      emptyValue=<<tmap \\\"option\\\" \\\"config.sys.liveTab.fallbackView\\\">>>\\n  <div>\\n    <$tiddlymap\\n        view=<<view>>\\n        click-to-use=\\\"false\\\"\\n        refresh-triggers=\\\"$:/temp/tmap/currentTiddler\\\"\\n        object-id=\\\"live_tab\\\">\\n    </$tiddlymap>\\n  </div>\\n  </$set> \\n</div>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/misc/quickConnectButton\": {\n            \"tags\": \"$:/tags/ViewToolbar\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/misc/quickConnectButton\",\n            \"description\": \"{{$:/language/Buttons/TiddlyMap/Hint}}\",\n            \"caption\": \"{{$:/plugins/felixhayashi/tiddlymap/icon}} {{$:/language/Buttons/TiddlyMap/Caption}}\",\n            \"text\": \"\\\\define buttonClass() $(tv-config-toolbar-class)$ $(additional-classes)$\\n\\n\\\\define nonExistentItem()\\n<<item>> <span style=\\\"color: #9E9E9E\\\">(will be created)</span>\\n\\\\end\\n\\n\\\\define noConnectionsMsg()\\n<tr><td colspan=\\\"4\\\">//No connections found!//</td></tr>\\n\\\\end\\n\\n\\\\define normalSearchFilter()\\n[!is[system]!has[draft.of]search:title{$:/temp/quickConnectSearch}sortcs[title]limit[50]]\\n\\\\end\\n\\n\\\\define regexSearchFilter()\\n[!is[system]!has[draft.of]regexp{$:/temp/quickConnectSearch}sortcs[title]limit[50]]\\n\\\\end\\n\\n\\\\define showButton(state)\\n<$button set=\\\"$:/temp/tmap/state/popup/quickConnect\\\"\\n         setTo=\\\"$state$\\\" tooltip={{$:/language/Buttons/TiddlyMap/Hint}} \\n         aria-label={{$:/language/Buttons/TiddlyMap/Caption}}\\n         class=<<buttonClass>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>prefix[yes]]\\\">{{$:/plugins/felixhayashi/tiddlymap/icon}}</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>prefix[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\"><$text text={{$:/language/Buttons/TiddlyMap/Caption}}/></span>\\n</$list>\\n</$button>\\n\\\\end\\n\\n\\\\define searchResults()\\n<td>\\n  <$button tooltip=\\\"Create incoming edge\\\">\\n    <<tmap \\\"option\\\" \\\"misc.arrows.in\\\">>\\n    <$action-sendmessage $message=\\\"tmap:tm-create-edge\\\"\\n                         from=<<item>>\\n                         to=<<currentTiddler>>\\n                         force=\\\"true\\\"\\n                         label={{$:/temp/quickConnectSearch/type}}\\n                         view={{$:/temp/quickConnectSearch/view}} />\\n  </$button>\\n</td>\\n<td>\\n  <$button tooltip=\\\"Create outgoing edge\\\">\\n    <<tmap \\\"option\\\" \\\"misc.arrows.out\\\">>\\n    <$action-sendmessage $message=\\\"tmap:tm-create-edge\\\"\\n                         from=<<currentTiddler>>\\n                         to=<<item>>\\n                         force=\\\"true\\\"\\n                         label={{$:/temp/quickConnectSearch/type}}\\n                         view={{$:/temp/quickConnectSearch/view}} />\\n  </$button>\\n</td>\\n<td>\\n  <$list\\n      filter=\\\"[<item>is[tiddler]]\\\"\\n      emptyMessage=<<nonExistentItem>>>\\n    <$view tiddler=<<item>> field=\\\"title\\\" />\\n  </$list>\\n</td>\\n\\\\end\\n\\n\\\\define hidePopup()\\n<$macrocall $name=\\\"showButton\\\" state=<<qualify>> />\\n\\\\end\\n\\n\\\\define showPopup()\\n<$set name=\\\"additional-classes\\\" value=\\\"tmap-active-button\\\">\\n  <$macrocall $name=\\\"showButton\\\" state=\\\"\\\" />\\n</$set>\\n<$set\\n    name=\\\"searchFilter\\\"\\n    filter=\\\"[field:title[$:/state/tmap/tid-toolbar]has[re-filter]]\\\"\\n    value=<<regexSearchFilter>>\\n    emptyValue=<<normalSearchFilter>>>\\n<div class=\\\"tmap-quick-connect tc-reveal tc-popup\\\">\\n  <div class=\\\"tc-drop-down\\\">\\n    <div class=\\\"title\\\">Create connection</div>\\n    <table class=\\\"tmap-quick-connect-search-bar\\\">\\n      <tr>\\n        <td>Type:</td>\\n        <td>\\n          <$edit-text\\n              tiddler=\\\"$:/temp/quickConnectSearch/type\\\"\\n              field=\\\"text\\\"\\n              type=\\\"text\\\"\\n              tag=\\\"input\\\"\\n              default=\\\"\\\" />\\n          <$select tiddler=\\\"$:/temp/quickConnectSearch/type\\\" default=\\\"\\\">\\n            <option></option>\\n            <$list filter=<<tmap \\\"option\\\" \\\"selector.allEdgeTypesById\\\">>>\\n              <option>{{!!title}}</option>\\n            </$list>\\n          </$select>\\n        </td>\\n      </tr>\\n      <tr>\\n        <td>Search:</td>\\n        <td>\\n          <$edit-text tiddler=\\\"$:/temp/quickConnectSearch\\\" type=\\\"text\\\" tag=\\\"input\\\" default=\\\"\\\"></$edit-text>\\n          <$checkbox\\n              tiddler=\\\"$:/state/tmap/tid-toolbar\\\"\\n              field=\\\"re-filter\\\"\\n              checked=\\\"1\\\"\\n              unchecked=\\\"\\\"\\n              default=\\\"\\\"> regexp\\n          </$checkbox>\\n<!--\\n          <small>(<$count filter=<<searchFilter>> /> results)</small>\\n-->\\n        </td>\\n      </tr>\\n      </table>\\n      <table class=\\\"tmap-create-connection-table\\\">\\n      <tr>\\n        <td colspan=\\\"2\\\">\\n          <table class=\\\"tmap-very-small-list\\\">\\n            <$list\\n                filter=<<searchFilter>>\\n                variable=\\\"item\\\">\\n            <tr><<searchResults>></tr>\\n            </$list>\\n            <tr>\\n            <$list filter=\\\"[{$:/temp/quickConnectSearch}regexp[.+]] -[is[tiddler]]\\\" variable=\\\"item\\\">\\n              <<searchResults>>\\n            </$list>\\n            </tr>\\n          </table>\\n        </td>\\n      </tr>\\n    </table>\\n    <div class=\\\"title\\\">Existing Connections</div>\\n    <div class=\\\"tmap-quick-connect-existing-bar\\\">\\n      <$select\\n          tiddler=\\\"$:/state/tmap/tid-toolbar\\\"\\n          field=\\\"direction\\\"\\n          default=\\\"both\\\">\\n          <option value=\\\"both\\\">both</option>\\n          <option value=\\\"in\\\">incoming</option>\\n          <option value=\\\"out\\\">outgoing</option>\\n      </$select>\\n      <$checkbox\\n          tiddler=\\\"$:/state/tmap/tid-toolbar\\\"\\n          field=\\\"filter.links\\\"\\n          checked=\\\"-[[tw-body:link]]\\\"\\n          unchecked=\\\"\\\"\\n          default=\\\"\\\"> hide links\\n      </$checkbox>\\n    </div>\\n    <table class=\\\"tmap-connection-table\\\">\\n<!--\\n    <tr>\\n      <th></th>\\n      <th>Tiddler</th>\\n      <th>Type</th>\\n      <th></th>\\n    </tr>\\n-->\\n    \\n    <$tmap-connections\\n        filter=<<tmap mergeFields \\\"$:/state/tmap/tid-toolbar\\\" \\\"filter.\\\">>\\n        direction={{$:/state/tmap/tid-toolbar!!direction}}\\n        emptyMessage=<<noConnectionsMsg>>>\\n      <tr>\\n        <td title=<<direction>>><<directionSymbol>></td>\\n        <td><$link to=<<neighbour>>><$view field=\\\"title\\\" /></$link></td>\\n        <td><<edge.type>></td>\\n        <td>\\n          <$button\\n              tooltip=\\\"Delete this connection\\\"\\n              class=\\\"tc-btn-invisible\\\">{{$:/core/images/close-button}}\\n            <$action-sendmessage $message=\\\"tmap:tm-remove-edge\\\"\\n                id=<<edge.id>>\\n                from=<<edge.from>>\\n                to=<<edge.to>>\\n                type=<<edge.type>> />\\n          </$button>\\n        </td>\\n      </tr>\\n    </$tmap-connections>\\n    </table>   \\n  </div>\\n</div>\\n</$set>\\n\\\\end\\n\\n<$list filter=\\\"[all[current]is[tiddler]]\\\"><$list filter=\\\"[{$:/temp/tmap/state/popup/quickConnect}prefix<qualify>]\\\" variable=\\\"item\\\" emptyMessage=<<hidePopup>>><<showPopup>></$list></$list>\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/media/fullscreen.png\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/media/fullscreen.png\",\n            \"type\": \"image/png\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffARwOKQxPfTsHAAAEcUlEQVRIx72XX0xTZxjGn+c9JcYQ50qM5RjKkOOG1NQEQiMV1tkLIbLsypCahsTojIkX6kgBr7aG7Wo6ou7STHbnjdGb/Ymb2ABODdiIxKR/IdoeR1PIKJAZdZntLnZq0CEWtHtuzjk57/l+3/e9J8/7fkQB8vv9DIfDHyqK8nEul2sSkS0AzABAMkNyAsBNAD9qmna9t7c397oxudzLXbt2icVi+YxkH0mQ/4YvdRWRxZ/6EonEmcHBweyKwR6P5wCAfhEBSWzatClls9mS27ZtS1dVVc1v3LgxAwDT09PmBw8erI9Go5ZIJFKZSqVUEUE2mwXJg/39/d8XDN63b9+XAD4nie3bt0dbWlpC9fX1eiFpGR8ftwYCAVsoFKoxdumrc+fOffFynLIE9AyAHpLYvXv3yNGjR4dUVV1AgSovL19wOp2Tjx49QiKRqCD5kcPhMAeDwSuvBHs8nq9FxEcSXq93wOPx3MUqZbfbf1+zZs2f0Wi0mmSjw+EoDQaDV/8D9ng8B0ieFBHs37//17a2tjDeUJqmzZSWls6HQiFNUZQmh8ORvH379t3nOW5vb1dMJtPfJLFnz56bHR0dQQDwer3HlhrwwoUL3y5+fl3cpUuXGoaHh3cCQCqVMl28ePGZAICiKMdJwm63R/PQt6m9e/cGbTZbhCRUVT0OACa/3894PN4HAK2traFCVriaHXC5XKFYLLYVQJ/f7z8tsVjMBQBWqzVVV1eno0iqra19qKpqSkSwsLDgEpJtJFFbW5tEkaVpWlJEUFJS0iYkdxrgdLHB1dXVacNenSaS75NEVVXV/EpzW2jO87JarfOGp39gImkWEeS9t5gqKyvLGGCzKV8E/i/lq5jkcrkMSUxPT5uLDZ2dnTWLCEQkIyISFxEkk8n1Lwd6vd5jr3Kl5fSq76amptYbFSsmInKLJOLxuKXYK9Z13WKAbwnJnwAgGo1WFhucTCYrFUUBgJ+loqJimCTS6bR67969imJBJyYmKmZnZ1URgcvlum7q7e3NHT582Aegb3Bw0Ga32x8ulbPVVKfFunPnjk1EkMvlfG63OysAkMlkzhrbvfXy5csNb3u1gUCg4f79+1sB4MmTJ2df6LmOHDlyUETOK4qC9vb2X5qbm6NvAzo2NlYzMDDQShLZbPbQiRMnzr/QgQSDwbEdO3aUkmyKRCJb1q1bN1dZWfnHm0IDgUCr8Sef6unpOblkzzU6Onq1sbHRTLIxEolsefr06bOampqp1UCHhoYabty44Tbyerarq8u3bJc5MjJyxel0liqK0qTrulXX9XfXrl3714YNGwrqNCcnJ63Xrl1zhsPhOsMeT/l8Pl/BDX13d/enAL4zLA4WiyWlaVpi8+bNaVVVF8rKyjJ5G5yZmXknkUhYdF1/b25uTs2fOkge6uzsPL/iI4zf75fHjx93KoryjclkgtGfgSQMI0B+YovvSXbV19efdrvdKz/CvDyBbDbbTPITkjtFRBOR54ZPclJEbgL4weFw/LYcMK9/AFcdm7xTEIntAAAAAElFTkSuQmCC\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/media/halfscreen.png\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/media/halfscreen.png\",\n            \"type\": \"image/png\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffBAgRIDS2XJMlAAAEdklEQVRIx72XX2xTZRjGn+f9TiAEGHYhlMIObut0dGTAQlP2R2e9GUmNN0vYRrkgICEhIeDSdXeaE70SJIKXZNM7bkjmhX+CMgZVM3BpGIHM9nQOtlO0ac3oSiRkxlEvPF0AYXaw+lydnO/L+X3v95687/MSRcgwDMZisdeVUm/l8/kWkjUAHCRBMgvgF5LDAL5yu90/GIaR/69vcqFFv98vTqfzXRE5CQDkP9tF5LF9IjK/Zis0NTV16vLlyw8XDe7s7NxP8jM7KmzcuDHl8XisLVu2pCsrK3Pr1q3LAkAmk3FMTk6uMU3TaZrmplQq5SKJfD4Pkgf6+/s/Lxq8Z8+eDwC8BwDbtm0z29rafm5oaEgWk5YbN27oQ0NDdWNjY7X2zXx45syZ95/cp5580dXVdYpkLwC0tbX9dOTIkYjL5bqHIuV0Ou81NjZO3L9/H5OTkxUk3/D5fI5oNHr+meCurq6PSIYAIBgMDnZ0dFzHc6q+vv7X5cuX/5FIJKpJNnq93pXRaPTCv8CdnZ37ReQ4Sezbt++7QCAQwwvK7Xb/vmrVqtzY2JhbKdXi8/mskZGR6/M53r17t9I07S+SCAQCw3v37o0uBhAMBo8+7f3Zs2c/BYCBgQFvJBJpBoBUKqWdO3duTgBA07RjJLF161ZzsdBi1N7eHq2rq4uLCDZs2HAMAGgYBhOJxEMACIfDX2zfvj35oqDCDRQiBoBYLFbR19fXDgBlZWUipmm2AoCu66mlgD5LHo/njsvlSimlkMvlWkVEAiICj8djocSqqamxSGLZsmUBIdlsnyhdanBVVVVaRCAiTRqAV0QElZWVuaUCPJrbR6Xres6u6a9qIuIgiULtLaXKy8uzSikAcGiFJvB/ab7DAciKCDKZjKPU0Lt37zrsHGeF5DhJWJa1ZqkAwWDw6NOqWSqVWmPfcEJE5ApJjI+PO0sdcTKZdNoRXxGSX5OEaZqbSg22LGuT3aO/EV3XvyeJdDrtunnzZkWpoBMTExXT09MuEUFra+sPmmEY+UOHDoVInoxEInX19fV3nrc2L6Rr167ViQjy+XzI7/c/FADIZrOnASAej28eGBjwLnW0Q0ND3tu3b28midnZ2dOPea7Dhw8fEJF+pRQ6Ojq+bWlpMZcCOjo6Wjs4OLjLNoAHe3t7+x9zINFodHTnzp0rRaQlHo/XrF69ekbX9ekXhV66dGmXbX9PhMPh40/1XCMjIxeampocJBvj8XjN7OzsXG1t7W/PA41EIt7h4eE37UhP9/T0hBZ0mVevXj3f3Ny8UinVYlmWnkwmX1qxYsWfa9euLcpp3rp1S7948WJTPB5vsMvjiVAoFCra0IfD4XdI9hWmhPXr16eqq6unqqqq0i6X6155eXnW/jEdmUymzLIsZzKZfHlmZsZVqMkkD3Z3d/cveoQxDEMePHjQLSIfa5oGkrArz/wYU3guNBu7+/Ts2LHjE7/fv/gR5skDzM3NvSYibwNoVkq5STqUUiCZJTmhlBrO5/Nf+ny+HxcCFvQ3ae6MHdgDqpkAAAAASUVORK5CYII=\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/icon\": {\n            \"tags\": \"$:/tags/Image\",\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/icon\",\n            \"text\": \"<svg\\n   xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\"\\n   xmlns:cc=\\\"http://creativecommons.org/ns#\\\"\\n   xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\"\\n   xmlns:svg=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n   xmlns:inkscape=\\\"http://www.inkscape.org/namespaces/inkscape\\\"\\n   class=\\\"tc-image-tiddlymap-button tc-image-button\\\"\\n   version=\\\"1.1\\\"\\n   width=\\\"22pt\\\"\\n   height=\\\"22pt\\\"\\n   viewBox=\\\"0 0 128 128\\\">\\n  <defs\\n     id=\\\"defs4\\\">\\n    <marker\\n       refX=\\\"0\\\"\\n       refY=\\\"0\\\"\\n       orient=\\\"auto\\\"\\n       id=\\\"Arrow1Lend\\\"\\n       style=\\\"overflow:visible\\\">\\n      <path\\n         d=\\\"M 0,0 5,-5 -12.5,0 5,5 0,0 z\\\"\\n         transform=\\\"matrix(-0.8,0,0,-0.8,-10,0)\\\"\\n         id=\\\"path3850\\\"\\n         style=\\\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt\\\" />\\n    </marker>\\n    <marker\\n       refX=\\\"0\\\"\\n       refY=\\\"0\\\"\\n       orient=\\\"auto\\\"\\n       id=\\\"Arrow1Lstart\\\"\\n       style=\\\"overflow:visible\\\">\\n      <path\\n         d=\\\"M 0,0 5,-5 -12.5,0 5,5 0,0 z\\\"\\n         transform=\\\"matrix(0.8,0,0,0.8,10,0)\\\"\\n         id=\\\"path3847\\\"\\n         style=\\\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt\\\" />\\n    </marker>\\n    <inkscape:path-effect\\n       effect=\\\"skeletal\\\"\\n       id=\\\"path-effect4329\\\" />\\n    <inkscape:path-effect\\n       effect=\\\"skeletal\\\"\\n       id=\\\"path-effect4321\\\" />\\n    <inkscape:path-effect\\n       effect=\\\"skeletal\\\"\\n       id=\\\"path-effect4315\\\" />\\n    <inkscape:path-effect\\n       effect=\\\"skeletal\\\"\\n       id=\\\"path-effect4307\\\" />\\n    <inkscape:path-effect\\n       effect=\\\"skeletal\\\"\\n       id=\\\"path-effect4299\\\" />\\n    <inkscape:path-effect\\n       effect=\\\"skeletal\\\"\\n       id=\\\"path-effect4293\\\" />\\n  </defs>\\n  <g\\n     transform=\\\"translate(0,-1024.5289)\\\"\\n     id=\\\"layer1\\\">\\n    <path\\n       d=\\\"m 17.867073,4.5821643 a 3.7249374,3.7249374 0 1 1 -7.449875,0 3.7249374,3.7249374 0 1 1 7.449875,0 z\\\"\\n       transform=\\\"matrix(-6.3328802,0,0,6.2775831,193.9581,1100.3667)\\\"\\n       id=\\\"path4139-1-14\\\"\\n       style=\\\"fill-opacity:1;fill-rule:nonzero\\\" />\\n    <path\\n       d=\\\"M 77.450496,1064.5069 C 58.849552,1025.9634 15.704158,1023.3858 2.8821873e-7,1034.558 L 0.02388589,1035.2674 C 24.502636,1022.2072 44.810725,1042.1507 60.163934,1074.112 z\\\"\\n       id=\\\"path4337\\\"\\n       style=\\\"fill-opacity:1;stroke-width:0.58181816;stroke-miterlimit:4;stroke-dasharray:none;marker-start:none;marker-end:none\\\" />\\n    <path\\n       d=\\\"m 12.878637,11.280739 4.75937,-2.7478243 4.759371,-2.7478236 0,5.4956479 0,5.495648 -4.759371,-2.747824 z\\\"\\n       transform=\\\"matrix(4.6545455,0,0,4.6545455,-13.580429,1027.7638)\\\"\\n       id=\\\"path3004\\\"\\n       style=\\\"fill-opacity:1;fill-rule:nonzero\\\" />\\n  </g>\\n  <metadata\\n     id=\\\"metadata3772\\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\\"\\\">\\n        <dc:title></dc:title>\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\\"http://purl.org/dc/dcmitype/StillImage\\\" />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n</svg>\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/media/surface.png\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/media/surface.png\",\n            \"type\": \"image/png\",\n            \"text\": \"iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAAmALMAAQfdEQQAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfeDBYVBDLiNMeiAAAFvUlEQVRIx7WXbUxTZxTH/+c8VwQLlAKuEotF2mJRlMFEqeCUiMzojH7YEjMSlM1EY2Z04vbBbUrcZqbOTZfFOKMOcWRuZMyoS4xUN16EMUVUMkAFJ6VQkdFSoOIL9O5DBREFX/l/vOf+z+88z715znkITyMZZMjDTLfEC0iWE0hAD0DlZhkC7HCDagWoxA0cvzq/uwgE+UkpachoJjhiCta6mXYwATLfN7AnM923MzGIuC8hARn/lN3ZiUy4nxlsyEM6QAcgPECdb6TNFDTbMn10UnOkMsap9dE5AMDSVaeqdlYoz9qL1WftReOuuS6HMDHcshsEfrdyXscPTw3W/cabieRPmYAEdcrltLD3q2ar32x4mq9S2HIi9LBl78QzracnMDEI9FlFin3jE8G6PN5JLK9hAt4Zv6ps0+TvyvAc+rLmo+m5DfungwhEvKs8uWVt/7h4CPorb2VJzmACPpy01bzO+MUFPKcSg+c2+kijOs85zoQTKF6TplA0ZrvyHwEb8pAOgW0kgE8m7zyZHr6uGi+o6IDpLQEjAp1/tZ7WMUkJY5f6WRqzOy48AP8CETSCylkAS3VrS1YbNl7CS9IkZcx/rm5XT1XHxVBBvCh+gfPzqlzIDAD6kVgDBhJGp1z+OPLrc3jJWhOx6ZwpKKmGiGEL1q4BAIYMYqYdBCBt/OoqDJPeGpteJZEEiUfsgAxi/TG8DgAG/yjb7FcWNAwXOD5oljVcMcEmSELSH/rXmYjngwnTgmZZHmeIPaFcPlTCJ8UH/GwWIoYkjZzPRDSDQJgWNKt54Is513drb3W7vIdK5uru9BkslnN9t3amWZPaB/aPaxYQYBImBsFAxJiojHEONB6u/z5mpPC+N1jihQXRi72Fz92hCrPfaQnIub5bCwB6/ygnEYNBEczEKiLGuPtnb3/dvN2o8mbvQRO33WtVyPLgjWhP7ZbEcF9jY74tzwAAY701DokkCJJU7KmAHzEtK01OjvR/tcFLeN/trXjganUKY7PSS9X5uPiMk2PSetzdYol2RUWdq0b94JD2dDKGDAcRw9pVp+pvAoAsk9m8Ur+heE/tlsSB367tXqsiy2Q26xTG5t4V9fdH+EU1laTcyE4NW1Xffq/Nd2FB9GLbbatKIgFBwiEJ4qtMrK5uv6TU+OgcM82aVIPfpKYsk9kMAKlhq+pTw1bVx55QLldIfl06hbG5zlWjLkq25vQWN9OsSV1YEL14iXZFRb4tzxDhF9XnB4CYgPg6ALjmqlF61oorDOZSAqPcUaoGgJX6DcUHTafMA7fu/DznvpX6DcUyZPRCe1WUbM0J9Aru3FO7JVGGjP7Q3uKyTGZzVUelmjxbXUqTT/rOkmTpT51vpC13RkkuhlHrK5e93XCrPkR298zmyrmdhTIR/r1VG3KmJV8zXNCKtjJNU5c1RJDAJNOcIgZBJlAGg/Czdf/E4QKbbx6dyCQgwBmZlOn2dKc2+y4AOGsvMn57ZfPUlw3NseydeslZbiQQ7tQH7Orrx1W5kEPTfBuIeFF158XQwJHBbUa/6NaXAT118/iEvKZDSUwCIHn5TylHyx+aQBoPuSpC05QKJk4osxfqVV7BbUa/Ka0vCs1p2PsGEwPg7dlxv2977MxlzW7PH7dMpSJQ/Fl7of5Wj6snLjCx6Xmgh60Hph5pykliYshw78qKO5Yx6LAHAJaDbSfC0gMVTFJCTcel0MsdlQF+kv/dsT7a9qcBXnT+HfqjZY+pzF4Q4xlvsf3A1IehQw70cwoi3yPQPkECRIzxowy2aOW0+skBsc3higntY7w1DgC4cbtRZem65l/dflFd01GpvXnHFkIgeMZaWr4v9sj+Z77CZMrg0sKoD4jFV17sBYAgSAITQ5Dk2TLP2QuA+p4TaP2412K/yaTMZ7/CDCzgfElcIhEvJNAMiSQdEasESSBiB4PrBIsSctOx8XHTiocC9up/PG8QrAaKLngAAAAASUVORK5CYII=\"\n        },\n        \"$:/language/Buttons/TiddlyMap/Caption\": {\n            \"title\": \"$:/language/Buttons/TiddlyMap/Caption\",\n            \"text\": \"tiddlymap\"\n        },\n        \"$:/language/Buttons/TiddlyMap/Hint\": {\n            \"title\": \"$:/language/Buttons/TiddlyMap/Hint\",\n            \"text\": \"Toggle TiddlyMap actions\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/misc/macros\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/misc/macros\",\n            \"text\": \"\\\\define concat(str) $str$\\n\\n\\\\define input-text(field, index, default, readonly)\\n  <$reveal type=\\\"match\\\" text=\\\"\\\" default=\\\"$readonly$\\\">\\n    <$edit-text tiddler=<<output>> field=\\\"$field$\\\" index=\\\"$index$\\\" type=\\\"text\\\" tag=\\\"input\\\" default=\\\"$default$\\\" />\\n  </$reveal>\\n  <$reveal type=\\\"nomatch\\\" text=\\\"\\\" default=\\\"$readonly$\\\">\\n    <input type=\\\"text\\\" value=\\\"$default$\\\" readonly=\\\"true\\\" disabled=\\\"true\\\" />\\n  </$reveal>\\n\\\\end\\n\\n\\\\define input-button(field, index, default, default, label:\\\"Proceed\\\")\\n  <div class=\\\"tmap-button-wrapper\\\">\\n  <$button>$label$\\n    <$action-setfield $tiddler=<<output>> $field=\\\"$field$\\\" index=\\\"$index$\\\" $value=\\\"$default$\\\" />\\n  </$button>\\n  </div>\\n\\\\end\\n\\n\\\\define input-textarea(field, index, default, default)\\n  <$edit-text tiddler=<<output>> field=\\\"$field$\\\" index=\\\"$index$\\\" autoHeight=\\\"no\\\" type=\\\"text\\\" tag=\\\"textarea\\\" default=\\\"$default$\\\" />\\n\\\\end\\n\\n\\\\define input-checkbox(field, index, readonly, default)\\n  <$reveal type=\\\"match\\\" text=\\\"\\\" default=\\\"$readonly$\\\">\\n    <$checkbox\\n        tiddler=<<output>>\\n        field=\\\"$field$\\\"\\n        index=\\\"$index$\\\"\\n        checked=\\\"true\\\"\\n        unchecked=\\\"false\\\"\\n        default=\\\"$default$\\\" />\\n  </$reveal>\\n  <$reveal type=\\\"nomatch\\\" text=\\\"\\\" default=\\\"$readonly$\\\">\\n    <input type=\\\"checkbox\\\" value=\\\"$default$\\\" readonly=\\\"true\\\" disabled=\\\"true\\\" />\\n  </$reveal>\\n\\\\end\\n\\n\\\\define input-multi-checkbox(selectFilter, invert:\\\"no\\\", default)\\n  <div class=\\\"tmap-no-stretch\\\">\\n  <$list\\n      filter=\\\"$selectFilter$\\\"\\n      emptyMessage=\\\"– This list contains no items –\\\">\\n    <$checkbox\\n        tiddler=<<output>>\\n        tag=<<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"0\\\">>>\\n      <$view\\n          tiddler=<<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"1\\\">>\\n          field=\\\"title\\\" />\\n    </$checkbox><br />\\n  </$list>\\n  </div>\\n\\\\end\\n\\n\\\\define input-select(field, index, selectFilter, default, nochoice)\\n  <$select\\n      tiddler=<<output>>\\n      field=\\\"$field$\\\"\\n      index=\\\"$index$\\\"\\n      default=\\\"$default$\\\">\\n    <$set name=\\\"nochoice\\\" value=\\\"$nochoice$\\\">\\n      <$list filter=\\\"[<nochoice>regexp[.+]]\\\">\\n        <option value=\\\"\\\"><b><<nochoice>></b></option>\\n      </$list>\\n    </$set>\\n    <$list filter=\\\"$selectFilter$\\\">\\n      <option value=<<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"0\\\">> >\\n        <$view tiddler=<<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"1\\\">> field=\\\"title\\\" />   \\n      </option>\\n    </$list> \\n  </$select>\\n\\\\end\\n\\n\\\\define input-radio(field, index, selectFilter, default)\\n  <$list filter=\\\"$selectFilter$\\\">\\n    <$radio\\n        tiddler=<<output>>\\n        field=\\\"$field$\\\"\\n        index=\\\"$index$\\\"\\n        value=<<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"0\\\">>>\\n      <<tmap \\\"splitAndSelect\\\" \\\"|\\\" \\\"1\\\">>\\n    </$radio><br />\\n  </$list>\\n\\\\end\\n\\n\\\\define tmap-row(title, field, index, type, descr, note, label, default, readonly, reset, selectFilter, nochoice, invert)\\n  <tr>\\n    <td class=\\\"tmap-title\\\">$title$:</td>\\n    <td>\\n        <<$type$\\n          field:\\\"$field$\\\"\\n          index:\\\"$index$\\\"\\n          readonly:\\\"$readonly$\\\"\\n          default:\\\"$default$\\\"\\n          label:\\\"$label$\\\"\\n          invert:\\\"$invert$\\\"\\n          selectFilter:\\\"$selectFilter$\\\"\\n          nochoice:\\\"$nochoice$\\\" >>\\n        <$reveal type=\\\"match\\\" text=\\\"true\\\" default=\\\"$reset$\\\">\\n          <$button>reset\\n            <$action-setfield $tiddler=<<output>> $field=\\\"$field$\\\" $index=\\\"$index$\\\" $value=\\\"$default$\\\" />\\n          </$button>\\n        </$reveal>\\n    </td>\\n    <td>\\n      <span class=\\\"tmap-description\\\">$descr$</span>\\n      <$reveal type=\\\"nomatch\\\" text=\\\"\\\" default=\\\"$note$\\\">\\n        <div class=\\\"tmap-note\\\">''Note:'' $note$</div>\\n      </$reveal>\\n    </td>\\n  </tr>\\n\\\\end\\n\\n\\\\define visConfiguration(inheritedList,\\n                         extensionField,\\n                         styleName:\\\"style\\\")\\n                         \\n  <fieldset><legend>Visjs configurations ($styleName$)</legend>\\n    <div class=\\\"tmap-flash-message tmap-info\\\">\\n      Only config items that you actually changed have an effect on\\n      the graph. Other options are visible, yet, inactive.\\n    </div>\\n    <$tmap-config\\n        mode=\\\"manage-node-types\\\"\\n        inherited=\\\"$inheritedList$\\\"\\n        extension=\\\"$extensionField$\\\"\\n    />\\n  </fieldset>\\n\\\\end\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/misc/defaultViewHolder\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/misc/defaultViewHolder\",\n            \"text\": \"Default\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:central-topic\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:central-topic\",\n            \"description\": \"The style is applied to the node that you marked as central topic in a map.\",\n            \"style\": \"{\\\"font\\\":{\\\"size\\\":22,\\\"color\\\":\\\"rgba(0,0,0,1)\\\"},\\\"shape\\\":\\\"star\\\"}\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:neighbour\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:neighbour\",\n            \"description\": \"Neighbours are all nodes that are not part of the original set of nodes (\\\"matches\\\") but are connected (either outgoing or incoming) to a node of the original set.\",\n            \"style\": \"{\\\"color\\\":\\\"#565656\\\"}\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/edges\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/edges\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/nodes\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/nodes\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Default\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Default\",\n            \"config.physics_mode\": \"false\",\n            \"isview\": \"true\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/edges\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/edges\",\n            \"filter\": \"[prefix[$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes]]\",\n            \"text\": \"\\n\\n\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/nodes\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/nodes\",\n            \"filter\": \"[field:title{$:/temp/tmap/currentTiddler}]\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Live View\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Live View\",\n            \"config.neighbourhood_scope\": \"1\",\n            \"config.refresh-triggers\": \"$:/temp/tmap/currentTiddler\",\n            \"config.physics_mode\": \"true\",\n            \"config.vis\": \"{\\\"physics\\\":{\\\"forceAtlas2Based\\\":{\\\"springLength\\\":0,\\\"springConstant\\\":0.09}}}\",\n            \"isview\": \"true\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search/filter/nodes\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search/filter/nodes\",\n            \"filter\": \"[!is[system]search{$:/temp/search}] [!is[system]search:tags{$:/temp/search}] [!is[system]search:text{$:/temp/search}limit[10]]\"\n        },\n        \"$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search\": {\n            \"title\": \"$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search\",\n            \"config.refresh-triggers\": \"$:/temp/search\",\n            \"config.neighbourhood_scope\": \"1\",\n            \"config.physics_mode\": \"true\"\n        }\n    }\n}"
  }
]